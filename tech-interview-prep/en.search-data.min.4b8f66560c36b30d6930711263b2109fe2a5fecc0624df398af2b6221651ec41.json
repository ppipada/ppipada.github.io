[{"id":0,"href":"/tech-interview-prep/levels/problems/","title":"Problems","section":"Path: Levels","content":"Levels: Problems# Work problems in increasing difficulty.\nLevel 0 (4) Level 1 (7) Level 2 (11) Level 3 (18) Level 4 (22) Level 5 (11) Level 0 Contains duplicateInvert a binary treeMaximum depth of binary treeTwo sumLevel 1 Best time to buy and sell stockLinked list cycleNumber of 1 bitsReverse linked listSum of two integersValid anagramValid parenthesesLevel 2 Container with most waterFind minimum in rotated sorted arrayLowest common ancestor of a binary search treeMaximum subarrayMissing numberReverse bitsSame treeSpiral matrixThree sumValid palindromeValidate a binary search treeLevel 3 Binary tree level order traversalClimbing stairsClone graphCoin changeConstruct binary tree from preorder and inorder traversalGroup anagramsHouse robberKth smallest element in a BSTMaximum product subarrayMerge intervalsProduct of array except selfRemove n\u0026#39;th node from end of listReorder listRotate imageSearch in rotated sorted arraySet matrix zeroesSubtree of another treeTop k frequent elementsLevel 4 Add and search word - data structure designCombination sum IVCounting bitsCourse scheduleDecode waysEncode and decode stringsHouse robber IIImplement trie (prefix tree)Jump gameLongest increasing subsequenceLongest palindromic substringLongest repeating character replacementLongest substring without repeating charactersMeeting roomsMeeting rooms IINon overlapping intervalsNumber of islandsPacific-Atlantic water flowPalindromic substringsUnique pathsWord breakWord searchLevel 5 Alien dictionaryBinary tree maximum path sumFind median from data streamGraph valid treeInsert intervalLongest consecutive sequenceMerge k sorted listsMinimum window substringNumber of connected components in an undirected graphSerialize and deserialize a binary treeWord search II "},{"id":1,"href":"/tech-interview-prep/patterns/problems/","title":"Problems","section":"Path: Patterns","content":"Patterns: Problems# Patterns cut across data structures and show up frequently in interviews.\nBacktracking (3) Intervals (5) Sliding Window (3) Union Find (2) Backtracking Add and search word - data structure designWord searchWord search IIIntervals Insert intervalMeeting roomsMeeting rooms IIMerge intervalsNon overlapping intervalsSliding Window Longest repeating character replacementLongest substring without repeating charactersMinimum window substringUnion Find Longest consecutive sequenceNumber of islands "},{"id":2,"href":"/tech-interview-prep/data-structures/quick-notes/","title":"Quick Notes","section":"Path: Data Structures","content":"Data Structures: Quick Notes# Complexity summary# Worst case time and space complexity:\nData Structure Access Search Insertion Deletion Space complexity Array O(1) O(n) O(n) O(n) O(n) Stack O(n) O(n) O(1) O(1) O(n) Queue O(n) O(n) O(1) O(1) O(n) Singly-Linked List O(n) O(n) O(1) O(1) O(n) Doubly-Linked List O(n) O(n) O(1) O(1) O(n) Skip List O(n) O(n) O(n) O(n) O(n log(n)) Hash Table N/A O(n) O(n) O(n) O(n) Binary Search Tree O(n) O(n) O(n) O(n) O(n) B-Tree O(log(n)) O(log(n)) O(log(n)) O(log(n)) O(n) Red-Black Tree O(log(n)) O(log(n)) O(log(n)) O(log(n)) O(n) AVL Tree O(log(n)) O(log(n)) O(log(n)) O(log(n)) O(n) Linked List# A linked list is a linear collection of nodes, each pointing to the next node. Singly-linked list: each node points to the next node; last points to null. Doubly-linked list: nodes have pointers to previous and next nodes. Circular-linked list: last node points back to first. Stack# Push / pop LIFO (last in, first out) Queue# Enqueue / dequeue FIFO (first in, first out) Tree# A tree is an undirected, connected, acyclic graph.\nBinary Tree# Node has at most two children: left and right Full tree: every node has 0 or 2 children Perfect binary tree: all interior nodes have two children and all leaves have the same depth Complete tree: all levels full except possibly last; last is left-packed Binary Search Tree# A BST maintains: left subtree values ≤ node ≤ right subtree values.\nTrie# A trie (prefix tree) stores a set of strings by shared prefixes.\nFenwick Tree (Binary Indexed Tree)# Range sum / update in O(log n).\nSegment Tree# Range queries / updates in O(log n).\nHeap# Max heap / min heap Insert / remove in O(log n), peek in O(1) Hash map# Collision resolution:\nSeparate chaining Open addressing Graph# "},{"id":3,"href":"/tech-interview-prep/data-structures/problems/","title":"Problems","section":"Path: Data Structures","content":"Data Structures: Problems# Pick a data structure and drill problems tagged with it.\nArray (29) Bits (5) Graph (7) Hash Table (8) Heap (3) Linkedlist (5) Stack (1) String (12) Tree (11) Trie (3) Array Best time to buy and sell stockCombination sum IVConstruct binary tree from preorder and inorder traversalContainer with most waterContains duplicateCounting bitsFind minimum in rotated sorted arrayHouse robberHouse robber IIInsert intervalJump gameLongest consecutive sequenceLongest increasing subsequenceMaximum product subarrayMaximum subarrayMeeting roomsMeeting rooms IIMerge intervalsMissing numberNon overlapping intervalsProduct of array except selfRotate imageSearch in rotated sorted arraySet matrix zeroesSpiral matrixThree sumTwo sumUnique pathsWord searchBits Counting bitsMissing numberNumber of 1 bitsReverse bitsSum of two integersGraph Alien dictionaryClone graphCourse scheduleGraph valid treeNumber of connected components in an undirected graphNumber of islandsPacific-Atlantic water flowHash Table Contains duplicateGroup anagramsLongest substring without repeating charactersMinimum window substringThree sumTop k frequent elementsTwo sumValid anagramHeap Find median from data streamMerge k sorted listsTop k frequent elementsLinkedlist Linked list cycleMerge k sorted listsRemove n\u0026#39;th node from end of listReorder listReverse linked listStack Valid parenthesesString Decode waysEncode and decode stringsGroup anagramsLongest palindromic substringLongest repeating character replacementLongest substring without repeating charactersMinimum window substringPalindromic substringsValid anagramValid palindromeValid parenthesesWord breakTree Binary tree level order traversalBinary tree maximum path sumConstruct binary tree from preorder and inorder traversalInvert a binary treeKth smallest element in a BSTLowest common ancestor of a binary search treeMaximum depth of binary treeSame treeSerialize and deserialize a binary treeSubtree of another treeValidate a binary search treeTrie Add and search word - data structure designImplement trie (prefix tree)Word search II "},{"id":4,"href":"/tech-interview-prep/algorithms/problems/","title":"Problems","section":"Path: Algorithms","content":"Algorithms: Problems# Approach problems by core Algorithms / techniques (DP/DFS/BFS/etc.).\nBfs (5) Binary Search (4) Dfs (9) Divide and Conquer (2) Dynamic Programming (14) Greedy (1) Bfs Binary tree level order traversalClone graphCourse scheduleNumber of islandsPacific-Atlantic water flowBinary Search Find minimum in rotated sorted arrayKth smallest element in a BSTLongest increasing subsequenceSearch in rotated sorted arrayDfs Binary tree maximum path sumClone graphConstruct binary tree from preorder and inorder traversalCourse scheduleMaximum depth of binary treeNumber of islandsPacific-Atlantic water flowSame treeValidate a binary search treeDivide and Conquer Maximum subarrayMerge k sorted listsDynamic Programming Climbing stairsCoin changeCombination sum IVCounting bitsDecode waysHouse robberHouse robber IIJump gameLongest increasing subsequenceLongest palindromic substringMaximum subarrayPalindromic substringsUnique pathsWord breakGreedy Non overlapping intervals "},{"id":5,"href":"/tech-interview-prep/problems/","title":"All Problems","section":"Tech Interview Prep","content":"All Problems# This is the complete problem bank.\nBelow is the list of all problems in this section.\n"},{"id":6,"href":"/tech-interview-prep/algorithms/quick-notes/","title":"Quick Notes","section":"Path: Algorithms","content":"Algorithms: Quick Notes# Bitmasks# Bitmasking is a technique used to perform operations at the bit level. It often leads to faster runtime and helps limit memory usage.\nOperation Expression Test kth bit s \u0026amp; (1 \u0026lt;\u0026lt; k) Set kth bit s = (1 \u0026lt;\u0026lt; k) Turn off kth bit s \u0026amp;= ~(1 \u0026lt;\u0026lt; k) Toggle kth bit s ^= (1 \u0026lt;\u0026lt; k) Multiply by 2^n s \u0026lt;\u0026lt; n Divide by 2^n s \u0026gt;\u0026gt; n Intersection s \u0026amp; t Union s | t Set subtraction s \u0026amp; ~t Extract lowest set bit s \u0026amp; (-s) Extract lowest unset bit ~s \u0026amp; (s + 1) Swap values x ^= y; y ^= x; x ^= y; Sorting# Complexity summary# Algorithm Best Average Worst Space Quicksort Ω(n log n) Θ(n log n) O(n^2) O(log n) Mergesort Ω(n log n) Θ(n log n) O(n log n) O(n) Timsort Ω(n) Θ(n log n) O(n log n) O(n) Heapsort Ω(n log n) Θ(n log n) O(n log n) O(1) Bubble Sort Ω(n) Θ(n^2) O(n^2) O(1) Insertion Sort Ω(n) Θ(n^2) O(n^2) O(1) Selection Sort Ω(n^2) Θ(n^2) O(n^2) O(1) Shell Sort Ω(n log n) Θ(n(log n)^2) O(n(log n)^2) O(1) Bucket Sort Ω(n+k) Θ(n+k) O(n^2) O(n) Radix Sort Ω(nk) Θ(nk) O(nk) O(n+k) Counting Sort Ω(n+k) Θ(n+k) O(n+k) O(k) Quicksort# Divide and conquer with partition around a pivot. Stable: No Mergesort# Divide array, sort halves, merge. Stable: Yes Bucket Sort# Radix Sort# Radix sort distributes items by digit (or bit groups) across multiple passes.\nGraph Algorithms# Traversal: Depth First Search (DFS)# DFS explores as far as possible along each branch before backtracking. Time: O(|V| + |E|) Traversal: Breadth First Search (BFS)# BFS explores neighbors first, then moves level-by-level. Time: O(|V| + |E|) Topological Sort# Linear ordering of a DAG such that for every edge u -\u0026gt; v, u comes before v. Time: O(|V| + |E|) Shortest path: Dijkstra# Shortest paths from a single source with non-negative weights. Time: O(|V|^2) (basic); can be improved with heaps. Shortest path: Bellman–Ford# Handles negative weights (but not negative cycles). Time: Best: O(|E|) Worst: O(|V||E|) Shortest path: Floyd–Warshall# All-pairs shortest paths. Time: O(|V|^3) MST: Prim# Greedy MST for connected, undirected weighted graph. Time: O(E log V) with a heap-based implementation. Python# 1# A Python program for Prims\u0026#39;s MST for 2# adjacency list representation of graph 3# Source GeeksForGeeks 4 5from collections import defaultdict 6import sys 7 8 9class Heap(): 10 def __init__(self): 11 self.array = [] 12 self.size = 0 13 self.pos = [] 14 15 def newMinHeapNode(self, v, dist): 16 minHeapNode = [v, dist] 17 return minHeapNode 18 19 # A utility function to swap two nodes of 20 # min heap. Needed for min heapify 21 def swapMinHeapNode(self, a, b): 22 t = self.array[a] 23 self.array[a] = self.array[b] 24 self.array[b] = t 25 26 # A standard function to heapify at given idx 27 # This function also updates position of nodes 28 # when they are swapped. Position is needed 29 # for decreaseKey() 30 def minHeapify(self, idx): 31 smallest = idx 32 left = 2 * idx + 1 33 right = 2 * idx + 2 34 35 if left \u0026lt; self.size and self.array[left][1] \u0026lt; self.array[smallest][1]: 36 smallest = left 37 38 if right \u0026lt; self.size and self.array[right][1] \u0026lt; self.array[smallest][1]: 39 smallest = right 40 41 # The nodes to be swapped in min heap 42 # if idx is not smallest 43 if smallest != idx: 44 45 # Swap positions 46 self.pos[self.array[smallest][0]] = idx 47 self.pos[self.array[idx][0]] = smallest 48 49 # Swap nodes 50 self.swapMinHeapNode(smallest, idx) 51 52 self.minHeapify(smallest) 53 54 # Standard function to extract minimum node from heap 55 def extractMin(self): 56 57 # Return NULL wif heap is empty 58 if self.isEmpty() == True: 59 return 60 61 # Store the root node 62 root = self.array[0] 63 64 # Replace root node with last node 65 lastNode = self.array[self.size - 1] 66 self.array[0] = lastNode 67 68 # Update position of last node 69 self.pos[lastNode[0]] = 0 70 self.pos[root[0]] = self.size - 1 71 72 # Reduce heap size and heapify root 73 self.size -= 1 74 self.minHeapify(0) 75 76 return root 77 78 def isEmpty(self): 79 return True if self.size == 0 else False 80 81 def decreaseKey(self, v, dist): 82 83 # Get the index of v in heap array 84 85 i = self.pos[v] 86 87 # Get the node and update its dist value 88 self.array[i][1] = dist 89 90 # Travel up while the complete tree is not 91 # hepified. This is a O(Logn) loop 92 while i \u0026gt; 0 and self.array[i][1] \u0026lt; self.array[(i - 1) / 2][1]: 93 94 # Swap this node with its parent 95 self.pos[self.array[i][0]] = (i - 1) / 2 96 self.pos[self.array[(i - 1) / 2][0]] = i 97 self.swapMinHeapNode(i, (i - 1) / 2) 98 99 # move to parent index 100 i = (i - 1) / 2 101 102 # A utility function to check if a given vertex 103 # \u0026#39;v\u0026#39; is in min heap or not 104 def isInMinHeap(self, v): 105 106 if self.pos[v] \u0026lt; self.size: 107 return True 108 return False 109 110 111def printArr(parent, n): 112 for i in range(1, n): 113 print(\u0026#34;% d - % d\u0026#34; % (parent[i], i)) 114 115 116class Graph(): 117 def __init__(self, V): 118 self.V = V 119 self.graph = defaultdict(list) 120 121 # Adds an edge to an undirected graph 122 def addEdge(self, src, dest, weight): 123 124 # Add an edge from src to dest. A new node is 125 # added to the adjacency list of src. The node 126 # is added at the begining. The first element of 127 # the node has the destination and the second 128 # elements has the weight 129 newNode = [dest, weight] 130 self.graph[src].insert(0, newNode) 131 132 # Since graph is undirected, add an edge from 133 # dest to src also 134 newNode = [src, weight] 135 self.graph[dest].insert(0, newNode) 136 137 # The main function that prints the Minimum 138 # Spanning Tree(MST) using the Prim\u0026#39;s Algorithm. 139 # It is a O(ELogV) function 140 def PrimMST(self): 141 # Get the number of vertices in graph 142 V = self.V 143 144 # key values used to pick minimum weight edge in cut 145 key = [] 146 147 # List to store contructed MST 148 parent = [] 149 150 # minHeap represents set E 151 minHeap = Heap() 152 153 # Initialize min heap with all vertices. Key values of all 154 # vertices (except the 0th vertex) is is initially infinite 155 for v in range(V): 156 parent.append(-1) 157 key.append(sys.maxsize) 158 minHeap.array.append(minHeap.newMinHeapNode(v, key[v])) 159 minHeap.pos.append(v) 160 161 # Make key value of 0th vertex as 0 so 162 # that it is extracted first 163 minHeap.pos[0] = 0 164 key[0] = 0 165 minHeap.decreaseKey(0, key[0]) 166 167 # Initially size of min heap is equal to V 168 minHeap.size = V 169 170 # In the following loop, min heap contains all nodes 171 # not yet added in the MST. 172 while minHeap.isEmpty() == False: 173 174 # Extract the vertex with minimum distance value 175 newHeapNode = minHeap.extractMin() 176 u = newHeapNode[0] 177 178 # Traverse through all adjacent vertices of u 179 # (the extracted vertex) and update their 180 # distance values 181 for pCrawl in self.graph[u]: 182 183 v = pCrawl[0] 184 185 # If shortest distance to v is not finalized 186 # yet, and distance to v through u is less than 187 # its previously calculated distance 188 if minHeap.isInMinHeap(v) and pCrawl[1] \u0026lt; key[v]: 189 key[v] = pCrawl[1] 190 parent[v] = u 191 192 # update distance value in min heap also 193 minHeap.decreaseKey(v, key[v]) 194 195 printArr(parent, V) 196 197 198# Driver program to test the above functions 199graph = Graph(9) 200graph.addEdge(0, 1, 4) 201graph.addEdge(0, 7, 8) 202graph.addEdge(1, 2, 8) 203graph.addEdge(1, 7, 11) 204graph.addEdge(2, 3, 7) 205graph.addEdge(2, 8, 2) 206graph.addEdge(2, 5, 4) 207graph.addEdge(3, 4, 9) 208graph.addEdge(3, 5, 14) 209graph.addEdge(4, 5, 10) 210graph.addEdge(5, 6, 2) 211graph.addEdge(6, 7, 1) 212graph.addEdge(6, 8, 6) 213graph.addEdge(7, 8, 7) 214graph.PrimMST() MST: Kruskal# Greedy MST using sorting + union-find. Time: O(E log E) (sorting dominates). Python# 1# Python program for Kruskal\u0026#39;s algorithm to find 2# Minimum Spanning Tree of a given connected, 3# undirected and weighted graph. Source: GeeksForGeeks. 4 5 6#Class to represent a graph 7class Graph: 8 def __init__(self, vertices): 9 self.V = vertices #No. of vertices 10 self.graph = [] 11 12 # function to add an edge to graph 13 def addEdge(self, u, v, w): 14 self.graph.append([u, v, w]) 15 16 # A utility function to find set of an element i 17 # (uses path compression technique) 18 def find(self, parent, i): 19 if parent[i] == i: 20 return i 21 return self.find(parent, parent[i]) 22 23 # A function that does union of two sets of x and y 24 # (uses union by rank) 25 def union(self, parent, rank, x, y): 26 xroot = self.find(parent, x) 27 yroot = self.find(parent, y) 28 29 # Attach smaller rank tree under root of 30 # high rank tree (Union by Rank) 31 if rank[xroot] \u0026lt; rank[yroot]: 32 parent[xroot] = yroot 33 elif rank[xroot] \u0026gt; rank[yroot]: 34 parent[yroot] = xroot 35 36 # If ranks are same, then make one as root 37 # and increment its rank by one 38 else: 39 parent[yroot] = xroot 40 rank[xroot] += 1 41 42 # The main function to construct MST using Kruskal\u0026#39;s 43 # algorithm 44 def KruskalMST(self): 45 46 result = [] #This will store the resultant MST 47 48 i = 0 # An index variable, used for sorted edges 49 e = 0 # An index variable, used for result[] 50 51 # Step 1: Sort all the edges in non-decreasing 52 # order of their 53 # weight. If we are not allowed to change the 54 # given graph, we can create a copy of graph 55 self.graph = sorted(self.graph, key=lambda item: item[2]) 56 57 parent = [] 58 rank = [] 59 60 # Create V subsets with single elements 61 for node in range(self.V): 62 parent.append(node) 63 rank.append(0) 64 65 # Number of edges to be taken is equal to V-1 66 while e \u0026lt; self.V - 1: 67 68 # Step 2: Pick the smallest edge and increment 69 # the index for next iteration 70 u, v, w = self.graph[i] 71 i = i + 1 72 x = self.find(parent, u) 73 y = self.find(parent, v) 74 75 # If including this edge does\u0026#39;t cause cycle, 76 # include it in result and increment the index 77 # of result for next edge 78 if x != y: 79 e = e + 1 80 result.append([u, v, w]) 81 self.union(parent, rank, x, y) 82 # Else discard the edge 83 84 # print the contents of result[] to display the built MST 85 print(\u0026#34;Following are the edges in the constructed MST\u0026#34;) 86 for u, v, weight in result: 87 #print str(u) + \u0026#34; -- \u0026#34; + str(v) + \u0026#34; == \u0026#34; + str(weight) 88 print(\u0026#34;%d -- %d == %d\u0026#34; % (u, v, weight)) 89 90 91# Driver code 92g = Graph(4) 93g.addEdge(0, 1, 10) 94g.addEdge(0, 2, 6) 95g.addEdge(0, 3, 5) 96g.addEdge(1, 3, 15) 97g.addEdge(2, 3, 4) 98 99g.KruskalMST() Greedy Algorithms'# Greedy algorithms make locally optimal choices at each step in the hope of reaching a global optimum.\nGreedy is typically applicable when the problem exhibits:\nOptimal substructure Greedy choice property Example problem:\nCoin Change "},{"id":7,"href":"/tech-interview-prep/system-design/","title":"System Design","section":"Tech Interview Prep","content":"System Design# For system design preparation, I primarily rely on:\nSystem Design Primer Grokking the System Design Interview This book focuses mostly on DS/Algo + coding interview patterns, and links out for system design.\n"},{"id":8,"href":"/tech-interview-prep/external/","title":"External References","section":"Tech Interview Prep","content":"External References# Educative: Grokking the System Design Interview System Design Primer ProgramCreek: Top algorithms for interviews Kevin Naughton Jr.: Interviews repo Leetcode implementations Big O notation cheat sheet "},{"id":9,"href":"/tech-interview-prep/problems/add-and-search-word/","title":"Add and search word - data structure design","section":"All Problems","content":" Levels:\u0026ensp;level-4 Data structures:\u0026ensp;trie Patterns:\u0026ensp;backtracking Practice Link: LeetCode\nDescription:\nDesign a data structure that supports the following two operations:\n1void addWord(word) 2bool search(word) Search(word) can search a literal word or a regular expression string containing only letters a-z or ..\nA .means it can represent any one letter.\nYou may assume that all words are consist of lowercase letters a-z.\nExample:\n1addWord(\u0026#34;bad\u0026#34;) 2addWord(\u0026#34;dad\u0026#34;) 3addWord(\u0026#34;mad\u0026#34;) 4search(\u0026#34;pad\u0026#34;) -\u0026gt; false 5search(\u0026#34;bad\u0026#34;) -\u0026gt; true 6search(\u0026#34;.ad\u0026#34;) -\u0026gt; true 7search(\u0026#34;b..\u0026#34;) -\u0026gt; truePython Solution:\n1import collections 2 3 4class TrieNode(): 5 def __init__(self): 6 self.children = collections.defaultdict(TrieNode) 7 self.isWord = False 8 9 10class WordDictionary(object): 11 def __init__(self): 12 \u0026#34;\u0026#34;\u0026#34; 13 Initialize your data structure here. 14 \u0026#34;\u0026#34;\u0026#34; 15 self.root = TrieNode() 16 17 def addWord(self, word): 18 \u0026#34;\u0026#34;\u0026#34; 19 Adds a word into the data structure. 20 :type word: str 21 :rtype: None 22 \u0026#34;\u0026#34;\u0026#34; 23 node = self.root 24 for w in word: 25 node = node.children[w] 26 node.isWord = True 27 28 def search(self, word): 29 \u0026#34;\u0026#34;\u0026#34; 30 Returns if the word is in the data structure. A word could contain the dot character \u0026#39;.\u0026#39; to represent any one letter. 31 :type word: str 32 :rtype: bool 33 \u0026#34;\u0026#34;\u0026#34; 34 node = self.root 35 self.res = False 36 self.dfs(node, word) 37 return self.res 38 39 def dfs(self, node, word): 40 if not word: 41 if node.isWord: 42 self.res = True 43 return 44 if word[0] == \u0026#34;.\u0026#34;: 45 for n in node.children.values(): 46 self.dfs(n, word[1:]) 47 else: 48 node = node.children.get(word[0]) 49 if not node: 50 return 51 self.dfs(node, word[1:]) 52 53 54# Your WordDictionary object will be instantiated and called as such: 55# obj = WordDictionary() 56# obj.addWord(word) 57# param_2 = obj.search(word) "},{"id":10,"href":"/tech-interview-prep/problems/alien-dictionary/","title":"Alien dictionary","section":"All Problems","content":" Levels:\u0026ensp;level-5 Data structures:\u0026ensp;graph Description:\nThere is a new alien language which uses the latin alphabet. However, the order among letters are unknown to you. You receive a list of words from the dictionary, where words are sorted lexicographically by the rules of this new language. Derive the order of letters in this language. Example 1:\n1Given the following words in dictionary, 2[ 3 \u0026#34;wrt\u0026#34;, 4 \u0026#34;wrf\u0026#34;, 5 \u0026#34;er\u0026#34;, 6 \u0026#34;ett\u0026#34;, 7 \u0026#34;rftt\u0026#34; 8] 9 10The correct order is: \u0026#34;wertf\u0026#34;.Example 2:\n1Input: 2[ 3 \u0026#34;z\u0026#34;, 4 \u0026#34;x\u0026#34; 5] 6Output: \u0026#34;zx\u0026#34;Example 3:\n1Input: 2[ 3 \u0026#34;z\u0026#34;, 4 \u0026#34;x\u0026#34;, 5 \u0026#34;z\u0026#34; 6] 7Output: \u0026#34;\u0026#34; 8Explanation: The order is invalid, so return \u0026#34;\u0026#34;.Note:\nYou may assume all letters are in lowercase. If the order is invalid, return an empty string. There may be multiple valid order of letters, return any one of them is fine. Python Solution:\n1from typing import List 2from collections import defaultdict, deque 3 4 5class Solution(object): 6 def alienOrder(self, words: List[str]) -\u0026gt; str: 7 G = self.construct_graph(words) 8 visited = defaultdict(int) # 0 not visited, 1 visiting, 2 visted 9 ret = deque() 10 for u in G.keys(): 11 if visited[u] == 0: 12 if not self.topo_dfs(G, u, visited, ret): 13 return \u0026#34;\u0026#34; 14 15 return \u0026#34;\u0026#34;.join(ret) 16 17 def construct_graph(self, words): 18 G = defaultdict(list) 19 # need to initialize, consider test case [\u0026#34;z\u0026#34;, \u0026#34;z\u0026#34;] 20 for w in words: # error 21 for c in w: 22 G[c] 23 24 for i in range(len(words) - 1): # compare word_i and word_{i+1} 25 for c1, c2 in zip(words[i], words[i + 1]): 26 if c1 != c2: # lexical order 27 G[c1].append(c2) 28 break # need to break for lexical order 29 30 return G 31 32 def topo_dfs(self, G, u, visited, ret): 33 \u0026#34;\u0026#34;\u0026#34; 34 Topological sort 35 G = defaultdict(list) 36 visited = defaultdict(int) # 0 not visited, 1 visiteding, 2 visted 37 pre-condition: u is not visited (0) 38 \u0026#34;\u0026#34;\u0026#34; 39 visited[u] = 1 40 for nbr in G[u]: 41 if visited[nbr] == 1: 42 return False 43 if visited[nbr] == 0: 44 if not self.topo_dfs(G, nbr, visited, ret): 45 return False 46 47 visited[u] = 2 48 ret.appendleft(u) # visit larger first 49 return True 50 51 52if __name__ == \u0026#34;__main__\u0026#34;: 53 lst = [ 54 \u0026#34;ze\u0026#34;, \u0026#34;yf\u0026#34;, \u0026#34;xd\u0026#34;, \u0026#34;wd\u0026#34;, \u0026#34;vd\u0026#34;, \u0026#34;ua\u0026#34;, \u0026#34;tt\u0026#34;, \u0026#34;sz\u0026#34;, \u0026#34;rd\u0026#34;, \u0026#34;qd\u0026#34;, \u0026#34;pz\u0026#34;, \u0026#34;op\u0026#34;, 55 \u0026#34;nw\u0026#34;, \u0026#34;mt\u0026#34;, \u0026#34;ln\u0026#34;, \u0026#34;ko\u0026#34;, \u0026#34;jm\u0026#34;, \u0026#34;il\u0026#34;, \u0026#34;ho\u0026#34;, \u0026#34;gk\u0026#34;, \u0026#34;fa\u0026#34;, \u0026#34;ed\u0026#34;, \u0026#34;dg\u0026#34;, \u0026#34;ct\u0026#34;, 56 \u0026#34;bb\u0026#34;, \u0026#34;ba\u0026#34; 57 ] 58 assert Solution().alienOrder(lst) == \u0026#34;zyxwvutsrqponmlkjihgfedcba\u0026#34; "},{"id":11,"href":"/tech-interview-prep/problems/best-time-to-buy-and-sell-stock/","title":"Best time to buy and sell stock","section":"All Problems","content":" Levels:\u0026ensp;level-1 Data structures:\u0026ensp;array Practice Link: LeetCode\nDescription:\nSay you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit. Note:\nYou cannot sell a stock before you buy one. Python Solution:\n1class Solution(object): 2 def maxProfit(self, prices): 3 \u0026#34;\u0026#34;\u0026#34; 4 :type prices: List[int] 5 :rtype: int 6 \u0026#34;\u0026#34;\u0026#34; 7 l = len(prices) 8 if l \u0026lt; 2: 9 return 0 10 profit = 0 11 cmin = 0 12 i = 1 13 while i \u0026lt; l: 14 if prices[i] \u0026lt; prices[cmin]: 15 cmin = i 16 newp = prices[i] - prices[cmin] 17 if newp \u0026gt; profit: 18 profit = newp 19 # print(i, cmin, profit) 20 i += 1 21 return profit 22 23 24if __name__ == \u0026#34;__main__\u0026#34;: 25 p = [2, 1, 2, 1, 0, 1, 2] 26 #p = [3,3,5,0,0,3,1,4] 27 sol = Solution() 28 r = sol.maxProfit(p) 29 print(r) "},{"id":12,"href":"/tech-interview-prep/problems/binary-tree-level-order-traversal/","title":"Binary tree level order traversal","section":"All Problems","content":" Levels:\u0026ensp;level-3 Data structures:\u0026ensp;tree Algorithms:\u0026ensp;bfs Practice Link: LeetCode\nDescription:\nGiven a binary tree, return the level order traversal of its nodes\u0026rsquo; values. (ie, from left to right, level by level). Example 1:\n1Given binary tree [3,9,20,null,null,15,7], 2 3 3 4 / \\ 5 9 20 6 / \\ 7 15 7 8 9Output: 10[ 11 [3], 12 [9,20], 13 [15,7] 14]Python Solution:\n1class TreeNode(object): 2 def __init__(self, x): 3 self.val = x 4 self.left = None 5 self.right = None 6 7 8class Solution(object): 9 def levelOrder(self, root): 10 \u0026#34;\u0026#34;\u0026#34; 11 :type root: TreeNode 12 :rtype: List[List[int]] 13 \u0026#34;\u0026#34;\u0026#34; 14 if not root: 15 return [] 16 ans, level = [], [root] 17 while level: 18 ans.append([node.val for node in level]) 19 temp = [] 20 for node in level: 21 temp.extend([node.left, node.right]) 22 level = [leaf for leaf in temp if leaf] 23 return ans "},{"id":13,"href":"/tech-interview-prep/problems/binary-tree-maximum-path-sum/","title":"Binary tree maximum path sum","section":"All Problems","content":" Levels:\u0026ensp;level-5 Data structures:\u0026ensp;tree Algorithms:\u0026ensp;dfs Description:\nGiven a non-empty binary tree, find the maximum path sum. For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root. Example 1:\n1Input: [1,2,3] 2 3 1 4 / \\ 5 2 3 6 7Output: 6Example 2:\n1Input: [-10,9,20,null,null,15,7] 2 3 -10 4 / \\ 5 9 20 6 / \\ 7 15 7 8 9Output: 42Python Solution:\n1class TreeNode(object): 2 def __init__(self, x): 3 self.val = x 4 self.left = None 5 self.right = None 6 7 8class Solution(object): 9 def maxPathSum(self, root): 10 \u0026#34;\u0026#34;\u0026#34; 11 :type root: TreeNode 12 :rtype: int 13 \u0026#34;\u0026#34;\u0026#34; 14 def maxend(node): 15 if not node: 16 return 0 17 left = maxend(node.left) 18 right = maxend(node.right) 19 self.max = max(self.max, left + node.val + right) 20 return max(node.val + max(left, right), 0) 21 22 self.max = None 23 maxend(root) 24 return self.max "},{"id":14,"href":"/tech-interview-prep/problems/climbing-stairs/","title":"Climbing stairs","section":"All Problems","content":" Levels:\u0026ensp;level-3 Algorithms:\u0026ensp;dynamic-programming Practice Link: LeetCode\nDescription:\nYou are climbing a stair case. It takes n steps to reach to the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? Example 1:\n1Input: 2 2Output: 2 3Explanation: There are two ways to climb to the top. 41. 1 step + 1 step 52. 2 stepsExample 2:\n1Input: 3 2Output: 3 3Explanation: There are three ways to climb to the top. 41. 1 step + 1 step + 1 step 52. 1 step + 2 steps 63. 2 steps + 1 stepNote:\nGiven n will be a positive integer. Python Solution:\n1class Solution1(object): 2 def climbStairs(self, n): 3 \u0026#34;\u0026#34;\u0026#34; 4 :type n: int 5 :rtype: int 6 \u0026#34;\u0026#34;\u0026#34; 7 if not n: 8 return 0 9 if n == 1: 10 return 1 11 f = 1 12 s = 2 13 for _ in range(3, n + 1): 14 t = f + s 15 f = s 16 s = t 17 return s 18 19 20class Solution2(object): 21 def climbStairs(self, n): 22 \u0026#34;\u0026#34;\u0026#34; 23 :type n: int 24 :rtype: int 25 \u0026#34;\u0026#34;\u0026#34; 26 if not n: 27 return 0 28 if n == 1: 29 return 1 30 dp = [0 for _ in range(n + 1)] 31 dp[1] = 1 32 dp[2] = 2 33 for i in range(3, n + 1): 34 dp[i] = dp[i - 1] + dp[i - 2] 35 return dp[n] 36 37 38tm = [ 39 (1, 1), 40 (2, 2), 41 (3, 3), 42 (0, 0), 43 (None, 0), 44] 45 46if __name__ == \u0026#34;__main__\u0026#34;: 47 48 sol1 = Solution1() 49 sol2 = Solution2() 50 51 for idx, nin in enumerate(tm): 52 resout = sol1.climbStairs(nin[0]) 53 print(nin, resout, resout == nin[1]) 54 resout = sol2.climbStairs(nin[0]) 55 print(nin, resout, resout == nin[1]) "},{"id":15,"href":"/tech-interview-prep/problems/clone-graph/","title":"Clone graph","section":"All Problems","content":" Levels:\u0026ensp;level-3 Data structures:\u0026ensp;graph Algorithms:\u0026ensp;dfs,\u0026ensp;bfs Description:\nGiven a reference of a node in a connected undirected graph. Return a deep copy (clone) of the graph. Each node in the graph contains a val (int) and a list (List[Node]) of its neighbors. Test case format:\nFor simplicity sake, each node\u0026rsquo;s value is the same as the node\u0026rsquo;s index (1-indexed). For example, the first node with val = 1, the second node with val = 2, and so on. The graph is represented in the test case using an adjacency list. Adjacency list is a collection of unordered lists used to represent a finite graph. Each list describes the set of neighbors of a node in the graph. The given node will always be the first node with val = 1. You must return the copy of the given node as a reference to the cloned graph. Example 1:\n1Input: adjList = [[2,4],[1,3],[2,4],[1,3]] 2Output: [[2,4],[1,3],[2,4],[1,3]] 3Explanation: There are 4 nodes in the graph. 41st node (val = 1)\u0026#39;s neighbors are 2nd node (val = 2) and 4th node (val = 4). 52nd node (val = 2)\u0026#39;s neighbors are 1st node (val = 1) and 3rd node (val = 3). 63rd node (val = 3)\u0026#39;s neighbors are 2nd node (val = 2) and 4th node (val = 4). 74th node (val = 4)\u0026#39;s neighbors are 1st node (val = 1) and 3rd node (val = 3).Example 2:\n1Input: adjList = [[]] 2Output: [[]] 3Explanation: Note that the input contains one empty list. The graph consists of only one node with val = 1 and it does not have any neighbors.Constraints:\n1 \u0026lt;= Node.val \u0026lt;= 100 Node.val is unique for each node. Number of Nodes will not exceed 100. There is no repeated edges and no self-loops in the graph. The Graph is connected and all nodes can be visited starting from the given node. Python Solution:\n1class Node: 2 def __init__(self, val=0, neighbors=[]): 3 self.val = val 4 self.neighbors = neighbors 5 6 7class Solution: 8 def cloneGraph(self, node: \u0026#39;Node\u0026#39;) -\u0026gt; \u0026#39;Node\u0026#39;: 9 dic = {} 10 11 def dfs(node): 12 if not node: 13 return 14 else: 15 node_copy = Node(node.val, []) 16 dic[node] = node_copy 17 for nei in node.neighbors: 18 if nei in dic: 19 node_copy.neighbors.append(dic[nei]) 20 else: 21 node_copy.neighbors.append(dfs(nei)) 22 return node_copy 23 24 return dfs(node) "},{"id":16,"href":"/tech-interview-prep/problems/coin-change/","title":"Coin change","section":"All Problems","content":" Levels:\u0026ensp;level-3 Algorithms:\u0026ensp;dynamic-programming Practice Link: LeetCode\nDescription:\nYou are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1. Example 1:\n1Input: coins = [1, 2, 5], amount = 11 2Output: 3 3Explanation: 11 = 5 + 5 + 1Example 2:\n1Input: coins = [2], amount = 3 2Output: -1Note:\nYou may assume that you have an infinite number of each kind of coin. Python Solution:\n1class Solution(object): 2 def coinChange(self, coins, amount): 3 \u0026#34;\u0026#34;\u0026#34; 4 :type coins: List[int] 5 :type amount: int 6 :rtype: int 7 \u0026#34;\u0026#34;\u0026#34; 8 # Start with a dp array of size amount + 1. 9 # Use amount + 1 as the \u0026#34;max\u0026#34; value. 10 rs = [amount + 1] * (amount + 1) 11 # No coin needed for amount zero 12 rs[0] = 0 13 # Calculate min counts needed for each target upto amount. 14 for i in range(1, amount + 1): 15 # Check for each available denomination 16 for c in coins: 17 if i \u0026gt;= c: 18 # Coins needed for target amount i is 19 # the min of (current calculated min number of coins) 20 # and (coins needed for i - c target amount + 1) 21 rs[i] = min(rs[i], rs[i - c] + 1) 22 23 if rs[amount] == amount + 1: 24 # return -1 if calculated n coins is the \u0026#34;max\u0026#34; value set initially. 25 return -1 26 return rs[amount] 27 28 29tm = [ 30 ([1, 2, 5], 11, 3), 31 ([2], 3, -1), 32 ([], 11, -1), 33] 34 35if __name__ == \u0026#34;__main__\u0026#34;: 36 37 sol1 = Solution() 38 39 for idx, nin in enumerate(tm): 40 resout = sol1.coinChange(nin[0], nin[1]) 41 print(nin, resout, resout == nin[-1]) "},{"id":17,"href":"/tech-interview-prep/problems/combination-sum-iv/","title":"Combination sum IV","section":"All Problems","content":" Levels:\u0026ensp;level-4 Data structures:\u0026ensp;array Algorithms:\u0026ensp;dynamic-programming Practice Link: LeetCode\nDescription:\nGiven an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target. Example:\n1nums = [1, 2, 3] 2target = 4 3 4The possible combination ways are: 5(1, 1, 1, 1) 6(1, 1, 2) 7(1, 2, 1) 8(1, 3) 9(2, 1, 1) 10(2, 2) 11(3, 1) 12 13Note that different sequences are counted as different combinations. 14 15Therefore the output is 7.Follow up:\nWhat if negative numbers are allowed in the given array? How does it change the problem? What limitation we need to add to the question to allow negative numbers? Python Solution:\n1class Solution(object): 2 def combinationSum4(self, nums, target): 3 nums, combs = sorted(nums), [1] + [0] * (target) 4 for i in range(target + 1): 5 for num in nums: 6 if num \u0026gt; i: break 7 if num == i: combs[i] += 1 8 if num \u0026lt; i: combs[i] += combs[i - num] 9 return combs[target] "},{"id":18,"href":"/tech-interview-prep/problems/construct-binary-tree-from-preorder-and-inorder-traversal/","title":"Construct binary tree from preorder and inorder traversal","section":"All Problems","content":" Levels:\u0026ensp;level-3 Data structures:\u0026ensp;tree,\u0026ensp;array Algorithms:\u0026ensp;dfs Practice Link: LeetCode\nDescription:\nGiven preorder and inorder traversal of a tree, construct the binary tree. Example:\n1preorder = [3,9,20,15,7] 2inorder = [9,3,15,20,7] 3 4Return the following binary tree: 5 6 3 7 / \\ 8 9 20 9 / \\ 10 15 7Note:\nYou may assume that duplicates do not exist in the tree. Python Solution:\n1class TreeNode(object): 2 def __init__(self, x): 3 self.val = x 4 self.left = None 5 self.right = None 6 7 8class Solution(object): 9 def buildTree(self, preorder, inorder): 10 \u0026#34;\u0026#34;\u0026#34; 11 :type preorder: List[int] 12 :type inorder: List[int] 13 :rtype: TreeNode 14 \u0026#34;\u0026#34;\u0026#34; 15 if inorder: 16 ind = inorder.index(preorder.pop(0)) 17 root = TreeNode(inorder[ind]) 18 root.left = self.buildTree(preorder, inorder[0:ind]) 19 root.right = self.buildTree(preorder, inorder[ind + 1:]) 20 return root "},{"id":19,"href":"/tech-interview-prep/problems/container-with-most-water/","title":"Container with most water","section":"All Problems","content":" Levels:\u0026ensp;level-2 Data structures:\u0026ensp;array Practice Link: LeetCode\nDescription:\nGiven n non-negative integers a1, a2, ..., an, where each represents a point at coordinate (i, ai), n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. Example 1:\n1Input: [1,8,6,2,5,4,8,3,7] 2Output: 49Note:\nYou may not slant the container and n is at least 2. Python Solution:\n1class Solution(object): 2 def maxArea(self, height): 3 \u0026#34;\u0026#34;\u0026#34; 4 :type height: List[int] 5 :rtype: int 6 \u0026#34;\u0026#34;\u0026#34; 7 if not height: 8 return -1 9 l = 0 10 h = len(height) - 1 11 if h \u0026lt; 1: 12 return -1 13 maxarea = -1 14 sidel = h 15 while l \u0026lt; h: 16 if height[l] \u0026lt; height[h]: 17 sidew = height[l] 18 l += 1 19 else: 20 sidew = height[h] 21 h -= 1 22 a = sidew * sidel 23 if a \u0026gt; maxarea: 24 maxarea = a 25 sidel -= 1 26 return maxarea 27 28 29in_arrs = [ 30 [1, 8, 6, 2, 5, 4, 8, 3, 7], 31 [1], 32 [], 33 None, 34] 35 36exp_out = [ 37 49, 38 -1, 39 -1, 40 -1, 41] 42 43if __name__ == \u0026#34;__main__\u0026#34;: 44 45 sol = Solution() 46 for idx, nin in enumerate(in_arrs): 47 resout = sol.maxArea(nin) 48 print(nin, resout, exp_out[idx], resout == exp_out[idx]) "},{"id":20,"href":"/tech-interview-prep/problems/contains-duplicate/","title":"Contains duplicate","section":"All Problems","content":" Levels:\u0026ensp;level-0 Data structures:\u0026ensp;array,\u0026ensp;hash-table Practice Link: LeetCode\nDescription:\nGiven an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct. Example 1:\n1Input: [1,2,3,1] 2Output: truePython Solution:\n1class Solution(object): 2 def containsDuplicate(self, nums): 3 \u0026#34;\u0026#34;\u0026#34; 4 :type nums: List[int] 5 :rtype: bool 6 \u0026#34;\u0026#34;\u0026#34; 7 h = {} 8 for n in nums: 9 if n in h: 10 return True 11 h[n] = True 12 return False 13 14 15class Solution2(object): 16 def containsDuplicate(self, nums): 17 \u0026#34;\u0026#34;\u0026#34; 18 :type nums: List[int] 19 :rtype: bool 20 \u0026#34;\u0026#34;\u0026#34; 21 return True if len(set(nums)) \u0026lt; len(nums) else False 22 23 24in_arrs = [ 25 [2, 1, 2, 1, 0, 1, 2], 26 [3, 3, 5, 0, 0, 3, 1, 4], 27 [3, 5, 0, 1, 4], 28 [1, 2, 3, 1], 29 [1, 2, 3, 4], 30 [1, 1, 1, 3, 3, 4, 3, 2, 4, 2], 31] 32if __name__ == \u0026#34;__main__\u0026#34;: 33 34 sol = Solution2() 35 for nin in in_arrs: 36 r = sol.containsDuplicate(nin) 37 print(r) "},{"id":21,"href":"/tech-interview-prep/problems/counting-bits/","title":"Counting bits","section":"All Problems","content":" Levels:\u0026ensp;level-4 Data structures:\u0026ensp;bits,\u0026ensp;array Algorithms:\u0026ensp;dynamic-programming Practice Link: LeetCode\nDescription:\nGiven a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1\u0026rsquo;s in their binary representation and return them as an array. Example 1:\n1Input: 2 2Output: [0,1,1]Example 2:\n1Input: 5 2Output: [0,1,1,2,1,2]Follow up:\nIt is very easy to come up with a solution with run time O(n*sizeof(integer)). But can you do it in linear time O(n) /possibly in a single pass? Space complexity should be O(n). Thinking:\nWe do not need check the input parameter, because the question has already mentioned that the number is non negative.\nHow we do this? The first idea come up with is find the pattern or rules for the result. Therefore, we can get following pattern\n1Index : 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 2num : 0 1 1 2 1 2 2 3 1 2 2 3 2 3 3 4 Do you find the pattern?\nObviously, this is overlap sub problem, and we can come up the DP solution. For now, we need find the function to implement DP.\n1dp[0] = 0; 2dp[1] = dp[0] + 1; 3dp[2] = dp[0] + 1; 4dp[3] = dp[1] +1; 5dp[4] = dp[0] + 1; 6dp[5] = dp[1] + 1; 7dp[6] = dp[2] + 1; 8dp[7] = dp[3] + 1; 9dp[8] = dp[0] + 1; This is the function we get, now we need find the other pattern for the function to get the general function.\nAfter we analyze the above function, we can get\n1dp[0] = 0; 2dp[1] = dp[1-1] + 1; 3dp[2] = dp[2-2] + 1; 4dp[3] = dp[3-2] +1; 5dp[4] = dp[4-4] + 1; 6dp[5] = dp[5-4] + 1; 7dp[6] = dp[6-4] + 1; 8dp[7] = dp[7-4] + 1; 9dp[8] = dp[8-8] + 1; Obviously, we can find the pattern for above example, so now we get the general function dp[index] = dp[index - offset] + 1;\nPython Solution:\n1class Solution(object): 2 def countBits(self, num): 3 \u0026#34;\u0026#34;\u0026#34; 4 :type num: int 5 :rtype: List[int] 6 \u0026#34;\u0026#34;\u0026#34; 7 result = [0] * (num + 1) 8 offset = 1 9 for index in range(1, num + 1): 10 if (offset * 2 == index): 11 offset *= 2 12 result[index] = result[index - offset] + 1 13 return result "},{"id":22,"href":"/tech-interview-prep/problems/course-schedule/","title":"Course schedule","section":"All Problems","content":" Levels:\u0026ensp;level-4 Data structures:\u0026ensp;graph Algorithms:\u0026ensp;dfs,\u0026ensp;bfs Description:\nThere are a total of numCourses courses you have to take, labeled from 0 to numCourses-1. Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1] Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses? Example 1:\n1Input: numCourses = 2, prerequisites = [[1,0]] 2Output: true 3Explanation: There are a total of 2 courses to take. 4 To take course 1 you should have finished course 0. So it is possible.Example 2:\n1Input: numCourses = 2, prerequisites = [[1,0],[0,1]] 2Output: false 3Explanation: There are a total of 2 courses to take. 4 To take course 1 you should have finished course 0, and to take course 0 you should 5 also have finished course 1. So it is impossible.Constraints:\nThe input prerequisites is a graph represented by a list of edges, not adjacency matrices. You may assume that there are no duplicate edges in the input prerequisites. 1 \u0026lt;= numCourses \u0026lt;= 10^5 Python Solution:\n1class Solution(object): 2 def canFinish(self, numCourses, prerequisites): 3 \u0026#34;\u0026#34;\u0026#34; 4 :type numCourses: int 5 :type prerequisites: List[List[int]] 6 :rtype: bool 7 \u0026#34;\u0026#34;\u0026#34; 8 graph = [[] for _ in range(numCourses)] 9 visited = [0 for _ in range(numCourses)] 10 # create graph 11 for pair in prerequisites: 12 x, y = pair 13 graph[x].append(y) 14 # visit each node 15 for i in range(numCourses): 16 if not self.dfs(graph, visited, i): 17 return False 18 return True 19 20 def dfs(self, graph, visited, i): 21 # if ith node is marked as being visited, then a cycle is found 22 if visited[i] == -1: 23 return False 24 # if it is done visted, then do not visit again 25 if visited[i] == 1: 26 return True 27 # mark as being visited 28 visited[i] = -1 29 # visit all the neighbours 30 for j in graph[i]: 31 if not self.dfs(graph, visited, j): 32 return False 33 # after visit all the neighbours, mark it as done visited 34 visited[i] = 1 35 return True "},{"id":23,"href":"/tech-interview-prep/problems/decode-ways/","title":"Decode ways","section":"All Problems","content":" Levels:\u0026ensp;level-4 Data structures:\u0026ensp;string Algorithms:\u0026ensp;dynamic-programming Practice Link: LeetCode\nDescription:\nA message containing letters from A-Z is being encoded to numbers using the following mapping:\n1\u0026#39;A\u0026#39; -\u0026gt; 1 2\u0026#39;B\u0026#39; -\u0026gt; 2 3... 4\u0026#39;Z\u0026#39; -\u0026gt; 26 Given a non-empty string containing only digits, determine the total number of ways to decode it.\nExample 1:\n1Input: \u0026#34;12\u0026#34; 2Output: 2 3Explanation: It could be decoded as \u0026#34;AB\u0026#34; (1 2) or \u0026#34;L\u0026#34; (12).Example 2:\n1Input: \u0026#34;226\u0026#34; 2Output: 3 3Explanation: It could be decoded as \u0026#34;BZ\u0026#34; (2 26), \u0026#34;VF\u0026#34; (22 6), or \u0026#34;BBF\u0026#34; (2 2 6).Python Solution:\n1class Solution: 2 def numDecodings(self, s): 3 if not s or s[0] == \u0026#39;0\u0026#39;: 4 return 0 5 6 dp = [0 for x in range(len(s) + 1)] 7 8 # base case initialization 9 dp[0:2] = [1, 1] 10 11 for i in range(2, len(s) + 1): 12 # One step jump 13 if 0 \u0026lt; int(s[i - 1:i]): #(2) 14 dp[i] = dp[i - 1] 15 # Two step jump 16 if 10 \u0026lt;= int(s[i - 2:i]) \u0026lt;= 26: #(3) 17 dp[i] += dp[i - 2] 18 19 return dp[-1] "},{"id":24,"href":"/tech-interview-prep/problems/encode-and-decode-strings/","title":"Encode and decode strings","section":"All Problems","content":" Levels:\u0026ensp;level-4 Data structures:\u0026ensp;string Description:\nDesign an algorithm to encode a list of strings to a string. The encoded string is then sent over the network and is decoded back to the original list of strings. Note:\nThe string may contain any possible characters out of 256 valid ascii characters. Your algorithm should be generalized enough to work on any possible characters. Do not use class member/global/static variables to store states. Your encode and decode algorithms should be stateless. Do not rely on any library method such as eval or serialize methods. You should implement your own encode/decode algorithm. Python Solution:\n1from functools import reduce 2 3 4class Codec(object): 5 def encode(self, strs): 6 \u0026#34;\u0026#34;\u0026#34; 7 Encodes a list of strings to a single string. 8 9 Algorithm: Length info 10 11 :type strs: List[str] 12 :rtype: str 13 \u0026#34;\u0026#34;\u0026#34; 14 strs = list(map(lambda x: str(len(x)) + \u0026#34;/\u0026#34; + x, strs)) 15 return reduce(lambda x, y: x + y, strs, \u0026#34;\u0026#34;) # i.e. \u0026#34;\u0026#34;.join(strs) 16 17 def decode(self, s): 18 \u0026#34;\u0026#34;\u0026#34; 19 Decodes a single string to a list of strings. 20 21 :type s: str 22 :rtype: List[str] 23 \u0026#34;\u0026#34;\u0026#34; 24 strs = [] 25 i = 0 26 while i \u0026lt; len(s): 27 j = s.index(\u0026#34;/\u0026#34;, i) 28 l = int(s[i:j]) 29 strs.append(s[j + 1:j + 1 + l]) 30 i = j + 1 + l 31 32 return strs 33 34 35class CodecMethod2(object): 36 def encode(self, strs): 37 \u0026#34;\u0026#34;\u0026#34; 38 Encodes a list of strings to a single string. 39 40 Algorithm: Escape 41 42 :type strs: List[str] 43 :rtype: str 44 \u0026#34;\u0026#34;\u0026#34; 45 strs = list(map(lambda x: x.replace(\u0026#34;\\n\u0026#34;, \u0026#34;\\n\\n\u0026#34;) + \u0026#34;_\\n_\u0026#34;, strs)) 46 return reduce(lambda x, y: x + y, strs, \u0026#34;\u0026#34;) 47 48 def decode(self, s): 49 \u0026#34;\u0026#34;\u0026#34; 50 Decodes a single string to a list of strings. 51 52 :type s: str 53 :rtype: List[str] 54 \u0026#34;\u0026#34;\u0026#34; 55 strs = s.split(\u0026#34;_\\n_\u0026#34;) 56 strs = strs[:-1] # clear the trailing delimiter 57 return list(map(lambda x: x.replace(\u0026#34;\\n\\n\u0026#34;, \u0026#34;\\n\u0026#34;), strs)) "},{"id":25,"href":"/tech-interview-prep/problems/find-median-from-data-stream/","title":"Find median from data stream","section":"All Problems","content":" Levels:\u0026ensp;level-5 Data structures:\u0026ensp;heap Practice Link: LeetCode\nDescription:\nMedian is the middle value in an ordered integer list.\nIf the size of the list is even, there is no middle value.\nSo the median is the mean of the two middle value.\n1For example, 2[2,3,4], the median is 3 3 4[2,3], the median is (2 + 3) / 2 = 2.5 Design a data structure that supports the following two operations:\nvoid addNum(int num): Add a integer number from the data stream to the data structure. double findMedian(): Return the median of all elements so far. Example:\n1addNum(1) 2addNum(2) 3findMedian() -\u0026gt; 1.5 4addNum(3) 5findMedian() -\u0026gt; 2Follow up:\nIf all integer numbers from the stream are between 0 and 100, how would you optimize it? If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it? Python Solution:\n1from heapq import heappush, heappushpop, heappop 2 3 4class MedianFinder: 5 def __init__(self): 6 self.heaps = [], [] 7 8 def addNum(self, num): 9 small, large = self.heaps 10 heappush(small, -heappushpop(large, num)) 11 if len(large) \u0026lt; len(small): 12 heappush(large, -heappop(small)) 13 14 def findMedian(self): 15 small, large = self.heaps 16 if len(large) \u0026gt; len(small): 17 return float(large[0]) 18 return (large[0] - small[0]) / 2.0 "},{"id":26,"href":"/tech-interview-prep/problems/find-minimum-in-rotated-sorted-array/","title":"Find minimum in rotated sorted array","section":"All Problems","content":" Levels:\u0026ensp;level-2 Data structures:\u0026ensp;array Algorithms:\u0026ensp;binary-search Practice Link: LeetCode\nDescription:\nSuppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). Find the minimum element. You may assume no duplicate exists in the array. Python Solution:\n1class Solution(object): 2 def findMin(self, nums): 3 \u0026#34;\u0026#34;\u0026#34; 4 :type nums: List[int] 5 :rtype: int 6 \u0026#34;\u0026#34;\u0026#34; 7 if not nums: 8 return None 9 return self.__fmin(nums, 0, len(nums) - 1) 10 11 def __fmin(self, nums, i, j): 12 if i == j: 13 return nums[i] 14 if i + 1 == j: 15 return min(nums[i], nums[j]) 16 if nums[i] \u0026lt; nums[j]: 17 return nums[i] 18 mid = int((i + j) / 2) 19 if nums[i] \u0026lt; nums[mid]: 20 return self.__fmin(nums, mid, j) 21 return self.__fmin(nums, i, mid) 22 23 24class Solution2(object): 25 def findMin(self, nums): 26 \u0026#34;\u0026#34;\u0026#34; 27 :type nums: List[int] 28 :rtype: int 29 \u0026#34;\u0026#34;\u0026#34; 30 if not nums: 31 return None 32 lo = 0 33 hi = len(nums) - 1 34 while lo \u0026lt; hi: 35 mid = (lo + hi) / 2 36 if (nums[mid] \u0026gt; nums[hi]): 37 lo = mid + 1 38 else: 39 hi = mid 40 return nums[lo] 41 42 43in_arrs = [ 44 [3, 4, 5, 1, 2], 45 [4, 5, 6, 7, 0, 1, 2], 46 [8, 1, 2, 3], 47 [1, 2, 3, 4], 48 [1], 49 [], 50 None, 51] 52 53exp_out = [ 54 1, 55 0, 56 1, 57 1, 58 1, 59 None, 60 None, 61] 62 63if __name__ == \u0026#34;__main__\u0026#34;: 64 65 sol = Solution() 66 sol2 = Solution() 67 for idx, nin in enumerate(in_arrs): 68 r = sol.findMin(nin) 69 print(exp_out[idx] == r, r) 70 r = sol2.findMin(nin) 71 print(exp_out[idx] == r, r) "},{"id":27,"href":"/tech-interview-prep/problems/graph-valid-tree/","title":"Graph valid tree","section":"All Problems","content":" Levels:\u0026ensp;level-5 Data structures:\u0026ensp;graph Description:\nGiven n nodes labeled from 0 to n - 1 and a list of undirected edges (each edge is a pair of nodes), write a function to check whether these edges make up a valid tree. Example 1:\n1Given n = 5 and edges = [[0, 1], [0, 2], [0, 3], [1, 4]], return true. 2 3Given n = 5 and edges = [[0, 1], [1, 2], [2, 3], [1, 3], [1, 4]], return false.Hint:\nGiven n = 5 and edges = [[0, 1], [1, 2], [3, 4]], what should your return? Is this case a valid tree? According to the definition of tree on Wikipedia: “a tree is an undirected graph in which any two vertices are connected by exactly one path. In other words, any connected graph without simple cycles is a tree.” Note: you can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0, 1] is the same as [1, 0] and thus will not appear together inedges. Treating input as graph, making sure no cycles and one connected component. Check for cycle and connectness in Graph can be done by DFS, BFS and Union-find Python Solution:\n1from collections import defaultdict 2 3 4class Solution(object): 5 def validTree(self, n, edges): 6 \u0026#34;\u0026#34;\u0026#34; 7 A graph is a tree: 8 1. no cycle 9 2. all connected 10 :type n: int 11 :type edges: List[List[int] 12 :rtype: bool 13 \u0026#34;\u0026#34;\u0026#34; 14 if not edges: 15 return n in (0, 1) 16 17 V = defaultdict(list) 18 for e in edges: 19 V[e[0]].append(e[1]) 20 V[e[1]].append(e[0]) 21 22 visited = set() 23 pathset = set() 24 if not self.dfs(V, edges[0][0], None, pathset, visited): 25 return False 26 27 return len(visited) == n 28 29 def dfs(self, V, v, pi, pathset, visited): 30 if v in pathset: 31 return False 32 33 pathset.add(v) 34 for nbr in V[v]: 35 if nbr != pi: # since undirected graph 36 if not self.dfs(V, nbr, v, pathset, visited): 37 return False 38 39 pathset.remove(v) 40 visited.add(v) 41 return True "},{"id":28,"href":"/tech-interview-prep/problems/group-anagrams/","title":"Group anagrams","section":"All Problems","content":" Levels:\u0026ensp;level-3 Data structures:\u0026ensp;string,\u0026ensp;hash-table Practice Link: LeetCode\nDescription:\nGiven an array of strings, group anagrams together. Example:\n1Input: [\u0026#34;eat\u0026#34;, \u0026#34;tea\u0026#34;, \u0026#34;tan\u0026#34;, \u0026#34;ate\u0026#34;, \u0026#34;nat\u0026#34;, \u0026#34;bat\u0026#34;], 2Output: 3[ 4 [\u0026#34;ate\u0026#34;,\u0026#34;eat\u0026#34;,\u0026#34;tea\u0026#34;], 5 [\u0026#34;nat\u0026#34;,\u0026#34;tan\u0026#34;], 6 [\u0026#34;bat\u0026#34;] 7]Note:\nAll inputs will be in lowercase. The order of your output does not matter. Python Solution:\n1import collections 2 3 4class Solution(object): 5 def groupAnagrams(self, strs): 6 ans = collections.defaultdict(list) 7 for s in strs: 8 ans[tuple(sorted(s))].append(s) 9 return ans.values() "},{"id":29,"href":"/tech-interview-prep/problems/house-robber/","title":"House robber","section":"All Problems","content":" Levels:\u0026ensp;level-3 Data structures:\u0026ensp;array Algorithms:\u0026ensp;dynamic-programming Practice Link: LeetCode\nDescription:\nYou are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. Example 1:\n1Input: [1,2,3,1] 2Output: 4 3Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3). 4 Total amount you can rob = 1 + 3 = 4.Example 2:\n1Input: [2,7,9,3,1] 2Output: 12 3Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1). 4 Total amount you can rob = 2 + 9 + 1 = 12.Python Solution:\n1class Solution: 2 def rob(self, nums): 3 rob, not_rob = 0, 0 4 for num in nums: 5 rob, not_rob = not_rob + num, max(rob, not_rob) 6 return max(rob, not_rob) "},{"id":30,"href":"/tech-interview-prep/problems/house-robber-ii/","title":"House robber II","section":"All Problems","content":" Levels:\u0026ensp;level-4 Data structures:\u0026ensp;array Algorithms:\u0026ensp;dynamic-programming Practice Link: LeetCode\nDescription:\nYou are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. Example 1:\n1Input: [2,3,2] 2Output: 3 3Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), 4 because they are adjacent houses.Example 1:\n1Input: [1,2,3,1] 2Output: 4 3Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3). 4 Total amount you can rob = 1 + 3 = 4.Python Solution:\n1class Solution(object): 2 def rob(self, nums): 3 \u0026#34;\u0026#34;\u0026#34; 4 :type nums: List[int] 5 :rtype: int 6 \u0026#34;\u0026#34;\u0026#34; 7 def simple_rob(nums): 8 rob, not_rob = 0, 0 9 for num in nums: 10 rob, not_rob = not_rob + num, max(rob, not_rob) 11 return max(rob, not_rob) 12 13 if not nums: 14 return 0 15 elif len(nums) == 1: 16 return nums[0] 17 else: 18 return max(simple_rob(nums[1:]), simple_rob(nums[:-1])) "},{"id":31,"href":"/tech-interview-prep/problems/implement-trie-prefix-tree/","title":"Implement trie (prefix tree)","section":"All Problems","content":" Levels:\u0026ensp;level-4 Data structures:\u0026ensp;trie Practice Link: LeetCode\nDescription:\nImplement a trie with insert, search, and startsWith methods. You may assume that all inputs are consist of lowercase letters a-z. All inputs are guaranteed to be non-empty strings. Example:\n1Trie trie = new Trie(); 2 3trie.insert(\u0026#34;apple\u0026#34;); 4trie.search(\u0026#34;apple\u0026#34;); // returns true 5trie.search(\u0026#34;app\u0026#34;); // returns false 6trie.startsWith(\u0026#34;app\u0026#34;); // returns true 7trie.insert(\u0026#34;app\u0026#34;); 8trie.search(\u0026#34;app\u0026#34;); // returns truePython Solution:\n1import collections 2 3 4class TrieNode: 5 # Initialize your data structure here. 6 def __init__(self): 7 self.children = collections.defaultdict(TrieNode) 8 self.is_word = False 9 10 11class Trie(object): 12 def __init__(self): 13 self.root = TrieNode() 14 15 def insert(self, word): 16 current = self.root 17 for letter in word: 18 current = current.children[letter] 19 current.is_word = True 20 21 def search(self, word): 22 current = self.root 23 for letter in word: 24 current = current.children.get(letter) 25 if current is None: 26 return False 27 return current.is_word 28 29 def startsWith(self, prefix): 30 current = self.root 31 for letter in prefix: 32 current = current.children.get(letter) 33 if current is None: 34 return False 35 return True 36 37 38# Your Trie object will be instantiated and called as such: 39# obj = Trie() 40# obj.insert(word) 41# param_2 = obj.search(word) 42# param_3 = obj.startsWith(prefix) "},{"id":32,"href":"/tech-interview-prep/problems/insert-interval/","title":"Insert interval","section":"All Problems","content":" Levels:\u0026ensp;level-5 Data structures:\u0026ensp;array Patterns:\u0026ensp;intervals Practice Link: LeetCode\nDescription:\nGiven a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary). You may assume that the intervals were initially sorted according to their start times. Example 1:\n1Input: intervals = [[1,3],[6,9]], newInterval = [2,5] 2Output: [[1,5],[6,9]]Example 2:\n1Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8] 2Output: [[1,2],[3,10],[12,16]] 3Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].Python Solution:\n1class Solution(object): 2 def insert(self, intervals, newInterval): 3 \u0026#34;\u0026#34;\u0026#34; 4 :type intervals: List[List[int]] 5 :type newInterval: List[int] 6 :rtype: List[List[int]] 7 \u0026#34;\u0026#34;\u0026#34; 8 s, e = newInterval[0], newInterval[-1] 9 left, right = [], [] 10 for i in intervals: 11 if i[-1] \u0026lt; s: 12 left += i, 13 elif i[0] \u0026gt; e: 14 right += i, 15 else: 16 s = min(s, i[0]) 17 e = max(e, i[-1]) 18 return left + [[s, e]] + right "},{"id":33,"href":"/tech-interview-prep/problems/invert-binary-tree/","title":"Invert a binary tree","section":"All Problems","content":" Levels:\u0026ensp;level-0 Data structures:\u0026ensp;tree Practice Link: LeetCode\nDescription:\nInvert a binary tree Example:\n1Input: 2 4 3 / \\ 4 2 7 5 / \\ / \\ 61 3 6 9 7 8Output: 9 4 10 / \\ 11 7 2 12 / \\ / \\ 139 6 3 1Python Solution:\n1# Definition for a binary tree node. 2class TreeNode(object): 3 def __init__(self, x): 4 self.val = x 5 self.left = None 6 self.right = None 7 8 9class Solution(object): 10 def invertTree(self, root): 11 \u0026#34;\u0026#34;\u0026#34; 12 :type root: TreeNode 13 :rtype: TreeNode 14 \u0026#34;\u0026#34;\u0026#34; 15 if root is None: 16 return None 17 root.left, root.right = self.invertTree(root.right), self.invertTree( 18 root.left) 19 return root "},{"id":34,"href":"/tech-interview-prep/problems/jump-game/","title":"Jump game","section":"All Problems","content":" Levels:\u0026ensp;level-4 Data structures:\u0026ensp;array Algorithms:\u0026ensp;dynamic-programming Practice Link: LeetCode\nDescription:\nGiven an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index. Example 1:\n1Input: [2,3,1,1,4] 2Output: true 3Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.Example 2:\n1Input: [3,2,1,0,4] 2Output: false 3Explanation: You will always arrive at index 3 no matter what. Its maximum 4 jump length is 0, which makes it impossible to reach the last index.Python Solution:\n1class Solution: 2 def canJump(self, nums): 3 \u0026#34;\u0026#34;\u0026#34; 4 :type nums: List[int] 5 :rtype: bool 6 \u0026#34;\u0026#34;\u0026#34; 7 if len(nums) \u0026lt;= 1: 8 return True 9 jumps = 1 10 n = len(nums) - 2 11 for i in range(n, -1, -1): 12 if nums[i] \u0026gt;= jumps: 13 jumps = 1 14 else: 15 jumps += 1 16 return nums[0] \u0026gt;= jumps "},{"id":35,"href":"/tech-interview-prep/problems/kth-smallest-element-in-a-bst/","title":"Kth smallest element in a BST","section":"All Problems","content":" Levels:\u0026ensp;level-3 Data structures:\u0026ensp;tree Algorithms:\u0026ensp;binary-search Practice Link: LeetCode\nDescription:\nGiven a binary search tree, write a function kthSmallest to find the kth smallest element in it. Example 1:\n1Input: root = [3,1,4,null,2], k = 1 2 3 3 / \\ 4 1 4 5 \\ 6 2 7Output: 1Example 2:\n1Input: root = [5,3,6,2,4,null,null,1], k = 3 2 5 3 / \\ 4 3 6 5 / \\ 6 2 4 7 / 8 1 9Output: 3Note:\nYou may assume k is always valid, 1 ≤ k ≤ BST\u0026rsquo;s total elements. Follow up:\nWhat if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine? Python Solution:\n1class TreeNode(object): 2 def __init__(self, x): 3 self.val = x 4 self.left = None 5 self.right = None 6 7 8class Solution(object): 9 def kthSmallestRecursive(self, root, k): 10 \u0026#34;\u0026#34;\u0026#34; 11 :type root: TreeNode 12 :type k: int 13 :rtype: int 14 \u0026#34;\u0026#34;\u0026#34; 15 def inorder(r): 16 return inorder(r.left) + [r.val] + inorder(r.right) if r else [] 17 18 return inorder(root)[k - 1] 19 20 def kthSmallestIterative(self, root, k): 21 \u0026#34;\u0026#34;\u0026#34; 22 :type root: TreeNode 23 :type k: int 24 :rtype: int 25 \u0026#34;\u0026#34;\u0026#34; 26 stack = [] 27 28 while True: 29 while root: 30 stack.append(root) 31 root = root.left 32 root = stack.pop() 33 k -= 1 34 if not k: 35 return root.val 36 root = root.right "},{"id":36,"href":"/tech-interview-prep/problems/linked-list-cycle/","title":"Linked list cycle","section":"All Problems","content":" Levels:\u0026ensp;level-1 Data structures:\u0026ensp;linkedlist Practice Link: LeetCode\nDescription:\nGiven a linked list, determine if it has a cycle in it. To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list. Example 1:\n1Input: head = [3,2,0,-4], pos = 1 2Output: true 3Explanation: There is a cycle in the linked list, where tail connects to the second node.Example 2:\n1Input: head = [1,2], pos = 0 2Output: true 3Explanation: There is a cycle in the linked list, where tail connects to the first node.Thinking:\nThis can be solved using tortoise and hare approach or using hashtable. Python Solution:\n1class Solution(object): 2 # Tortise and hare approach 3 def hasCycle(self, head): 4 try: 5 slow = head 6 fast = head.next 7 while slow is not fast: 8 slow = slow.next 9 fast = fast.next.next 10 return True 11 except: 12 return False "},{"id":37,"href":"/tech-interview-prep/problems/longest-consecutive-sequence/","title":"Longest consecutive sequence","section":"All Problems","content":" Levels:\u0026ensp;level-5 Data structures:\u0026ensp;array Patterns:\u0026ensp;union-find Practice Link: LeetCode\nDescription:\nGiven an unsorted array of integers, find the length of the longest consecutive elements sequence. Your algorithm should run in O(n) complexity. Example:\n1Input: [100, 4, 200, 1, 3, 2] 2Output: 4 3Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.Python Solution:\n1class Solution: 2 def longestConsecutive(self, nums): 3 longest_streak = 0 4 num_set = set(nums) 5 6 for num in num_set: 7 if num - 1 not in num_set: 8 current_num = num 9 current_streak = 1 10 11 while current_num + 1 in num_set: 12 current_num += 1 13 current_streak += 1 14 15 longest_streak = max(longest_streak, current_streak) 16 17 return longest_streak "},{"id":38,"href":"/tech-interview-prep/problems/longest-increasing-subsequence/","title":"Longest increasing subsequence","section":"All Problems","content":" Levels:\u0026ensp;level-4 Data structures:\u0026ensp;array Algorithms:\u0026ensp;dynamic-programming,\u0026ensp;binary-search Practice Link: LeetCode\nDescription:\nGiven an unsorted array of integers, find the length of longest increasing subsequence. Example:\n1Input: [10,9,2,5,3,7,101,18] 2Output: 4 3Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.Note:\nThere may be more than one LIS combination, it is only necessary for you to return the length. Your algorithm should run in O(n2) complexity. Follow up:\nCould you improve it to O(n log n) time complexity? Python Solution:\n1class Solution(object): 2 def lengthOfLIS(self, nums): 3 tails = [0] * len(nums) 4 size = 0 5 for x in nums: 6 i, j = 0, size 7 while i != j: 8 m = (i + j) / 2 9 if tails[m] \u0026lt; x: 10 i = m + 1 11 else: 12 j = m 13 tails[i] = x 14 size = max(i + 1, size) 15 return size "},{"id":39,"href":"/tech-interview-prep/problems/longest-palindromic-substring/","title":"Longest palindromic substring","section":"All Problems","content":" Levels:\u0026ensp;level-4 Data structures:\u0026ensp;string Algorithms:\u0026ensp;dynamic-programming Practice Link: LeetCode\nDescription:\nGiven a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. Example 1:\n1Input: \u0026#34;babad\u0026#34; 2Output: \u0026#34;bab\u0026#34; 3Note: \u0026#34;aba\u0026#34; is also a valid answer.Example 2:\n1Input: \u0026#34;cbbd\u0026#34; 2Output: \u0026#34;bb\u0026#34;Python Solution:\n1class Solution(object): 2 def longestPalindrome(self, s): 3 \u0026#34;\u0026#34;\u0026#34; 4 :type s: str 5 :rtype: str 6 \u0026#34;\u0026#34;\u0026#34; 7 8 res = \u0026#34;\u0026#34; 9 for i in range(len(s)): 10 # odd case, like \u0026#34;aba\u0026#34; 11 tmp = self.helper(s, i, i) 12 if len(tmp) \u0026gt; len(res): 13 res = tmp 14 # even case, like \u0026#34;abba\u0026#34; 15 tmp = self.helper(s, i, i + 1) 16 if len(tmp) \u0026gt; len(res): 17 res = tmp 18 return res 19 20 # get the longest palindrome, l, r are the middle indexes 21 # from inner to outer 22 def helper(self, s, l, r): 23 while l \u0026gt;= 0 and r \u0026lt; len(s) and s[l] == s[r]: 24 l -= 1 25 r += 1 26 return s[l + 1:r] "},{"id":40,"href":"/tech-interview-prep/problems/longest-repeating-character-replacement/","title":"Longest repeating character replacement","section":"All Problems","content":" Levels:\u0026ensp;level-4 Data structures:\u0026ensp;string Patterns:\u0026ensp;sliding-window Practice Link: LeetCode\nDescription:\nGiven a string s that consists of only uppercase english letters, you can perform at most k operations on that string. In one operation, you can choose any character of the string and change it to any other uppercase English character. Find the length of the longest sub-string containing all repeating letters you can get after performing the above operations. Example 1:\n1Input: s = \u0026#34;ABAB\u0026#34;, k = 2 2 3Output: 4 4 5Explanation: 6Replace the two \u0026#39;A\u0026#39;s with two \u0026#39;B\u0026#39;s or vice versa.Example 2:\n1Input: s = \u0026#34;AABABBA\u0026#34;, k = 1 2 3Output: 4 4 5Explanation: 6Replace the one \u0026#39;A\u0026#39; in the middle with \u0026#39;B\u0026#39; and form \u0026#34;AABBBBA\u0026#34;. 7The substring \u0026#34;BBBB\u0026#34; has the longest repeating letters, which is 4.Note:\nBoth the string\u0026rsquo;s length and k will not exceed 10^4. Thinking:\nCan this have a sliding window based implementation? Python Solution:\n1import collections 2 3 4class Solution: 5 def characterReplacement(self, s, k): 6 counts = collections.Counter() 7 start = res = 0 8 9 # We use a window ranging from index start to end 10 # We only look in characters inside this window and keep track of their counts 11 # We can allow up to K chars that are not the most frequent char in our window 12 13 for end in range(len(s)): 14 # at each loop, end is shifted to the right 15 counts[s[end]] += 1 # we\u0026#39;ve seen character \u0026#39;s[end]\u0026#39; one more time in the this new window 16 17 # we shift start to the right only if we ran out of replacements 18 # we ran out of replacements if (CHARS that are not the most frequent in current window) \u0026gt; k 19 # (end - start + 1) is length of our window, because our window range is INCLUSIVE of both ends 20 if end - start + 1 - counts.most_common(1)[0][1] \u0026gt; k: 21 # since our window will be shifted, we subtract the character that we are shifting away from by 1 22 # because it will no longer be in the new window 23 counts[s[start]] -= 1 24 start += 1 # now shift our window 25 26 # at each window, simply update res if our current window is larger 27 res = max(res, end - start + 1) 28 29 return res "},{"id":41,"href":"/tech-interview-prep/problems/longest-substring-without-repeating-characters/","title":"Longest substring without repeating characters","section":"All Problems","content":" Levels:\u0026ensp;level-4 Data structures:\u0026ensp;string,\u0026ensp;hash-table Patterns:\u0026ensp;sliding-window Practice Link: LeetCode\nDescription:\nGiven a string, find the length of the longest substring without repeating characters. Example 1:\n1Input: \u0026#34;abcabcbb\u0026#34; 2Output: 3 3Explanation: The answer is \u0026#34;abc\u0026#34;, with the length of 3.Example 2:\n1Input: \u0026#34;pwwkew\u0026#34; 2Output: 3 3Explanation: The answer is \u0026#34;wke\u0026#34;, with the length of 3. 4Note that the answer must be a substring, \u0026#34;pwke\u0026#34; is a subsequence and not a substring.Python Solution:\n1class Solution: 2 # @return an integer 3 def lengthOfLongestSubstring(self, s): 4 used = {} 5 max_length = start = 0 6 for i, c in enumerate(s): 7 if c in used and start \u0026lt;= used[c]: 8 start = used[c] + 1 9 else: 10 max_length = max(max_length, i - start + 1) 11 12 used[c] = i 13 return max_length "},{"id":42,"href":"/tech-interview-prep/problems/lowest-common-ancestor-of-a-bst/","title":"Lowest common ancestor of a binary search tree","section":"All Problems","content":" Levels:\u0026ensp;level-2 Data structures:\u0026ensp;tree Practice Link: LeetCode\nDescription:\nGiven a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST. According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).” Example 1:\n1Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8 2Output: 6 3Explanation: The LCA of nodes 2 and 8 is 6.Example 2:\n1Output: 2 2Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.Note:\nAll of the nodes\u0026rsquo; values will be unique. p and q are different and both values will exist in the BST. Python Solution:\n1class TreeNode(object): 2 def __init__(self, x): 3 self.val = x 4 self.left = None 5 self.right = None 6 7 8class Solution: 9 # Recursive solution is O(N) in time and O(N) in space 10 def lowestCommonAncestorRecursive(self, root, p, q): 11 \u0026#34;\u0026#34;\u0026#34; 12 :type root: TreeNode 13 :type p: TreeNode 14 :type q: TreeNode 15 :rtype: TreeNode 16 \u0026#34;\u0026#34;\u0026#34; 17 # Value of current node or parent node. 18 parent_val = root.val 19 20 # Value of p 21 p_val = p.val 22 23 # Value of q 24 q_val = q.val 25 26 # If both p and q are greater than parent 27 if p_val \u0026gt; parent_val and q_val \u0026gt; parent_val: 28 return self.lowestCommonAncestorRecursive(root.right, p, q) 29 # If both p and q are lesser than parent 30 elif p_val \u0026lt; parent_val and q_val \u0026lt; parent_val: 31 return self.lowestCommonAncestorRecursive(root.left, p, q) 32 # We have found the split point, i.e. the LCA node. 33 else: 34 return root 35 36 # Iterative solution is O(N) in time and O(1) in space 37 def lowestCommonAncestorIterative(self, root, p, q): 38 \u0026#34;\u0026#34;\u0026#34; 39 :type root: TreeNode 40 :type p: TreeNode 41 :type q: TreeNode 42 :rtype: TreeNode 43 \u0026#34;\u0026#34;\u0026#34; 44 45 # Value of p 46 p_val = p.val 47 48 # Value of q 49 q_val = q.val 50 51 # Start from the root node of the tree 52 node = root 53 54 # Traverse the tree 55 while node: 56 57 # Value of current node or parent node. 58 parent_val = node.val 59 60 if p_val \u0026gt; parent_val and q_val \u0026gt; parent_val: 61 # If both p and q are greater than parent 62 node = node.right 63 elif p_val \u0026lt; parent_val and q_val \u0026lt; parent_val: 64 # If both p and q are lesser than parent 65 node = node.left 66 else: 67 # We have found the split point, i.e. the LCA node. 68 return node "},{"id":43,"href":"/tech-interview-prep/problems/maximum-depth-of-binary-tree/","title":"Maximum depth of binary tree","section":"All Problems","content":" Levels:\u0026ensp;level-0 Data structures:\u0026ensp;tree Algorithms:\u0026ensp;dfs Practice Link: LeetCode\nDescription:\nGiven a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Example:\n1Given binary tree [3,9,20,null,null,15,7], 2 3 3 4 / \\ 5 9 20 6 / \\ 7 15 7 8 9return its depth = 3.Note:\nA leaf is a node with no children. Python Solution:\n1class TreeNode(object): 2 def __init__(self, x): 3 self.val = x 4 self.left = None 5 self.right = None 6 7 8class Solution(object): 9 def maxDepth(self, root): 10 \u0026#34;\u0026#34;\u0026#34; 11 :type root: TreeNode 12 :rtype: int 13 \u0026#34;\u0026#34;\u0026#34; 14 return 1 + max(self.maxDepth(root.left), self.maxDepth( 15 root.right)) if root else 0 "},{"id":44,"href":"/tech-interview-prep/problems/maximum-product-subarray/","title":"Maximum product subarray","section":"All Problems","content":" Levels:\u0026ensp;level-3 Data structures:\u0026ensp;array Practice Link: LeetCode\nDescription:\nGiven an integer array nums, find the contiguous subarray within an array (containing at least one number) which has the largest product. Example 1:\n1Input: [2,3,-2,4] 2Output: 6 3Explanation: [2,3] has the largest product 6.Example 2:\n1Input: [-2,0,-1] 2Output: 0 3Explanation: The result cannot be 2, because [-2,-1] is not a subarray.Python Solution:\n1class Solution(object): 2 def maxProduct(self, nums): 3 \u0026#34;\u0026#34;\u0026#34; 4 :type nums: List[int] 5 :rtype: int 6 \u0026#34;\u0026#34;\u0026#34; 7 if not nums: 8 return 0 9 best = nums[0] 10 current_max = nums[0] 11 current_min = nums[0] 12 for x in range(1, len(nums)): 13 n = (nums[x], nums[x] * current_max, nums[x] * current_min) 14 current_max = max(n) 15 current_min = min(n) 16 best = max(current_max, best) 17 print(nums[x], current_max, current_min, best) 18 return best 19 20 21in_arrs = [ 22 # [2, 1, 2, 1, 0, 1, 2], 23 # [3, 3, 5, 0, 0, 3, 1, 4], 24 # [3, 5, 0, 1, 4], 25 # [1, 2, -1, 1], 26 # [1, 2, 3, 4], 27 # [1, 1, 1, 3, 3, 4, 3, 2, 4, 2], 28 # [-2, 1, -3, 4, -1, 2, 1, -5, 4], 29 [2, 3, -2, 4], 30 [-2, 0, -1], 31 [-2], 32 [-4, -3], 33 [-2, 3, -4], 34 [2, -3, 4], 35 [0, -2, -3], 36 [0, -2], 37 [2, -3, 4, 0], 38 [2, -5, -2, -4, 3], 39] 40 41if __name__ == \u0026#34;__main__\u0026#34;: 42 43 sol = Solution() 44 for nin in in_arrs: 45 print(nin) 46 r = sol.maxProduct(nin) 47 print(r) "},{"id":45,"href":"/tech-interview-prep/problems/maximum-subarray/","title":"Maximum subarray","section":"All Problems","content":" Levels:\u0026ensp;level-2 Data structures:\u0026ensp;array Algorithms:\u0026ensp;divide-and-conquer,\u0026ensp;dynamic-programming Practice Link: LeetCode\nDescription:\nGiven an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. Example 1:\n1Input: [-2,1,-3,4,-1,2,1,-5,4], 2Output: 6 3Explanation: [4,-1,2,1] has the largest sum = 6.Follow up:\nIf you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle. Python Solution:\n1class Solution(object): 2 def maxSubArray(self, nums): 3 if not nums: 4 return 0 5 best_sum = nums[0] 6 current_sum = 0 7 for x in nums: 8 current_sum = max(x, current_sum + x) 9 best_sum = max(best_sum, current_sum) 10 return best_sum 11 12 13in_arrs = [ 14 [2, 1, 2, 1, 0, 1, 2], 15 [3, 3, 5, 0, 0, 3, 1, 4], 16 [3, 5, 0, 1, 4], 17 [1, 2, -1, 1], 18 [1, 2, 3, 4], 19 [1, 1, 1, 3, 3, 4, 3, 2, 4, 2], 20 [-2, 1, -3, 4, -1, 2, 1, -5, 4], 21] 22if __name__ == \u0026#34;__main__\u0026#34;: 23 24 sol = Solution() 25 for nin in in_arrs: 26 r = sol.maxSubArray(nin) 27 print(r) "},{"id":46,"href":"/tech-interview-prep/problems/meeting-rooms/","title":"Meeting rooms","section":"All Problems","content":" Levels:\u0026ensp;level-4 Data structures:\u0026ensp;array Patterns:\u0026ensp;intervals Description:\nGiven an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],...] (si \u0026lt; ei), determine if a person could attend all meetings. Example 1:\n1Input: [[0, 30],[5, 10],[15, 20]], 2Output: false.Python Solution:\n1import operator 2 3 4class Interval: 5 def __init__(self, s=0, e=0): 6 self.start = s 7 self.end = e 8 9 10class Solution: 11 def canAttendMeetings(self, intervals): 12 \u0026#34;\u0026#34;\u0026#34; 13 :type intervals: list[Interval] 14 :rtype: bool 15 \u0026#34;\u0026#34;\u0026#34; 16 intervals.sort(key=operator.attrgetter(\u0026#34;start\u0026#34;)) 17 for i in range(len(intervals) - 1): 18 if intervals[i].end \u0026gt; intervals[i + 1].start: 19 return False 20 21 return True "},{"id":47,"href":"/tech-interview-prep/problems/meeting-rooms-ii/","title":"Meeting rooms II","section":"All Problems","content":" Levels:\u0026ensp;level-4 Data structures:\u0026ensp;array Patterns:\u0026ensp;intervals Description:\nGiven an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],...] (si \u0026lt; ei), find the minimum number of conference rooms required. i.e Find the maximum number of overlapped intervals Example 1:\n1Input: [[0, 30],[5, 10],[15, 20]], 2Output: 2Python Solution:\n1import heapq 2import operator 3 4 5class Interval: 6 def __init__(self, s=0, e=0): 7 self.start = s 8 self.end = e 9 10 11class Solution(object): 12 def minMeetingRooms(self, intervals): 13 \u0026#34;\u0026#34;\u0026#34; 14 :type intervals: list[Interval] 15 :rtype: int 16 \u0026#34;\u0026#34;\u0026#34; 17 maxa = 0 18 19 intervals.sort(key=operator.attrgetter(\u0026#34;start\u0026#34;)) 20 h_end = [] 21 for itvl in intervals: 22 heapq.heappush(h_end, itvl.end) 23 while h_end and h_end[0] \u0026lt;= itvl.start: 24 heapq.heappop(h_end) 25 26 maxa = max(maxa, len(h_end)) 27 28 return maxa "},{"id":48,"href":"/tech-interview-prep/problems/merge-intervals/","title":"Merge intervals","section":"All Problems","content":" Levels:\u0026ensp;level-3 Data structures:\u0026ensp;array Patterns:\u0026ensp;intervals Practice Link: LeetCode\nDescription:\nGiven a collection of intervals, merge all overlapping intervals. Example 1:\n1Input: [[1,3],[2,6],[8,10],[15,18]] 2Output: [[1,6],[8,10],[15,18]] 3Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].Example 2:\n1Input: [[1,4],[4,5]] 2Output: [[1,5]] 3Explanation: Intervals [1,4] and [4,5] are considered overlapping.Python Solution:\n1from typing import List 2 3 4class Solution: 5 def merge(self, intervals: List[List[int]]) -\u0026gt; List[List[int]]: 6 7 intervals.sort(key=lambda x: x[0]) 8 9 merged = [] 10 for interval in intervals: 11 # if the list of merged intervals is empty or if the current 12 # interval does not overlap with the previous, simply append it. 13 if not merged or merged[-1][1] \u0026lt; interval[0]: 14 merged.append(interval) 15 else: 16 # otherwise, there is overlap, so we merge the current and previous 17 # intervals. 18 merged[-1][1] = max(merged[-1][1], interval[1]) 19 20 return merged "},{"id":49,"href":"/tech-interview-prep/problems/merge-k-sorted-lists/","title":"Merge k sorted lists","section":"All Problems","content":" Levels:\u0026ensp;level-5 Data structures:\u0026ensp;linkedlist,\u0026ensp;heap Algorithms:\u0026ensp;divide-and-conquer Practice Link: LeetCode\nDescription:\nMerge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity. Example:\n1Input: 2[ 3 1-\u0026gt;4-\u0026gt;5, 4 1-\u0026gt;3-\u0026gt;4, 5 2-\u0026gt;6 6] 7Output: 1-\u0026gt;1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;4-\u0026gt;5-\u0026gt;6Python Solution:\n1class ListNode(object): 2 def __init__(self, x): 3 self.val = x 4 self.next = None 5 6 7class Solution(object): 8 # This O(N*log k). Divide and conquer 9 def mergeKLists(self, lists): 10 \u0026#34;\u0026#34;\u0026#34; 11 :type lists: List[ListNode] 12 :rtype: ListNode 13 \u0026#34;\u0026#34;\u0026#34; 14 amount = len(lists) 15 interval = 1 16 while interval \u0026lt; amount: 17 for i in range(0, amount - interval, interval * 2): 18 lists[i] = self.merge2Lists(lists[i], lists[i + interval]) 19 interval *= 2 20 return lists[0] if amount \u0026gt; 0 else lists 21 22 def merge2Lists(self, l1, l2): 23 head = point = ListNode(0) 24 while l1 and l2: 25 if l1.val \u0026lt;= l2.val: 26 point.next = l1 27 l1 = l1.next 28 else: 29 point.next = l2 30 l2 = l1 31 l1 = point.next.next 32 point = point.next 33 if not l1: 34 point.next = l2 35 else: 36 point.next = l1 37 return head.next "},{"id":50,"href":"/tech-interview-prep/problems/minimum-window-substring/","title":"Minimum window substring","section":"All Problems","content":" Levels:\u0026ensp;level-5 Data structures:\u0026ensp;string,\u0026ensp;hash-table Patterns:\u0026ensp;sliding-window Practice Link: LeetCode\nDescription:\nGiven a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n). Example 1:\n1Input: S = \u0026#34;ADOBECODEBANC\u0026#34;, T = \u0026#34;ABC\u0026#34; 2Output: \u0026#34;BANC\u0026#34;Note:\nIf there is no such window in S that covers all characters in T, return the empty string \u0026ldquo;\u0026rdquo;. If there is such window, you are guaranteed that there will always be only one unique minimum window in S. Thinking:\nCan this have a sliding window based approach? Python Solution:\n1from collections import Counter 2 3 4class Solution(object): 5 def minWindow(self, s, t): 6 \u0026#34;\u0026#34;\u0026#34; 7 :type s: str 8 :type t: str 9 :rtype: str 10 \u0026#34;\u0026#34;\u0026#34; 11 12 if not t or not s: 13 return \u0026#34;\u0026#34; 14 15 # Dictionary which keeps a count of all the unique characters in t. 16 dict_t = Counter(t) 17 18 # Number of unique characters in t, which need to be present in the desired window. 19 required = len(dict_t) 20 21 # left and right pointer 22 l, r = 0, 0 23 24 # formed is used to keep track of how many unique characters in t are present in the current window in its desired frequency. 25 # e.g. if t is \u0026#34;AABC\u0026#34; then the window must have two A\u0026#39;s, one B and one C. Thus formed would be = 3 when all these conditions are met. 26 formed = 0 27 28 # Dictionary which keeps a count of all the unique characters in the current window. 29 window_counts = {} 30 31 # ans tuple of the form (window length, left, right) 32 ans = float(\u0026#34;inf\u0026#34;), None, None 33 34 while r \u0026lt; len(s): 35 36 # Add one character from the right to the window 37 character = s[r] 38 window_counts[character] = window_counts.get(character, 0) + 1 39 40 # If the frequency of the current character added equals to the desired count in t then increment the formed count by 1. 41 if character in dict_t and window_counts[character] == dict_t[ 42 character]: 43 formed += 1 44 45 # Try and contract the window till the point where it ceases to be \u0026#39;desirable\u0026#39;. 46 while l \u0026lt;= r and formed == required: 47 character = s[l] 48 49 # Save the smallest window until now. 50 if r - l + 1 \u0026lt; ans[0]: 51 ans = (r - l + 1, l, r) 52 53 # The character at the position pointed by the `left` pointer is no longer a part of the window. 54 window_counts[character] -= 1 55 if character in dict_t and window_counts[character] \u0026lt; dict_t[ 56 character]: 57 formed -= 1 58 59 # Move the left pointer ahead, this would help to look for a new window. 60 l += 1 61 62 # Keep expanding the window once we are done contracting. 63 r += 1 64 return \u0026#34;\u0026#34; if ans[0] == float(\u0026#34;inf\u0026#34;) else s[ans[1]:ans[2] + 1] "},{"id":51,"href":"/tech-interview-prep/problems/missing-number/","title":"Missing number","section":"All Problems","content":" Levels:\u0026ensp;level-2 Data structures:\u0026ensp;bits,\u0026ensp;array Practice Link: LeetCode\nDescription:\nGiven an array containing n distinct numbers taken from 0, 1, 2, \u0026hellip;, n, find the one that is missing from the array. Example 1:\n1Input: [3,0,1] 2Output: 2Example 2:\n1Input: [9,6,4,2,3,5,7,0,1] 2Output: 8Note:\nYour algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity? Thinking:\nWe can harness the fact that XOR is its own inverse to find the missing element in linear time. Because we know that nums contains n numbers and that it is missing exactly one number on the range [0..n-1][0..n−1], we know that nn definitely replaces the missing number in nums. Therefore, if we initialize an integer to nn and XOR it with every index and value, we will be left with the missing number. Python Solution:\n1class Solution: 2 def missingNumber(self, nums): 3 missing = len(nums) 4 for i, num in enumerate(nums): 5 missing ^= i ^ num 6 return missing "},{"id":52,"href":"/tech-interview-prep/problems/non-overlapping-intervals/","title":"Non overlapping intervals","section":"All Problems","content":" Levels:\u0026ensp;level-4 Data structures:\u0026ensp;array Algorithms:\u0026ensp;greedy Patterns:\u0026ensp;intervals Practice Link: LeetCode\nDescription:\nGiven a collection of intervals, find the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping. Example 1:\n1Input: [[1,2],[2,3],[3,4],[1,3]] 2Output: 1 3Explanation: [1,3] can be removed and the rest of intervals are non-overlapping.Example 2:\n1Input: [[1,2],[1,2],[1,2]] 2Output: 2 3Explanation: You need to remove two [1,2] to make the rest of intervals non-overlapping.Example 3:\n1Input: [[1,2],[2,3]] 2Output: 0 3Explanation: You don\u0026#39;t need to remove any of the intervals since they\u0026#39;re already non-overlapping.Note:\nYou may assume the interval\u0026rsquo;s end point is always bigger than its start point. Intervals like [1,2] and [2,3] have borders \u0026ldquo;touching\u0026rdquo; but they don\u0026rsquo;t overlap each other. Python Solution:\n1class Solution(object): 2 def eraseOverlapIntervals(self, intervals): 3 \u0026#34;\u0026#34;\u0026#34; 4 :type intervals: List[List[int]] 5 :rtype: int 6 \u0026#34;\u0026#34;\u0026#34; 7 end = float(\u0026#39;-inf\u0026#39;) 8 erased = 0 9 for i in sorted(intervals, key=lambda i: i.end): 10 if i.start \u0026gt;= end: 11 end = i.end 12 else: 13 erased += 1 14 return erased "},{"id":53,"href":"/tech-interview-prep/problems/number-of-1-bits/","title":"Number of 1 bits","section":"All Problems","content":" Levels:\u0026ensp;level-1 Data structures:\u0026ensp;bits Practice Link: LeetCode\nDescription:\nWrite a function that takes an unsigned integer and return the number of \u0026lsquo;1\u0026rsquo; bits it has (also known as the Hamming weight). Example 1:\n1Input: 00000000000000000000000000001011 2Output: 3 3Explanation: The input binary string 00000000000000000000000000001011 has a total of three \u0026#39;1\u0026#39; bits.Python Solution:\n1class Solution(object): 2 # Use inbuilt functions 3 def hammingWeightBuiltin(self, n): 4 \u0026#34;\u0026#34;\u0026#34; 5 :type n: int 6 :rtype: int 7 \u0026#34;\u0026#34;\u0026#34; 8 return bin(n).count(\u0026#39;1\u0026#39;) 9 10 # Using bit operation to cancel a 1 in each round 11 # Think of a number in binary `n = XXXXXX1000, n - 1 is XXXXXX0111`. 12 # `n \u0026amp; (n - 1)` will be `XXXXXX0000` which just canceled the last `1` 13 def hammingWeightBitwise(self, n): 14 \u0026#34;\u0026#34;\u0026#34; 15 :type n: int 16 :rtype: int 17 \u0026#34;\u0026#34;\u0026#34; 18 c = 0 19 while n: 20 n \u0026amp;= n - 1 21 c += 1 22 return c "},{"id":54,"href":"/tech-interview-prep/problems/number-of-connected-components-in-an-undirected-graph/","title":"Number of connected components in an undirected graph","section":"All Problems","content":" Levels:\u0026ensp;level-5 Data structures:\u0026ensp;graph Description:\nGiven n nodes labeled from 0 to n - 1 and a list of undirected edges (each edge is a pair of nodes), write a function to find the number of connected components in an undirected graph. Example 1:\n1 2 0 3 3 | | 4 1 --- 2 4 5 6Given n = 5 and edges = [[0, 1], [1, 2], [3, 4]], return 2.Example 2:\n1 0 4 2 | | 3 1 --- 2 --- 3 4 5Given n = 5 and edges = [[0, 1], [1, 2], [2, 3], [3, 4]], return 1.Note:\nYou can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0, 1] is the same as [1, 0] and thus will not appear together in edges. Python Solution:\n1class Solution(object): 2 def countComponents(self, n, edges): 3 \u0026#34;\u0026#34;\u0026#34; 4 :type n: int 5 :type edges: List[List[int]] 6 :rtype: int 7 \u0026#34;\u0026#34;\u0026#34; 8 V = [[] for _ in range(n)] 9 for e in edges: 10 V[e[0]].append(e[1]) 11 V[e[1]].append(e[0]) 12 13 visited = [False for _ in range(n)] 14 cnt = 0 15 for v in range(n): 16 if not visited[v]: 17 cnt += 1 18 self.dfs(V, v, visited) 19 20 return cnt 21 22 def dfs(self, V, v, visited): 23 visited[v] = True 24 for nbr in V[v]: 25 if not visited[nbr]: 26 self.dfs(V, nbr, visited) "},{"id":55,"href":"/tech-interview-prep/problems/number-of-islands/","title":"Number of islands","section":"All Problems","content":" Levels:\u0026ensp;level-4 Data structures:\u0026ensp;graph Algorithms:\u0026ensp;dfs,\u0026ensp;bfs Patterns:\u0026ensp;union-find Practice Link: LeetCode\nDescription:\nGiven a 2d grid map of \u0026lsquo;1\u0026rsquo;s (land) and \u0026lsquo;0\u0026rsquo;s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. Example 1:\n1Input: 211110 311010 411000 500000 6Output: 1Example 2:\n1Input: 211000 311000 400100 500011 6Output: 3Python Solution:\n1class Solution(object): 2 # Iterate through each of the cell and if it is an island, 3 # do dfs to mark all adjacent islands, 4 # then increase the counter by 1. 5 def numIslands(self, grid): 6 if not grid: 7 return 0 8 9 count = 0 10 for i in range(len(grid)): 11 for j in range(len(grid[0])): 12 if grid[i][j] == \u0026#39;1\u0026#39;: 13 self.dfs(grid, i, j) 14 count += 1 15 return count 16 17 def dfs(self, grid, i, j): 18 if i \u0026lt; 0 or j \u0026lt; 0 or i \u0026gt;= len(grid) or j \u0026gt;= len( 19 grid[0]) or grid[i][j] != \u0026#39;1\u0026#39;: 20 return 21 grid[i][j] = \u0026#39;#\u0026#39; 22 self.dfs(grid, i + 1, j) 23 self.dfs(grid, i - 1, j) 24 self.dfs(grid, i, j + 1) 25 self.dfs(grid, i, j - 1) "},{"id":56,"href":"/tech-interview-prep/problems/pacific-atlantic-water-flow/","title":"Pacific-Atlantic water flow","section":"All Problems","content":" Levels:\u0026ensp;level-4 Data structures:\u0026ensp;graph Algorithms:\u0026ensp;dfs,\u0026ensp;bfs Practice Link: LeetCode\nDescription:\nGiven an m x n matrix of non-negative integers representing the height of each unit cell in a continent, the \u0026ldquo;Pacific ocean\u0026rdquo; touches the left and top edges of the matrix and the \u0026ldquo;Atlantic ocean\u0026rdquo; touches the right and bottom edges. Water can only flow in four directions (up, down, left, or right) from a cell to another one with height equal or lower. Find the list of grid coordinates where water can flow to both the Pacific and Atlantic ocean. Example:\n1Input: 2 Pacific ~ ~ ~ ~ ~ 3 ~ 1 2 2 3 (5) * 4 ~ 3 2 3 (4) (4) * 5 ~ 2 4 (5) 3 1 * 6 ~ (6) (7) 1 4 5 * 7 ~ (5) 1 1 2 4 * 8 * * * * * Atlantic 9Output: 10[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] 11(positions with parentheses in above matrix).Note:\nThe order of returned grid coordinates does not matter. Both m and n are less than 150. Python Solution:\n1class Solution(object): 2 def pacificAtlantic(self, matrix): 3 \u0026#34;\u0026#34;\u0026#34; 4 :type matrix: List[List[int]] 5 :rtype: List[List[int]] 6 \u0026#34;\u0026#34;\u0026#34; 7 if not matrix: return [] 8 self.directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] 9 m = len(matrix) 10 n = len(matrix[0]) 11 p_visited = [[False for _ in range(n)] for _ in range(m)] 12 13 a_visited = [[False for _ in range(n)] for _ in range(m)] 14 result = [] 15 16 for i in range(m): 17 # p_visited[i][0] = True 18 # a_visited[i][n-1] = True 19 self.dfs(matrix, i, 0, p_visited, m, n) 20 self.dfs(matrix, i, n - 1, a_visited, m, n) 21 for j in range(n): 22 # p_visited[0][j] = True 23 # a_visited[m-1][j] = True 24 self.dfs(matrix, 0, j, p_visited, m, n) 25 self.dfs(matrix, m - 1, j, a_visited, m, n) 26 27 for i in range(m): 28 for j in range(n): 29 if p_visited[i][j] and a_visited[i][j]: 30 result.append([i, j]) 31 return result 32 33 def dfs(self, matrix, i, j, visited, m, n): 34 # when dfs called, meaning its caller already verified this point 35 visited[i][j] = True 36 for dir in self.directions: 37 x, y = i + dir[0], j + dir[1] 38 if x \u0026lt; 0 or x \u0026gt;= m or y \u0026lt; 0 or y \u0026gt;= n or visited[x][ 39 y] or matrix[x][y] \u0026lt; matrix[i][j]: 40 continue 41 self.dfs(matrix, x, y, visited, m, n) "},{"id":57,"href":"/tech-interview-prep/problems/palindromic-substrings/","title":"Palindromic substrings","section":"All Problems","content":" Levels:\u0026ensp;level-4 Data structures:\u0026ensp;string Algorithms:\u0026ensp;dynamic-programming Practice Link: LeetCode\nDescription:\nGiven a string, your task is to count how many palindromic substrings in this string. The substrings with different start indexes or end indexes are counted as different substrings even they consist of same characters. Example 1:\n1Input: \u0026#34;abc\u0026#34; 2Output: 3 3Explanation: Three palindromic strings: \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;.Example 2:\n1Input: \u0026#34;aaa\u0026#34; 2Output: 6 3Explanation: Six palindromic strings: \u0026#34;a\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;aa\u0026#34;, \u0026#34;aa\u0026#34;, \u0026#34;aaa\u0026#34;.Note:\nThe input string length won\u0026rsquo;t exceed 1000. Python Solution:\n1class Solution(object): 2 # Let N be the length of the string. The middle of the palindrome could be in one of 2N - 1 positions: either at letter or between two letters. 3 # For each center, let\u0026#39;s count all the palindromes that have this center. Notice that if [a, b] is a palindromic interval (meaning S[a], S[a+1], ..., S[b] is a palindrome), then [a+1, b-1] is one too. 4 # Algorithm 5 # For each possible palindrome center, 6 # let\u0026#39;s expand our candidate palindrome on the interval [left, right] as long as we can. 7 # The condition for expanding is left \u0026gt;= 0 and right \u0026lt; N and S[left] == S[right]. 8 # That means we want to count a new palindrome S[left], S[left+1], ..., S[right]. 9 def countSubstrings(self, S): 10 N = len(S) 11 ans = 0 12 for center in range(2 * N - 1): 13 left = center / 2 14 right = left + center % 2 15 while left \u0026gt;= 0 and right \u0026lt; N and S[left] == S[right]: 16 ans += 1 17 left -= 1 18 right += 1 19 return ans "},{"id":58,"href":"/tech-interview-prep/problems/product-of-array-except-self/","title":"Product of array except self","section":"All Problems","content":" Levels:\u0026ensp;level-3 Data structures:\u0026ensp;array Practice Link: LeetCode\nDescription:\nGiven an array nums of n integers where n \u0026gt; 1, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i]. Note:\nPlease solve it without division and in O(n). Python Solution:\n1class Solution(object): 2 def productExceptSelf(self, nums): 3 \u0026#34;\u0026#34;\u0026#34; 4 :type nums: List[int] 5 :rtype: List[int] 6 \u0026#34;\u0026#34;\u0026#34; 7 out = [1 for idx in range(len(nums))] 8 for idx, _ in enumerate(nums): 9 outp = 1 10 for jdx, n in enumerate(nums): 11 if idx != jdx: 12 outp *= n 13 out[idx] = outp 14 return out 15 16 17class Solution2(object): 18 def productExceptSelf(self, nums): 19 20 # The length of the input array 21 length = len(nums) 22 23 # The left and right arrays as described in the algorithm 24 L, R, answer = [0] * length, [0] * length, [0] * length 25 26 # L[i] contains the product of all the elements to the left 27 # Note: for the element at index \u0026#39;0\u0026#39;, there are no elements to the left, 28 # so the L[0] would be 1 29 L[0] = 1 30 for i in range(1, length): 31 32 # L[i - 1] already contains the product of elements to the left of \u0026#39;i - 1\u0026#39; 33 # Simply multiplying it with nums[i - 1] would give the product of all 34 # elements to the left of index \u0026#39;i\u0026#39; 35 L[i] = nums[i - 1] * L[i - 1] 36 37 # R[i] contains the product of all the elements to the right 38 # Note: for the element at index \u0026#39;length - 1\u0026#39;, there are no elements to the right, 39 # so the R[length - 1] would be 1 40 R[length - 1] = 1 41 for i in reversed(range(length - 1)): 42 43 # R[i + 1] already contains the product of elements to the right of \u0026#39;i + 1\u0026#39; 44 # Simply multiplying it with nums[i + 1] would give the product of all 45 # elements to the right of index \u0026#39;i\u0026#39; 46 R[i] = nums[i + 1] * R[i + 1] 47 48 # Constructing the answer array 49 for i in range(length): 50 # For the first element, R[i] would be product except self 51 # For the last element of the array, product except self would be L[i] 52 # Else, multiple product of all elements to the left and to the right 53 answer[i] = L[i] * R[i] 54 55 return answer 56 57 58in_arrs = [ 59 [2, 1, 2, 1, 0, 1, 2], 60 [3, 3, 5, 0, 0, 3, 1, 4], 61 [3, 5, 0, 1, 4], 62 [1, 2, 3, 1], 63 [1, 2, 3, 4], 64 [1, 1, 1, 3, 3, 4, 3, 2, 4, 2], 65] 66if __name__ == \u0026#34;__main__\u0026#34;: 67 68 sol = Solution2() 69 for nin in in_arrs: 70 r = sol.productExceptSelf(nin) 71 print(r) "},{"id":59,"href":"/tech-interview-prep/problems/remove-nth-node-from-end-of-list/","title":"Remove n'th node from end of list","section":"All Problems","content":" Levels:\u0026ensp;level-3 Data structures:\u0026ensp;linkedlist Practice Link: LeetCode\nDescription:\nGiven a linked list, remove the n-th node from the end of list and return its head. Example 1:\n1Given linked list: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5, and n = 2. 2After removing the second node from the end, the linked list becomes 1-\u0026gt;2-\u0026gt;3-\u0026gt;5.Note:\nGiven n will always be valid. Follow up:\nCould you do this in one pass? Python Solution:\n1class ListNode(object): 2 def __init__(self, x): 3 self.val = x 4 self.next = None 5 6 7class Solution: 8 def removeNthFromEnd(self, head, n): 9 if not head: 10 return 11 fast = slow = head 12 for _ in range(n): 13 if not fast.next: 14 raise Exception(\u0026#34;less than n nodes found\u0026#34;) 15 fast = fast.next 16 if not fast: 17 return head.next 18 while fast.next: 19 fast = fast.next 20 slow = slow.next 21 slow.next = slow.next.next 22 return head "},{"id":60,"href":"/tech-interview-prep/problems/reorder-list/","title":"Reorder list","section":"All Problems","content":" Levels:\u0026ensp;level-3 Data structures:\u0026ensp;linkedlist Practice Link: LeetCode\nDescription:\nGiven a singly linked list L: L0→L1→…→Ln-1→Ln, reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→… You may not modify the values in the list\u0026rsquo;s nodes, only nodes itself may be changed. Example 1:\n1Given 1-\u0026gt;2-\u0026gt;3-\u0026gt;4, reorder it to 1-\u0026gt;4-\u0026gt;2-\u0026gt;3.Example 2:\n1Given 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5, reorder it to 1-\u0026gt;5-\u0026gt;2-\u0026gt;4-\u0026gt;3.Python Solution:\n1class ListNode(object): 2 def __init__(self, x): 3 self.val = x 4 self.next = None 5 6 7class Solution(object): 8 def reorderList(self, head): 9 \u0026#34;\u0026#34;\u0026#34; 10 :type head: ListNode 11 :rtype: None Do not return anything, modify head in-place instead. 12 \u0026#34;\u0026#34;\u0026#34; 13 if not head: 14 return 15 16 # find the mid point 17 slow = fast = head 18 while fast and fast.next: 19 slow = slow.next 20 fast = fast.next.next 21 22 # reverse the second half in-place 23 pre, node = None, slow 24 while node: 25 pre, node.next, node = node, pre, node.next 26 27 # Merge in-place; Note : the last node of \u0026#34;first\u0026#34; and \u0026#34;second\u0026#34; are the same 28 first, second = head, pre 29 while second.next: 30 first.next, first = second, first.next 31 second.next, second = first, second.next 32 return "},{"id":61,"href":"/tech-interview-prep/problems/reverse-bits/","title":"Reverse bits","section":"All Problems","content":" Levels:\u0026ensp;level-2 Data structures:\u0026ensp;bits Practice Link: LeetCode\nDescription:\nReverse bits of a given 32 bits unsigned integer. Example 1:\n1Input: 00000010100101000001111010011100 2Output: 00111001011110000010100101000000 3Explanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000.Follow up:\nIf this function is called many times, how would you optimize it? Thinking:\nWe first intitialize result to 0. We then iterate from 0 to 31 (an integer has 32 bits). In each iteration: We first shift result to the left by 1 bit. Then, if the last digit of input n is 1, we add 1 to result. To find the last digit of n, we just do: (n \u0026amp; 1) Example, if n=5 (101), n\u0026amp;1 = 101 \u0026amp; 001 = 001 = 1; however, if n = 2 (10), n\u0026amp;1 = 10 \u0026amp; 01 = 00 = 0). Finally, we update n by shifting it to the right by 1 (n \u0026raquo;= 1). This is because the last digit is already taken care of, so we need to drop it by shifting n to the right by 1. At the end of the iteration, we return result. Python Solution:\n1class Solution: 2 # @param n, an integer 3 # @return an integer 4 def reverseBits(self, n): 5 res = 0 6 for _ in range(32): 7 res = (res \u0026lt;\u0026lt; 1) + (n \u0026amp; 1) 8 n \u0026gt;\u0026gt;= 1 9 return res 10 11 # Use bit hacks to directly do in O(1) 12 # for 8 bit binary number abcdefgh, the process is as follow: 13 # abcdefgh -\u0026gt; efghabcd -\u0026gt; ghefcdab -\u0026gt; hgfedcba 14 def reverseBitsHack(self, n): 15 n = (n \u0026gt;\u0026gt; 16) | (n \u0026lt;\u0026lt; 16) 16 n = ((n \u0026amp; 0xff00ff00) \u0026gt;\u0026gt; 8) | ((n \u0026amp; 0x00ff00ff) \u0026lt;\u0026lt; 8) 17 n = ((n \u0026amp; 0xf0f0f0f0) \u0026gt;\u0026gt; 4) | ((n \u0026amp; 0x0f0f0f0f) \u0026lt;\u0026lt; 4) 18 n = ((n \u0026amp; 0xcccccccc) \u0026gt;\u0026gt; 2) | ((n \u0026amp; 0x33333333) \u0026lt;\u0026lt; 2) 19 n = ((n \u0026amp; 0xaaaaaaaa) \u0026gt;\u0026gt; 1) | ((n \u0026amp; 0x55555555) \u0026lt;\u0026lt; 1) 20 return n "},{"id":62,"href":"/tech-interview-prep/problems/reverse-linked-list/","title":"Reverse linked list","section":"All Problems","content":" Levels:\u0026ensp;level-1 Data structures:\u0026ensp;linkedlist Practice Link: LeetCode\nDescription:\nReverse a singly linked list. Example 1:\n1Input: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5-\u0026gt;NULL 2Output: 5-\u0026gt;4-\u0026gt;3-\u0026gt;2-\u0026gt;1-\u0026gt;NULLFollow up:\nA linked list can be reversed either iteratively or recursively. Could you implement both? Python Solution:\n1class ListNode(object): 2 def __init__(self, x): 3 self.val = x 4 self.next = None 5 6 7class Solution(object): 8 def reverseList(self, head): # Iterative 9 prev, curr = None, head 10 while curr: 11 curr.next, prev, curr = prev, curr, curr.next 12 return prev 13 14 def reverseList_v1(self, head): # Recursive 15 \u0026#34;\u0026#34;\u0026#34; 16 :type head: ListNode 17 :rtype: ListNode 18 \u0026#34;\u0026#34;\u0026#34; 19 if not head or not head.next: 20 return head 21 p = self.reverseList_v1(head.next) 22 head.next.next = head 23 head.next = None 24 return p "},{"id":63,"href":"/tech-interview-prep/problems/rotate-image/","title":"Rotate image","section":"All Problems","content":" Levels:\u0026ensp;level-3 Data structures:\u0026ensp;array Practice Link: LeetCode\nDescription:\nYou are given an n x n 2D matrix representing an image. Rotate the image by 90 degrees (clockwise). Example 1:\n1Given input matrix = 2[ 3 [1,2,3], 4 [4,5,6], 5 [7,8,9] 6], 7 8rotate the input matrix in-place such that it becomes: 9[ 10 [7,4,1], 11 [8,5,2], 12 [9,6,3] 13]Example 2:\n1Given input matrix = 2[ 3 [ 5, 1, 9,11], 4 [ 2, 4, 8,10], 5 [13, 3, 6, 7], 6 [15,14,12,16] 7], 8 9rotate the input matrix in-place such that it becomes: 10[ 11 [15,13, 2, 5], 12 [14, 3, 4, 1], 13 [12, 6, 8, 9], 14 [16, 7,10,11] 15]Note:\nYou have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation. Python Solution:\n1class Solution(object): 2 # Pythonic with extended slices and zip syntax 3 def rotate(self, A): 4 \u0026#34;\u0026#34;\u0026#34; 5 :type matrix: List[List[int]] 6 :rtype: None Do not return anything, modify matrix in-place instead. 7 \u0026#34;\u0026#34;\u0026#34; 8 A[:] = list(zip(*A[::-1])) 9 10 # first transpose and then flip left-right 11 def rotateManual(self, A): 12 n = len(A) 13 for i in range(n): 14 for j in range(i): 15 A[i][j], A[j][i] = A[j][i], A[i][j] 16 for row in A: 17 for j in range(n / 2): 18 row[j], row[~j] = row[~j], row[j] "},{"id":64,"href":"/tech-interview-prep/problems/same-tree/","title":"Same tree","section":"All Problems","content":" Levels:\u0026ensp;level-2 Data structures:\u0026ensp;tree Algorithms:\u0026ensp;dfs Practice Link: LeetCode\nDescription:\nGiven two binary trees, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical and the nodes have the same value. Example 1:\n1Input: 1 1 2 / \\ / \\ 3 2 3 2 3 4 5 [1,2,3], [1,2,3] 6 7Output: trueExample 2:\n1Input: 1 1 2 / \\ 3 2 2 4 5 [1,2], [1,null,2] 6 7Output: falsePython Solution:\n1from collections import deque 2 3 4class TreeNode(object): 5 def __init__(self, x): 6 self.val = x 7 self.left = None 8 self.right = None 9 10 11class Solution: 12 # Recursive solution 13 def isSameTree(self, p, q): 14 \u0026#34;\u0026#34;\u0026#34; 15 :type p: TreeNode 16 :type q: TreeNode 17 :rtype: bool 18 \u0026#34;\u0026#34;\u0026#34; 19 # p and q are both None 20 if not p and not q: 21 return True 22 # one of p and q is None 23 if not q or not p: 24 return False 25 if p.val != q.val: 26 return False 27 return self.isSameTree(p.right, q.right) and \\ 28 self.isSameTree(p.left, q.left) 29 30 # Iterative solution 31 def isSameTreeIterative(self, p, q): 32 \u0026#34;\u0026#34;\u0026#34; 33 :type p: TreeNode 34 :type q: TreeNode 35 :rtype: bool 36 \u0026#34;\u0026#34;\u0026#34; 37 def check(p, q): 38 # if both are None 39 if not p and not q: 40 return True 41 # one of p and q is None 42 if not q or not p: 43 return False 44 if p.val != q.val: 45 return False 46 return True 47 48 deq = deque([ 49 (p, q), 50 ]) 51 while deq: 52 p, q = deq.popleft() 53 if not check(p, q): 54 return False 55 56 if p: 57 deq.append((p.left, q.left)) 58 deq.append((p.right, q.right)) 59 60 return True "},{"id":65,"href":"/tech-interview-prep/problems/search-in-rotated-sorted-array/","title":"Search in rotated sorted array","section":"All Problems","content":" Levels:\u0026ensp;level-3 Data structures:\u0026ensp;array Algorithms:\u0026ensp;binary-search Practice Link: LeetCode\nDescription:\nSuppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). You are given a target value to search. If found in the array return its index, otherwise return -1. You may assume no duplicate exists in the array. Your algorithm\u0026rsquo;s runtime complexity must be in the order of O(log n). Python Solution:\n1class Solution(object): 2 def search(self, nums, target): 3 \u0026#34;\u0026#34;\u0026#34; 4 :type nums: List[int] 5 :type target: int 6 :rtype: int 7 \u0026#34;\u0026#34;\u0026#34; 8 if not nums: 9 return -1 10 return self.__search(nums, 0, len(nums) - 1, target) 11 12 def __binsearch(self, nums, i, j, target): 13 if i == j: 14 if nums[i] == target: 15 return i 16 return -1 17 18 if i + 1 == j: 19 if nums[i] == target: 20 return i 21 if nums[j] == target: 22 return j 23 return -1 24 25 mid = int((i + j) / 2) 26 if nums[mid] \u0026lt; target: 27 return self.__binsearch(nums, mid, j, target) 28 return self.__binsearch(nums, i, mid, target) 29 30 def __search(self, nums, i, j, target): 31 if i == j: 32 if nums[i] == target: 33 return i 34 return -1 35 36 if i + 1 == j: 37 if nums[i] == target: 38 return i 39 if nums[j] == target: 40 return j 41 return -1 42 43 if nums[i] \u0026lt; nums[j]: 44 return self.__binsearch(nums, i, j, target) 45 46 mid = int((i + j) / 2) 47 if nums[i] \u0026lt; nums[mid]: 48 if (target \u0026lt;= nums[mid]) and (target \u0026gt;= nums[i]): 49 return self.__binsearch(nums, i, mid, target) 50 return self.__search(nums, mid, j, target) 51 if (target \u0026gt;= nums[mid]) and (target \u0026lt;= nums[j]): 52 return self.__binsearch(nums, mid, j, target) 53 return self.__search(nums, i, mid, target) 54 55 56class Solution2(object): 57 def find_min_index(self, nums): 58 \u0026#34;\u0026#34;\u0026#34; 59 :type nums: List[int] 60 :rtype: int 61 \u0026#34;\u0026#34;\u0026#34; 62 if not nums: 63 return None 64 lo = 0 65 hi = len(nums) - 1 66 while lo \u0026lt; hi: 67 mid = (lo + hi) / 2 68 if (nums[mid] \u0026gt; nums[hi]): 69 lo = mid + 1 70 else: 71 hi = mid 72 return lo 73 74 def search(self, nums, target): 75 \u0026#34;\u0026#34;\u0026#34; 76 :type nums: List[int] 77 :type target: int 78 :rtype: int 79 \u0026#34;\u0026#34;\u0026#34; 80 if not nums: 81 return -1 82 rot_index = self.find_min_index(nums) 83 hi = len(nums) - 1 84 if rot_index == 0: 85 return self.__binsearch(nums, rot_index, hi, target) 86 if target \u0026gt;= nums[rot_index] and target \u0026lt;= nums[hi]: 87 return self.__binsearch(nums, rot_index, hi, target) 88 return self.__binsearch(nums, 0, rot_index - 1, target) 89 90 def __binsearch(self, nums, i, j, target): 91 if i \u0026gt; j: 92 return -1 93 if i == j: 94 if nums[i] == target: 95 return i 96 return -1 97 98 if i + 1 == j: 99 if nums[i] == target: 100 return i 101 if nums[j] == target: 102 return j 103 return -1 104 105 mid = int((i + j) / 2) 106 if nums[mid] \u0026lt; target: 107 return self.__binsearch(nums, mid, j, target) 108 return self.__binsearch(nums, i, mid, target) 109 110 111in_arrs = [ 112 ([3, 4, 5, 1, 2], 4), 113 ([4, 5, 6, 7, 0, 1, 2], 1), 114 ([8, 1, 2, 3], 3), 115 ([1, 2, 3, 4], 5), 116 ([1], 1), 117 ([], 1), 118 (None, 1), 119 ([5, 1, 3, 4], 5), 120 ([8, 1, 2, 3], 1), 121 ([1, 2, 3, 4], 4), 122 ([1, 2, 3, 4], 1), 123 ([1], 0), 124] 125 126exp_out = [ 127 1, 128 5, 129 3, 130 -1, 131 0, 132 -1, 133 -1, 134 0, 135 1, 136 3, 137 0, 138 -1, 139] 140 141if __name__ == \u0026#34;__main__\u0026#34;: 142 143 sol = Solution() 144 sol2 = Solution() 145 for idx, nin in enumerate(in_arrs): 146 r = sol.search(nin[0], nin[1]) 147 print(exp_out[idx] == r, r) 148 r = sol2.search(nin[0], nin[1]) 149 print(exp_out[idx] == r, r) "},{"id":66,"href":"/tech-interview-prep/problems/serialize-and-deserialize-binary-tree/","title":"Serialize and deserialize a binary tree","section":"All Problems","content":" Levels:\u0026ensp;level-5 Data structures:\u0026ensp;tree Practice Link: LeetCode\nDescription:\nSerialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure. Example:\n1You may serialize the following tree: 2 1 3 / \\ 4 2 3 5 / \\ 6 4 5 7 8as \u0026#34;[1,2,3,null,null,4,5]\u0026#34;Clarification:\nThe above format is the same as how LeetCode serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself. Note:\nDo not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless. Python Solution:\n1# Definition for a binary tree node. 2class TreeNode(object): 3 def __init__(self, x): 4 self.val = x 5 self.left = None 6 self.right = None 7 8 9class Codec: 10 def serialize(self, root): 11 \u0026#34;\u0026#34;\u0026#34;Encodes a tree to a single string. 12 13 :type root: TreeNode 14 :rtype: str 15 \u0026#34;\u0026#34;\u0026#34; 16 def doit(node): 17 if node: 18 vals.append(str(node.val)) 19 doit(node.left) 20 doit(node.right) 21 else: 22 vals.append(\u0026#39;#\u0026#39;) 23 24 vals = [] 25 doit(root) 26 return \u0026#39; \u0026#39;.join(vals) 27 28 def deserialize(self, data): 29 \u0026#34;\u0026#34;\u0026#34;Decodes your encoded data to tree. 30 31 :type data: str 32 :rtype: TreeNode 33 \u0026#34;\u0026#34;\u0026#34; 34 def doit(): 35 val = next(vals) 36 if val == \u0026#39;#\u0026#39;: 37 return None 38 node = TreeNode(int(val)) 39 node.left = doit() 40 node.right = doit() 41 return node 42 43 vals = iter(data.split()) 44 return doit() 45 46 47# codec = Codec() 48# codec.deserialize(codec.serialize(root)) "},{"id":67,"href":"/tech-interview-prep/problems/set-matrix-zeroes/","title":"Set matrix zeroes","section":"All Problems","content":" Levels:\u0026ensp;level-3 Data structures:\u0026ensp;array Practice Link: LeetCode\nDescription:\nGiven a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in-place. Example 1:\n1Input: 2[ 3 [1,1,1], 4 [1,0,1], 5 [1,1,1] 6] 7Output: 8[ 9 [1,0,1], 10 [0,0,0], 11 [1,0,1] 12]Example 2:\n1Input: 2[ 3 [0,1,2,0], 4 [3,4,5,2], 5 [1,3,1,5] 6] 7Output: 8[ 9 [0,0,0,0], 10 [0,4,5,0], 11 [0,3,1,0] 12]Follow up:\nA straight forward solution using O(mn) space is probably a bad idea. A simple improvement uses O(m + n) space, but still not the best solution. Could you devise a constant space solution? Python Solution:\n1class Solution: 2 # @param {integer[][]} matrix 3 # @return {void} Do not return anything, modify matrix in-place instead. 4 def setZeroes(self, matrix): 5 m = len(matrix) 6 if m == 0: 7 return 8 n = len(matrix[0]) 9 10 row_zero = False 11 for i in range(m): 12 if matrix[i][0] == 0: 13 row_zero = True 14 col_zero = False 15 for j in range(n): 16 if matrix[0][j] == 0: 17 col_zero = True 18 19 for i in range(1, m): 20 for j in range(1, n): 21 if matrix[i][j] == 0: 22 matrix[i][0] = 0 23 matrix[0][j] = 0 24 25 for i in range(1, m): 26 if matrix[i][0] == 0: 27 for j in range(1, n): 28 matrix[i][j] = 0 29 30 for j in range(1, n): 31 if matrix[0][j] == 0: 32 for i in range(1, m): 33 matrix[i][j] = 0 34 35 if col_zero: 36 for j in range(n): 37 matrix[0][j] = 0 38 if row_zero: 39 for i in range(m): 40 matrix[i][0] = 0 "},{"id":68,"href":"/tech-interview-prep/problems/spiral-matrix/","title":"Spiral matrix","section":"All Problems","content":" Levels:\u0026ensp;level-2 Data structures:\u0026ensp;array Practice Link: LeetCode\nDescription:\nGiven a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order. Example 1:\n1Input: 2[ 3 [ 1, 2, 3 ], 4 [ 4, 5, 6 ], 5 [ 7, 8, 9 ] 6] 7Output: [1,2,3,6,9,8,7,4,5]Example 2:\n1Input: 2[ 3 [1, 2, 3, 4], 4 [5, 6, 7, 8], 5 [9,10,11,12] 6] 7Output: [1,2,3,4,8,12,11,10,9,5,6,7]Python Solution:\n1def spiralOrder(self, matrix): 2 res = [] 3 while matrix: 4 res.extend(matrix.pop(0)) # left to right 5 if matrix and matrix[0]: # top to dwon 6 for row in matrix: 7 res.append(row.pop()) 8 if matrix: # right to left 9 res.extend(matrix.pop()[::-1]) 10 if matrix and matrix[0]: # bottom to up 11 for row in matrix[::-1]: 12 res.append(row.pop(0)) 13 return res "},{"id":69,"href":"/tech-interview-prep/problems/subtree-of-another-tree/","title":"Subtree of another tree","section":"All Problems","content":" Levels:\u0026ensp;level-3 Data structures:\u0026ensp;tree Practice Link: LeetCode\nDescription:\nGiven two non-empty binary trees s and t, check whether tree t has exactly the same structure and node values with a subtree of s. A subtree of s is a tree consists of a node in s and all of this node\u0026rsquo;s descendants. The tree s could also be considered as a subtree of itself. Example 1:\n1 2Given tree s: 3 4 3 5 / \\ 6 4 5 7 / \\ 8 1 2 9 10Given tree t: 11 4 12 / \\ 13 1 2 14 15 Output: trueExample 2:\n1Given tree s: 2 3 3 4 / \\ 5 4 5 6 / \\ 7 1 2 8 / 9 0 10 11Given tree t: 12 4 13 / \\ 14 1 2 15 16Output: falsePython Solution:\n1class TreeNode(object): 2 def __init__(self, x): 3 self.val = x 4 self.left = None 5 self.right = None 6 7 8class Solution(object): 9 def isSubtree(self, s, t): 10 \u0026#34;\u0026#34;\u0026#34; 11 :type s: TreeNode 12 :type t: TreeNode 13 :rtype: bool 14 \u0026#34;\u0026#34;\u0026#34; 15 def convert(p): 16 return \u0026#34;^\u0026#34; + str(p.val) + \u0026#34;#\u0026#34; + convert(p.left) + convert( 17 p.right) if p else \u0026#34;$\u0026#34; 18 19 return convert(t) in convert(s) "},{"id":70,"href":"/tech-interview-prep/problems/sum-of-two-integers/","title":"Sum of two integers","section":"All Problems","content":" Levels:\u0026ensp;level-1 Data structures:\u0026ensp;bits Practice Link: LeetCode\nDescription:\nCalculate the sum of two integers a and b, but you are not allowed to use the operator + and -. Example 1:\n1Input: a = 1, b = 2 2Output: 3Python Solution:\n1# Add without using arithmetic operator 2def Add(x, y): 3 4 # Iterate till there is no carry 5 while (y != 0): 6 7 # carry now contains common 8 # set bits of x and y 9 carry = x \u0026amp; y 10 11 # Sum of bits of x and y where at 12 # least one of the bits is not set 13 x = x ^ y 14 15 # Carry is shifted by one so that 16 # adding it to x gives the required sum 17 y = carry \u0026lt;\u0026lt; 1 18 19 return x 20 21 22print(Add(15, 32)) "},{"id":71,"href":"/tech-interview-prep/problems/three-sum/","title":"Three sum","section":"All Problems","content":" Levels:\u0026ensp;level-2 Data structures:\u0026ensp;array,\u0026ensp;hash-table Practice Link: LeetCode\nDescription:\nGiven an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Note:\nThe solution set must not contain duplicate triplets. Python Solution:\n1class Solution(object): 2 def threeSum(self, nums): 3 \u0026#34;\u0026#34;\u0026#34; 4 :type nums: List[int] 5 :rtype: List[List[int]] 6 \u0026#34;\u0026#34;\u0026#34; 7 if not nums: 8 return [] 9 res = [] 10 nums.sort() 11 for i in range(len(nums) - 2): 12 # adjacent duplicate elements would cause duplicate triplets 13 if i \u0026gt; 0 and nums[i] == nums[i - 1]: 14 continue 15 l, r = i + 1, len(nums) - 1 16 while l \u0026lt; r: 17 s = nums[i] + nums[l] + nums[r] 18 if s \u0026lt; 0: 19 l += 1 20 elif s \u0026gt; 0: 21 r -= 1 22 else: 23 res.append((nums[i], nums[l], nums[r])) 24 # adjacent duplicate elements would cause duplicate triplets 25 # Increment left and right until duplicates are eliminated 26 while l \u0026lt; r and nums[l] == nums[l + 1]: 27 l += 1 28 while l \u0026lt; r and nums[r] == nums[r - 1]: 29 r -= 1 30 l += 1 31 r -= 1 32 return res 33 34 35in_arrs = [ 36 [-1, 0, 1, 2, -1, -4], 37 [1], 38 [], 39 None, 40] 41 42exp_out = [ 43 set([ 44 (-1, 0, 1), 45 (-1, -1, 2), 46 ]), 47 set([]), 48 set([]), 49 set([]), 50] 51 52if __name__ == \u0026#34;__main__\u0026#34;: 53 54 sol = Solution() 55 for idx, nin in enumerate(in_arrs): 56 resout = sol.threeSum(nin) 57 resout = set(map(tuple, resout)) 58 di = resout.symmetric_difference(exp_out[idx]) 59 print(resout, di, False if di else True) "},{"id":72,"href":"/tech-interview-prep/problems/top-k-frequent-elements/","title":"Top k frequent elements","section":"All Problems","content":" Levels:\u0026ensp;level-3 Data structures:\u0026ensp;heap,\u0026ensp;hash-table Description:\nGiven a non-empty array of integers, return the k most frequent elements. Example 1:\n1Input: nums = [1,1,1,2,2,3], k = 2 2Output: [1,2]Example 2:\n1Input: nums = [1], k = 1 2Output: [1]Note:\nYou may assume k is always valid, 1 ≤ k ≤ number of unique elements. Your algorithm\u0026rsquo;s time complexity must be better than O(n log n), where n is the array\u0026rsquo;s size. Python Solution:\n1import collections 2import heapq 3 4 5class Solution(object): 6 def topKFrequent(self, nums, k): 7 \u0026#34;\u0026#34;\u0026#34; 8 :type nums: List[int] 9 :type k: int 10 :rtype: List[int] 11 \u0026#34;\u0026#34;\u0026#34; 12 count = collections.Counter(nums) 13 return heapq.nlargest(k, list(count.keys()), key=count.get) "},{"id":73,"href":"/tech-interview-prep/problems/two-sum/","title":"Two sum","section":"All Problems","content":" Levels:\u0026ensp;level-0 Data structures:\u0026ensp;array,\u0026ensp;hash-table Practice Link: LeetCode\nDescription:\nGiven an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Python Solution:\n1class Solution1(object): 2 def twoSum(self, nums, target): 3 \u0026#34;\u0026#34;\u0026#34; 4 :type nums: List[int] 5 :type target: int 6 :rtype: List[int] 7 nlog(n) complexity using sorting. 8 \u0026#34;\u0026#34;\u0026#34; 9 nums.sort() 10 l = len(nums) 11 start = 0 12 end = l - 1 13 while start \u0026lt; end: 14 s = nums[start] + nums[end] 15 if s == target: 16 return [start, end] 17 if s \u0026gt; target: 18 end -= 1 19 continue 20 start += 1 21 return [] 22 23 24class Solution2(object): 25 def twoSum(self, nums, target): 26 \u0026#34;\u0026#34;\u0026#34; 27 :type nums: List[int] 28 :type target: int 29 :rtype: List[int] 30 O(n) complexity using hashmap. 31 \u0026#34;\u0026#34;\u0026#34; 32 m = {} 33 for idx, num in enumerate(nums): 34 complement = target - num 35 if complement in m: 36 return [idx, m[complement]] 37 m[num] = idx 38 return [] 39 40 41if __name__ == \u0026#34;__main__\u0026#34;: 42 nin = [2, 1, 2, 1, 0, 1, 2] 43 tin = 3 44 #p = [3,3,5,0,0,3,1,4] 45 sol = Solution2() 46 r = sol.twoSum(nin, tin) 47 print(r) "},{"id":74,"href":"/tech-interview-prep/problems/unique-paths/","title":"Unique paths","section":"All Problems","content":" Levels:\u0026ensp;level-4 Data structures:\u0026ensp;array Algorithms:\u0026ensp;dynamic-programming Practice Link: LeetCode\nDescription:\nA robot is located at the top-left corner of a m x n grid (marked \u0026lsquo;Start\u0026rsquo; in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked \u0026lsquo;Finish\u0026rsquo; in the diagram below). How many possible unique paths are there? Example 1:\n1Input: m = 3, n = 2 2Output: 3 3Explanation: 4From the top-left corner, there are a total of 3 ways to reach the bottom-right corner: 51. Right -\u0026gt; Right -\u0026gt; Down 62. Right -\u0026gt; Down -\u0026gt; Right 73. Down -\u0026gt; Right -\u0026gt; RightExample 2:\n1Input: m = 7, n = 3 2Output: 28Constraints:\n1 \u0026lt;= m, n \u0026lt;= 100 It\u0026rsquo;s guaranteed that the answer will be less than or equal to 2 * 10 ^ 9. Python Solution:\n1class Solution: 2 # @return an integer 3 def uniquePaths(self, m, n): 4 aux = [[1 for x in range(n)] for x in range(m)] 5 for i in range(1, m): 6 for j in range(1, n): 7 aux[i][j] = aux[i][j - 1] + aux[i - 1][j] 8 return aux[-1][-1] "},{"id":75,"href":"/tech-interview-prep/problems/valid-anagram/","title":"Valid anagram","section":"All Problems","content":" Levels:\u0026ensp;level-1 Data structures:\u0026ensp;string,\u0026ensp;hash-table Practice Link: LeetCode\nDescription:\nGiven two strings s and t, write a function to determine if t is an anagram of s. Example 1:\n1Input: s = \u0026#34;anagram\u0026#34;, t = \u0026#34;nagaram\u0026#34; 2Output: trueExample 2:\n1Input: s = \u0026#34;rat\u0026#34;, t = \u0026#34;car\u0026#34; 2Output: falseNote:\nYou may assume the string contains only lowercase alphabets. Follow up:\nWhat if the inputs contain unicode characters? How would you adapt your solution to such case? Thinking:\nThis can be solved either by Sorting or hashing. Python Solution:\n1import collections 2 3 4# Sorting solution 5def isAnagram(self, s, t): 6 if len(s) != len(t): 7 return False 8 return sorted(s) == sorted(t) 9 10 11# One liner with using counter 12def isAnagramCounter(self, s, t): 13 return collections.Counter(s) == collections.Counter(t) 14 15 16# using dicts 17def isAnagramDict(self, s, t): 18 dic1, dic2 = [0] * 26, [0] * 26 19 for item in s: 20 dic1[ord(item) - ord(\u0026#39;a\u0026#39;)] += 1 21 for item in t: 22 dic2[ord(item) - ord(\u0026#39;a\u0026#39;)] += 1 23 return dic1 == dic2 "},{"id":76,"href":"/tech-interview-prep/problems/valid-palindrome/","title":"Valid palindrome","section":"All Problems","content":" Levels:\u0026ensp;level-2 Data structures:\u0026ensp;string Practice Link: LeetCode\nDescription:\nGiven a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases. Example 1:\n1Input: \u0026#34;A man, a plan, a canal: Panama\u0026#34; 2Output: trueExample 2:\n1Input: \u0026#34;race a car\u0026#34; 2Output: falseNote:\nFor the purpose of this problem, we define empty string as valid palindrome. Python Solution:\n1class Solution(object): 2 def isPalindrome(self, s): 3 \u0026#34;\u0026#34;\u0026#34; 4 :type s: str 5 :rtype: bool 6 \u0026#34;\u0026#34;\u0026#34; 7 8 l, r = 0, len(s) - 1 9 while l \u0026lt; r: 10 while l \u0026lt; r and not s[l].isalnum(): 11 l += 1 12 while l \u0026lt; r and not s[r].isalnum(): 13 r -= 1 14 if s[l].lower() != s[r].lower(): 15 return False 16 l += 1 17 r -= 1 18 return True 19 20 # Use pythonic inbuilt functions 21 def isPalindromeInbuilt(self, s): 22 s = \u0026#39;\u0026#39;.join(e for e in s if e.isalnum()).lower() 23 return s == s[::-1] "},{"id":77,"href":"/tech-interview-prep/problems/valid-parentheses/","title":"Valid parentheses","section":"All Problems","content":" Levels:\u0026ensp;level-1 Data structures:\u0026ensp;string,\u0026ensp;stack Practice Link: LeetCode\nDescription:\nGiven a string containing just the characters \u0026lsquo;(\u0026rsquo;, \u0026lsquo;)\u0026rsquo;, \u0026lsquo;{\u0026rsquo;, \u0026lsquo;}\u0026rsquo;, \u0026lsquo;[\u0026rsquo; and \u0026lsquo;]\u0026rsquo;, determine if the input string is valid. An input string is valid if: Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Example 1:\n1Input: \u0026#34;()[]{}\u0026#34; 2Output: trueExample 2:\n1# Input: \u0026#34;([)]\u0026#34; 2# Output: falseNote:\nAn empty string is also considered valid. Python Solution:\n1class Solution(object): 2 def isValid(self, s): 3 \u0026#34;\u0026#34;\u0026#34; 4 :type s: str 5 :rtype: bool 6 \u0026#34;\u0026#34;\u0026#34; 7 8 # The stack to keep track of opening brackets. 9 stack = [] 10 11 # Hash map for keeping track of mappings. This keeps the code very clean. 12 # Also makes adding more types of parenthesis easier 13 mapping = {\u0026#34;)\u0026#34;: \u0026#34;(\u0026#34;, \u0026#34;}\u0026#34;: \u0026#34;{\u0026#34;, \u0026#34;]\u0026#34;: \u0026#34;[\u0026#34;} 14 15 # For every bracket in the expression. 16 for char in s: 17 18 # If the character is an closing bracket 19 if char in mapping: 20 21 # Pop the topmost element from the stack, if it is non empty 22 # Otherwise assign a dummy value of \u0026#39;#\u0026#39; to the top_element variable 23 top_element = stack.pop() if stack else \u0026#39;#\u0026#39; 24 25 # The mapping for the opening bracket in our hash and the top 26 # element of the stack don\u0026#39;t match, return False 27 if mapping[char] != top_element: 28 return False 29 else: 30 # We have an opening bracket, simply push it onto the stack. 31 stack.append(char) 32 33 # In the end, if the stack is empty, then we have a valid expression. 34 # The stack won\u0026#39;t be empty for cases like ((() 35 return not stack 36 "},{"id":78,"href":"/tech-interview-prep/problems/validate-binary-search-tree/","title":"Validate a binary search tree","section":"All Problems","content":" Levels:\u0026ensp;level-2 Data structures:\u0026ensp;tree Algorithms:\u0026ensp;dfs Practice Link: LeetCode\nDescription:\nGiven a binary tree, determine if it is a valid binary search tree (BST). Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than the node\u0026rsquo;s key. The right subtree of a node contains only nodes with keys greater than the node\u0026rsquo;s key. Both the left and right subtrees must also be binary search trees. Example 1:\n1 2 2 / \\ 3 1 3 4 5Input: [2,1,3] 6Output: trueExample 2:\n1 5 2 / \\ 3 1 4 4 / \\ 5 3 6 6 7Input: [5,1,4,null,null,3,6] 8Output: false 9Explanation: The root node\u0026#39;s value is 5 but its right child\u0026#39;s value is 4.Python Solution:\n1# Definition for a binary tree node. 2class TreeNode(object): 3 def __init__(self, x): 4 self.val = x 5 self.left = None 6 self.right = None 7 8 9class Solution: 10 # Recursive solution 11 def isValidBST(self, root): 12 \u0026#34;\u0026#34;\u0026#34; 13 :type root: TreeNode 14 :rtype: bool 15 \u0026#34;\u0026#34;\u0026#34; 16 def helper(node, lower=float(\u0026#39;-inf\u0026#39;), upper=float(\u0026#39;inf\u0026#39;)): 17 if not node: 18 return True 19 20 val = node.val 21 if val \u0026lt;= lower or val \u0026gt;= upper: 22 return False 23 24 if not helper(node.right, val, upper): 25 return False 26 if not helper(node.left, lower, val): 27 return False 28 return True 29 30 return helper(root) 31 32 # Use inorder traversal 33 def isValidBSTInorder(self, root): 34 \u0026#34;\u0026#34;\u0026#34; 35 :type root: TreeNode 36 :rtype: bool 37 \u0026#34;\u0026#34;\u0026#34; 38 stack, inorder = [], float(\u0026#39;-inf\u0026#39;) 39 40 while stack or root: 41 while root: 42 stack.append(root) 43 root = root.left 44 root = stack.pop() 45 # If next element in inorder traversal 46 # is smaller than the previous one 47 # that\u0026#39;s not BST. 48 if root.val \u0026lt;= inorder: 49 return False 50 inorder = root.val 51 root = root.right 52 53 return True "},{"id":79,"href":"/tech-interview-prep/problems/word-break/","title":"Word break","section":"All Problems","content":" Levels:\u0026ensp;level-4 Data structures:\u0026ensp;string Algorithms:\u0026ensp;dynamic-programming Practice Link: LeetCode\nDescription:\nGiven a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words. Example 1:\n1Input: s = \u0026#34;leetcode\u0026#34;, wordDict = [\u0026#34;leet\u0026#34;, \u0026#34;code\u0026#34;] 2Output: true 3Explanation: Return true because \u0026#34;leetcode\u0026#34; can be segmented as \u0026#34;leet code\u0026#34;.Example 2:\n1Input: s = \u0026#34;applepenapple\u0026#34;, wordDict = [\u0026#34;apple\u0026#34;, \u0026#34;pen\u0026#34;] 2Output: true 3Explanation: Return true because \u0026#34;applepenapple\u0026#34; can be segmented as \u0026#34;apple pen apple\u0026#34;. 4 Note that you are allowed to reuse a dictionary word.Example 3:\n1Input: s = \u0026#34;catsandog\u0026#34;, wordDict = [\u0026#34;cats\u0026#34;, \u0026#34;dog\u0026#34;, \u0026#34;sand\u0026#34;, \u0026#34;and\u0026#34;, \u0026#34;cat\u0026#34;] 2Output: falseNote:\nThe same word in the dictionary may be reused multiple times in the segmentation. You may assume the dictionary does not contain duplicate words. Python Solution:\n1class Solution(object): 2 def wordBreak(self, s, wordDict): 3 \u0026#34;\u0026#34;\u0026#34; 4 :type s: str 5 :type wordDict: Set[str] 6 :rtype: bool 7 \u0026#34;\u0026#34;\u0026#34; 8 # dp[i] means s[:i+1] can be segmented into words in the wordDicts 9 dp = [False] * (len(s) + 1) 10 dp[0] = True 11 for i in range(len(s)): 12 if dp[i]: 13 for j in range(i, len(s)): 14 if s[i:j + 1] in wordDict: 15 dp[j + 1] = True 16 17 return dp[-1] "},{"id":80,"href":"/tech-interview-prep/problems/word-search/","title":"Word search","section":"All Problems","content":" Levels:\u0026ensp;level-4 Data structures:\u0026ensp;array Patterns:\u0026ensp;backtracking Practice Link: LeetCode\nDescription:\nGiven a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where \u0026ldquo;adjacent\u0026rdquo; cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. Example:\n1board = 2[ 3 [\u0026#39;A\u0026#39;,\u0026#39;B\u0026#39;,\u0026#39;C\u0026#39;,\u0026#39;E\u0026#39;], 4 [\u0026#39;S\u0026#39;,\u0026#39;F\u0026#39;,\u0026#39;C\u0026#39;,\u0026#39;S\u0026#39;], 5 [\u0026#39;A\u0026#39;,\u0026#39;D\u0026#39;,\u0026#39;E\u0026#39;,\u0026#39;E\u0026#39;] 6] 7 8Given word = \u0026#34;ABCCED\u0026#34;, return true. 9Given word = \u0026#34;SEE\u0026#34;, return true. 10Given word = \u0026#34;ABCB\u0026#34;, return false.Constraints:\nBoard and word consists only of lowercase and uppercase English letters. 1 \u0026lt;= board.length \u0026lt;= 200 1 \u0026lt;= board[i].length \u0026lt;= 200 1 \u0026lt;= word.length \u0026lt;= 10^3 Python Solution:\n1class Solution(object): 2 def exist(self, board, word): 3 \u0026#34;\u0026#34;\u0026#34; 4 :type board: List[List[str]] 5 :type word: str 6 :rtype: bool 7 \u0026#34;\u0026#34;\u0026#34; 8 if not board: 9 return False 10 for i in range(len(board)): 11 for j in range(len(board[0])): 12 if self.dfs(board, i, j, word): 13 return True 14 return False 15 16 # check whether can find word, start at (i,j) position 17 def dfs(self, board, i, j, word): 18 if len(word) == 0: # all the characters are checked 19 return True 20 if i \u0026lt; 0 or i \u0026gt;= len(board) or j \u0026lt; 0 or j \u0026gt;= len( 21 board[0]) or word[0] != board[i][j]: 22 return False 23 tmp = board[i][j] # first character is found, check the remaining part 24 board[i][j] = \u0026#34;#\u0026#34; # avoid visit agian 25 # check whether can find \u0026#34;word\u0026#34; along one direction 26 res = self.dfs(board, i+1, j, word[1:]) or self.dfs(board, i-1, j, word[1:]) \\ 27 or self.dfs(board, i, j+1, word[1:]) or self.dfs(board, i, j-1, word[1:]) 28 board[i][j] = tmp 29 return res "},{"id":81,"href":"/tech-interview-prep/problems/word-search-ii/","title":"Word search II","section":"All Problems","content":" Levels:\u0026ensp;level-5 Data structures:\u0026ensp;trie Patterns:\u0026ensp;backtracking Practice Link: LeetCode\nDescription:\nGiven a 2D board and a list of words from the dictionary, find all words in the board. Each word must be constructed from letters of sequentially adjacent cell, where \u0026ldquo;adjacent\u0026rdquo; cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word. Example:\n1Input: 2board = [ 3 [\u0026#39;o\u0026#39;,\u0026#39;a\u0026#39;,\u0026#39;a\u0026#39;,\u0026#39;n\u0026#39;], 4 [\u0026#39;e\u0026#39;,\u0026#39;t\u0026#39;,\u0026#39;a\u0026#39;,\u0026#39;e\u0026#39;], 5 [\u0026#39;i\u0026#39;,\u0026#39;h\u0026#39;,\u0026#39;k\u0026#39;,\u0026#39;r\u0026#39;], 6 [\u0026#39;i\u0026#39;,\u0026#39;f\u0026#39;,\u0026#39;l\u0026#39;,\u0026#39;v\u0026#39;] 7] 8words = [\u0026#34;oath\u0026#34;,\u0026#34;pea\u0026#34;,\u0026#34;eat\u0026#34;,\u0026#34;rain\u0026#34;] 9 10Output: [\u0026#34;eat\u0026#34;,\u0026#34;oath\u0026#34;]Note:\nAll inputs are consist of lowercase letters a-z. The values of words are distinct. Python Solution:\n1import collections 2 3 4class TrieNode(): 5 def __init__(self): 6 self.children = collections.defaultdict(TrieNode) 7 self.isWord = False 8 9 10class Trie(): 11 def __init__(self): 12 self.root = TrieNode() 13 14 def insert(self, word): 15 node = self.root 16 for w in word: 17 node = node.children[w] 18 node.isWord = True 19 20 def search(self, word): 21 node = self.root 22 for w in word: 23 node = node.children.get(w) 24 if not node: 25 return False 26 return node.isWord 27 28 29class Solution(object): 30 def findWords(self, board, words): 31 res = [] 32 trie = Trie() 33 node = trie.root 34 for w in words: 35 trie.insert(w) 36 for i in range(len(board)): 37 for j in range(len(board[0])): 38 self.dfs(board, node, i, j, \u0026#34;\u0026#34;, res) 39 return res 40 41 def dfs(self, board, node, i, j, path, res): 42 if node.isWord: 43 res.append(path) 44 node.isWord = False 45 if i \u0026lt; 0 or i \u0026gt;= len(board) or j \u0026lt; 0 or j \u0026gt;= len(board[0]): 46 return 47 tmp = board[i][j] 48 node = node.children.get(tmp) 49 if not node: 50 return 51 board[i][j] = \u0026#34;#\u0026#34; 52 self.dfs(board, node, i + 1, j, path + tmp, res) 53 self.dfs(board, node, i - 1, j, path + tmp, res) 54 self.dfs(board, node, i, j - 1, path + tmp, res) 55 self.dfs(board, node, i, j + 1, path + tmp, res) 56 board[i][j] = tmp "}]