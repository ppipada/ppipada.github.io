[{"id":0,"href":"/tech-interview-prep/levels/problems/","title":"Problems","section":"Path: Levels","content":"Levels: Problems# Work problems in increasing difficulty.\nLevel 0 (4) Level 1 (7) Level 2 (12) Level 3 (20) Level 4 (26) Level 5 (12) Level 0 Contains duplicateInvert a binary treeMaximum depth of binary treeTwo sumLevel 1 Best time to buy and sell stockLinked list cycleNumber of 1 bitsReverse linked listSum of two integersValid anagramValid parenthesesLevel 2 Container with most waterFind minimum in rotated sorted arrayIs SubsequenceLowest common ancestor of a binary search treeMaximum subarrayMissing numberReverse bitsSame treeSpiral matrixThree sumValid palindromeValidate a binary search treeLevel 3 Binary tree level order traversalClimbing stairsClone graphCoin changeConstruct binary tree from preorder and inorder traversalGroup anagramsHouse robberKth smallest element in a BSTMaximum product subarrayMerge intervalsMinimum Remove To Make Parentheses ValidProduct of array except selfRemove n\u0026#39;th node from end of listReorder listRotate imageSearch in rotated sorted arraySet matrix zeroesSubtree of another treeTop k frequent elementsVerify Lexicographic Sort With Custom AlphabetLevel 4 Add and search word - data structure designBigram Model - Next Word PredictionCombination sum IVCounting bitsCourse scheduleDecode waysEncode and decode stringsEvaluate Precedence Expression With \u0026#43; And *House robber IIImplement trie (prefix tree)Insert Into Complete Binary Tree (Level-Order)Jump gameLongest increasing subsequenceLongest palindromic substringLongest repeating character replacementLongest substring without repeating charactersMeeting roomsMeeting rooms IINon overlapping intervalsNumber of islandsPacific-Atlantic water flowPalindromic substringsSET Card Game - Validate Set And Find SetUnique pathsWord breakWord searchLevel 5 Alien dictionaryBinary tree maximum path sumCount Distinct SubsequencesFind median from data streamGraph valid treeInsert intervalLongest consecutive sequenceMerge k sorted listsMinimum window substringNumber of connected components in an undirected graphSerialize and deserialize a binary treeWord search II "},{"id":1,"href":"/tech-interview-prep/patterns/problems/","title":"Problems","section":"Path: Patterns","content":"Patterns: Problems# Patterns cut across data structures and show up frequently in interviews.\nBacktracking (3) Bfs (1) Dynamic Programming (1) Hashing (3) Intervals (5) Mark and Sweep (2) Sliding Window (3) Two Pointers (1) Union Find (2) Backtracking Add and search word - data structure designWord searchWord search IIBfs Insert Into Complete Binary Tree (Level-Order)Dynamic Programming Count Distinct SubsequencesHashing Bigram Model - Next Word PredictionSET Card Game - Validate Set And Find SetVerify Lexicographic Sort With Custom AlphabetIntervals Insert intervalMeeting roomsMeeting rooms IIMerge intervalsNon overlapping intervalsMark and Sweep Evaluate Precedence Expression With \u0026#43; And *Minimum Remove To Make Parentheses ValidSliding Window Longest repeating character replacementLongest substring without repeating charactersMinimum window substringTwo Pointers Is SubsequenceUnion Find Longest consecutive sequenceNumber of islands "},{"id":2,"href":"/tech-interview-prep/data-structures/quick-notes/","title":"Quick Notes","section":"Path: Data Structures","content":"Data Structures: Quick Notes# Complexity summary (typical)# Many structures have good average performance but bad worst-case. Interviews often want both.\nData Structure Access Search Insert Delete Space Notes Array O(1) O(n) O(n) O(n) O(n) insert/delete in middle shifts Dynamic Array (vector/list) O(1) O(n) amort. O(1) append O(n) O(n) occasional resize Stack top O(1) O(n) O(1) O(1) O(n) LIFO Queue / Deque front/back O(1) O(n) O(1) O(1) O(n) FIFO / double-ended Singly Linked List O(n) O(n) O(1)* O(1)* O(n) *if pointer to node/prev is known Doubly Linked List O(n) O(n) O(1)* O(1)* O(n) easy delete given node Hash Table / Hash Map N/A avg O(1), worst O(n) avg O(1), worst O(n) avg O(1), worst O(n) O(n) depends on hashing + resizing BST (unbalanced) O(n) O(n) O(n) O(n) O(n) can degrade to linked list AVL / Red-Black Tree O(log n) O(log n) O(log n) O(log n) O(n) guaranteed height O(log n) B-Tree / B+Tree O(log n) O(log n) O(log n) O(log n) O(n) great for disks/DBs Binary Heap peek O(1) O(n) O(log n) O(log n) O(n) priority queue Trie O(L) O(L) O(L) O(L) large L = key length Fenwick Tree (BIT) N/A range sum O(log n) update O(log n) N/A O(n) prefix sums Segment Tree N/A query O(log n) update O(log n) N/A O(n) flexible aggregates Linked List# Linear collection of nodes; each node points to next (and possibly prev). Good for: frequent inserts/deletes when you already have a node reference, building other structures (LRU list). Bad for: random access, cache locality. Variants:\nSingly-linked: next Doubly-linked: prev, next Circular: last points to first Stack# Operations: push, pop, peek LIFO (last in, first out) Use cases: recursion simulation, DFS parentheses matching monotonic stack (next greater element, histogram) Queue / Deque# Queue: enqueue at back, dequeue at front (FIFO). Deque: insert/delete at both ends. Use cases: BFS (queue) sliding window max (deque) Tree (graph view)# A tree is an undirected, connected, acyclic graph.\nFor n nodes: exactly n-1 edges. Unique simple path between any two nodes. Binary Tree# Each node has ≤ 2 children: left/right. Common types: Full: each node has 0 or 2 children Perfect: all internal nodes have 2 children; all leaves same depth Complete: all levels filled except possibly last; last is left-packed Binary Search Tree (BST)# Invariant:\nleft subtree values ≤ node ≤ right subtree values (or strict \u0026lt; depending on definition) Operations are O(h) where h is height.\nBalanced BST: h = O(log n) Worst case: h = O(n) (sorted insertion) Balanced BSTs (AVL / Red-Black)# Guarantee O(log n) search/insert/delete. AVL: stricter balance (faster lookups, more rotations). Red-Black: looser balance (fewer rotations; widely used). Trie (Prefix Tree)# Stores strings by shared prefixes. Search/insert/delete: O(L) where L is key length. Great for: prefix queries (“startsWith”), autocomplete, dictionary word checks. Space heavy: optimize with compact tries / ternary search trees. Heap (Priority Queue)# Min-heap / max-heap Operations: peek: O(1) push: O(log n) pop: O(log n) Use cases: Dijkstra / Prim scheduling, top-k streaming median (two heaps) Hash Map (Hash Table)# Average O(1) search/insert/delete; worst O(n) (pathological collisions). Collision resolution:\nSeparate chaining (buckets are lists/trees) Open addressing (linear/quadratic probing, double hashing) Pitfalls:\nneed good hash function, load factor + resizing affects performance, iteration order usually not sorted. Fenwick Tree (Binary Indexed Tree)# Supports:\npoint update prefix sum query Both in O(log n). Common trick:\nrange sum [l..r] = prefix(r) - prefix(l-1) Suggested reading: Wiki Segment Tree# Supports range queries + point/range updates in O(log n).\nMore flexible than Fenwick (min/max/gcd, lazy propagation for range updates). Typical memory: ~4n. Suggested reading: Wiki Graph# Representations:\nAdjacency list: good for sparse graphs (O(V+E) memory) Adjacency matrix: good for dense graphs (O(V^2) memory) "},{"id":3,"href":"/tech-interview-prep/data-structures/problems/","title":"Problems","section":"Path: Data Structures","content":"Data Structures: Problems# Pick a data structure and drill problems tagged with it.\nArray (32) Bits (5) Graph (7) Hash Table (11) Heap (3) Linkedlist (5) Stack (3) String (18) Tree (12) Trie (3) Array Best time to buy and sell stockBigram Model - Next Word PredictionCombination sum IVConstruct binary tree from preorder and inorder traversalContainer with most waterContains duplicateCount Distinct SubsequencesCounting bitsFind minimum in rotated sorted arrayHouse robberHouse robber IIInsert intervalJump gameLongest consecutive sequenceLongest increasing subsequenceMaximum product subarrayMaximum subarrayMeeting roomsMeeting rooms IIMerge intervalsMissing numberNon overlapping intervalsProduct of array except selfRotate imageSearch in rotated sorted arraySET Card Game - Validate Set And Find SetSet matrix zeroesSpiral matrixThree sumTwo sumUnique pathsWord searchBits Counting bitsMissing numberNumber of 1 bitsReverse bitsSum of two integersGraph Alien dictionaryClone graphCourse scheduleGraph valid treeNumber of connected components in an undirected graphNumber of islandsPacific-Atlantic water flowHash Table Bigram Model - Next Word PredictionContains duplicateGroup anagramsLongest substring without repeating charactersMinimum window substringSET Card Game - Validate Set And Find SetThree sumTop k frequent elementsTwo sumValid anagramVerify Lexicographic Sort With Custom AlphabetHeap Find median from data streamMerge k sorted listsTop k frequent elementsLinkedlist Linked list cycleMerge k sorted listsRemove n\u0026#39;th node from end of listReorder listReverse linked listStack Evaluate Precedence Expression With \u0026#43; And *Minimum Remove To Make Parentheses ValidValid parenthesesString Bigram Model - Next Word PredictionCount Distinct SubsequencesDecode waysEncode and decode stringsEvaluate Precedence Expression With \u0026#43; And *Group anagramsIs SubsequenceLongest palindromic substringLongest repeating character replacementLongest substring without repeating charactersMinimum Remove To Make Parentheses ValidMinimum window substringPalindromic substringsValid anagramValid palindromeValid parenthesesVerify Lexicographic Sort With Custom AlphabetWord breakTree Binary tree level order traversalBinary tree maximum path sumConstruct binary tree from preorder and inorder traversalInsert Into Complete Binary Tree (Level-Order)Invert a binary treeKth smallest element in a BSTLowest common ancestor of a binary search treeMaximum depth of binary treeSame treeSerialize and deserialize a binary treeSubtree of another treeValidate a binary search treeTrie Add and search word - data structure designImplement trie (prefix tree)Word search II "},{"id":4,"href":"/tech-interview-prep/algorithms/quick-notes/","title":"Quick Notes","section":"Path: Algorithms","content":"Algorithms: Quick Notes# Bitmasks# Bitmasking performs operations at the bit level (often faster and memory-efficient).\nCommonly used for:\nsubset representation (set of small integers), DP over subsets, toggling flags, fast membership checks. Quick patterns\nIterate set bits: while s: lsb = s \u0026amp; -s; ...; s -= lsb Count bits: Python: s.bit_count() Enumerate all subsets of a mask: sub = mask; while sub: ...; sub = (sub - 1) \u0026amp; mask (also include 0 separately) Convention: k is 0-indexed from LSB (least-significant bit).\nOperation Expression Notes Test kth bit s \u0026amp; (1 \u0026lt;\u0026lt; k) non-zero means set Turn on kth bit s = (1 \u0026lt;\u0026lt; k) (common bug: don’t assign s = (1\u0026lt;\u0026lt;k)) Turn off kth bit s \u0026amp;= ~(1 \u0026lt;\u0026lt; k) clears bit Toggle kth bit s ^= (1 \u0026lt;\u0026lt; k) flips bit Multiply by 2^n s \u0026lt;\u0026lt; n beware overflow in fixed-width languages Divide by 2^n s \u0026gt;\u0026gt; n signed right shift is arithmetic in many languages Intersection s \u0026amp; t set intersection Union s | t set union Set subtraction s \u0026amp; ~t elements in s not in t Extract lowest set bit s \u0026amp; (-s) works with two’s complement Clear lowest set bit s \u0026amp;= (s - 1) removes one lowest-set bit Is power of two s \u0026gt; 0 and (s \u0026amp; (s - 1)) == 0 XOR swap (not recommended) x ^= y; y ^= x; x ^= y; use temp var for clarity Sorting# Complexity summary# Algorithm Best Average Worst Space Stable Quicksort Ω(n log n) Θ(n log n) O(n^2) O(log n) No Mergesort Ω(n log n) Θ(n log n) O(n log n) O(n) Yes Timsort (Python/Java) Ω(n) Θ(n log n) O(n log n) O(n) Yes Heapsort Ω(n log n) Θ(n log n) O(n log n) O(1) No Bubble sort Ω(n) Θ(n^2) O(n^2) O(1) Yes Insertion sort Ω(n) Θ(n^2) O(n^2) O(1) Yes Selection sort Ω(n^2) Θ(n^2) O(n^2) O(1) No Counting sort Ω(n+k) Θ(n+k) O(n+k) O(k) Yes Radix sort Ω(n·d) Θ(n·d) O(n·d) O(n+k) Yes (typical LSD) Bucket sort Ω(n+k) Θ(n+k) O(n^2) O(n+k) depends k = value range (counting/bucket), d = number of digits/passes (radix).\nQuicksort# Partition around pivot; recursively sort left/right. Average fast in practice; cache-friendly. Worst-case O(n^2) if pivots are bad (fix: random pivot / median-of-three). Stable: No Mergesort# Divide array, sort halves, merge. Predictable O(n log n) worst-case; stable. Needs extra memory O(n). Great for linked lists and external sorting (disk). Timsort# Hybrid of mergesort + insertion sort on “runs”. Excellent for partially sorted data. Used by Python (sorted, .sort) and Java (objects). Heapsort# Build heap O(n), then extract max/min n times. In-place O(1) auxiliary space. Not stable; typically slower than quicksort in practice. Counting / Radix / Bucket (when to use)# Counting sort: integers in small range [0..k). Fast and stable. Radix sort: fixed-length integers/strings; uses stable counting per digit. Bucket sort: when values are uniformly distributed; choose buckets well. Permutations# Definition: order matters. Count (distinct items): n! Count (choose r from n, order matters): nPr = n! / (n-r)! Typical interview use: generate all permutations (O(n!)), permutations with duplicates (needs sorting + skip duplicates), next permutation (greedy + reverse suffix). 1from collections import Counter 2 3 4def permutations(nums): 5 \u0026#34;\u0026#34;\u0026#34;All permutations of distinct items. O(n!).\u0026#34;\u0026#34;\u0026#34; 6 res = [] 7 used = [False] * len(nums) 8 path = [] 9 10 def dfs(): 11 if len(path) == len(nums): 12 res.append(path.copy()) 13 return 14 for i in range(len(nums)): 15 if used[i]: 16 continue 17 used[i] = True 18 path.append(nums[i]) 19 dfs() 20 path.pop() 21 used[i] = False 22 23 dfs() 24 return res 25 26 27def unique_permutations(nums): 28 \u0026#34;\u0026#34;\u0026#34;Permutations with duplicates handled. O(n!) worst-case, prunes duplicates.\u0026#34;\u0026#34;\u0026#34; 29 res = [] 30 counter = Counter(nums) 31 path = [] 32 n = len(nums) 33 34 def dfs(): 35 if len(path) == n: 36 res.append(path.copy()) 37 return 38 for x in list(counter.keys()): 39 if counter[x] == 0: 40 continue 41 counter[x] -= 1 42 path.append(x) 43 dfs() 44 path.pop() 45 counter[x] += 1 46 47 dfs() 48 return res Combinations# Definition: order does not matter. Count: nCr = n! / (r!(n-r)!) Typical interview use: generate k-combinations via backtracking, subset generation, “choose/not choose” DP patterns. 1def combinations(nums, k): 2 \u0026#34;\u0026#34;\u0026#34;All k-combinations (order doesn\u0026#39;t matter).\u0026#34;\u0026#34;\u0026#34; 3 res = [] 4 path = [] 5 6 def dfs(i): 7 if len(path) == k: 8 res.append(path.copy()) 9 return 10 if i == len(nums): 11 return 12 13 # choose 14 path.append(nums[i]) 15 dfs(i + 1) 16 path.pop() 17 18 # skip 19 dfs(i + 1) 20 21 dfs(0) 22 return res 23 24 25def combinations_1_to_n(n, k): 26 \u0026#34;\u0026#34;\u0026#34;Classic: choose k numbers from 1..n (pruning).\u0026#34;\u0026#34;\u0026#34; 27 res = [] 28 path = [] 29 30 def dfs(start): 31 if len(path) == k: 32 res.append(path.copy()) 33 return 34 # pruning: need (k-len(path)) more numbers 35 for x in range(start, n + 1): 36 if (n - x + 1) \u0026lt; (k - len(path)): 37 break 38 path.append(x) 39 dfs(x + 1) 40 path.pop() 41 42 dfs(1) 43 return res Tree Algorithms# Views of a Tree: Given a binary tree, “views” are what you see from a side/top/bottom.\nLeft view: first node at each depth (BFS level-order, pick first). Right view: last node at each depth (BFS level-order, pick last). Top view: first node encountered for each horizontal distance (HD). Bottom view: last node encountered for each horizontal distance (HD). Common implementation:\nBFS with a queue storing (node, depth, hd). Use maps: left/right: depth -\u0026gt; value top/bottom: hd -\u0026gt; value 1from collections import defaultdict 2from collections import deque 3 4 5class Node: 6 def __init__(self, val, left=None, right=None): 7 self.val = val 8 self.left = left 9 self.right = right 10 11 12def left_view(root): 13 if not root: return [] 14 q = deque([(root, 0)]) 15 first = {} 16 while q: 17 node, depth = q.popleft() 18 if depth not in first: 19 first[depth] = node.val 20 if node.left: q.append((node.left, depth + 1)) 21 if node.right: q.append((node.right, depth + 1)) 22 return [first[d] for d in sorted(first)] 23 24 25def right_view(root): 26 if not root: return [] 27 q = deque([(root, 0)]) 28 last = {} 29 while q: 30 node, depth = q.popleft() 31 last[depth] = node.val 32 if node.left: q.append((node.left, depth + 1)) 33 if node.right: q.append((node.right, depth + 1)) 34 return [last[d] for d in sorted(last)] 35 36 37def top_view(root): 38 \u0026#34;\u0026#34;\u0026#34;First node encountered at each horizontal distance (hd).\u0026#34;\u0026#34;\u0026#34; 39 if not root: return [] 40 q = deque([(root, 0)]) # node, hd 41 seen = {} 42 while q: 43 node, hd = q.popleft() 44 if hd not in seen: 45 seen[hd] = node.val 46 if node.left: q.append((node.left, hd - 1)) 47 if node.right: q.append((node.right, hd + 1)) 48 return [seen[h] for h in sorted(seen)] 49 50 51def bottom_view(root): 52 \u0026#34;\u0026#34;\u0026#34;Last node encountered at each horizontal distance (hd).\u0026#34;\u0026#34;\u0026#34; 53 if not root: return [] 54 q = deque([(root, 0)]) 55 seen = {} 56 while q: 57 node, hd = q.popleft() 58 seen[hd] = node.val 59 if node.left: q.append((node.left, hd - 1)) 60 if node.right: q.append((node.right, hd + 1)) 61 return [seen[h] for h in sorted(seen)] Dynamic Programming# Longest Common Subsequence\nProblem: given strings A, B, find the longest sequence appearing in both in order (not necessarily contiguous). Classic DP: dp[i][j] = LCS length of A[:i] and B[:j] Transition: if A[i-1] == B[j-1]: dp[i][j] = 1 + dp[i-1][j-1] else: dp[i][j] = max(dp[i-1][j], dp[i][j-1]) Time: O(n*m), Space: O(n*m) (or O(min(n,m)) for length only) 1def lcs_length(a: str, b: str) -\u0026gt; int: 2 \u0026#34;\u0026#34;\u0026#34;Length only, O(n*m) time, O(min(n,m)) space.\u0026#34;\u0026#34;\u0026#34; 3 if len(a) \u0026lt; len(b): 4 a, b = b, a # make b shorter for less memory 5 prev = [0] * (len(b) + 1) 6 for i in range(1, len(a) + 1): 7 cur = [0] * (len(b) + 1) 8 for j in range(1, len(b) + 1): 9 if a[i - 1] == b[j - 1]: 10 cur[j] = 1 + prev[j - 1] 11 else: 12 cur[j] = max(prev[j], cur[j - 1]) 13 prev = cur 14 return prev[-1] 15 16 17def lcs_string(a: str, b: str) -\u0026gt; str: 18 \u0026#34;\u0026#34;\u0026#34;Reconstruct one LCS, O(n*m) time and space.\u0026#34;\u0026#34;\u0026#34; 19 n, m = len(a), len(b) 20 dp = [[0] * (m + 1) for _ in range(n + 1)] 21 22 for i in range(1, n + 1): 23 for j in range(1, m + 1): 24 if a[i - 1] == b[j - 1]: 25 dp[i][j] = 1 + dp[i - 1][j - 1] 26 else: 27 dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) 28 29 # backtrack 30 i, j = n, m 31 out = [] 32 while i \u0026gt; 0 and j \u0026gt; 0: 33 if a[i - 1] == b[j - 1]: 34 out.append(a[i - 1]) 35 i -= 1 36 j -= 1 37 elif dp[i - 1][j] \u0026gt;= dp[i][j - 1]: 38 i -= 1 39 else: 40 j -= 1 41 42 return \u0026#34;\u0026#34;.join(reversed(out)) Graph Algorithms# Traversal: Depth First Search# Explore as far as possible before backtracking. Uses: connected components, cycle detection, topological sort, bridges/articulation points. Time: O(|V| + |E|) Traversal: Breadth First Search# Level-by-level exploration. Uses: shortest paths in unweighted graphs, bipartite check. Time: O(|V| + |E|) Topological Sort# Linear ordering such that for every edge u -\u0026gt; v, u comes before v. Two common methods: Kahn’s algorithm (in-degree + queue) DFS finishing times (reverse postorder) Time: O(|V| + |E|) If you cannot process all nodes (Kahn) ⇒ graph has a cycle. Shortest path: Dijkstra# Single-source shortest paths with non-negative edge weights. Typical implementation: adjacency list + min-heap (priority queue). Complexity: With heap: O((V+E) log V) (typical) With array: O(V^2) (dense graphs) Pitfalls: Do not use with negative weights. Use “lazy deletion” in heap: ignore outdated (dist, node) pairs. 1import heapq 2 3 4def dijkstra(n, edges, src): 5 \u0026#34;\u0026#34;\u0026#34; 6 n: number of nodes labeled [0..n-1] 7 edges: adjacency list {u: [(v, w), ...]} 8 weights must be non-negative 9 Returns: dist list 10 \u0026#34;\u0026#34;\u0026#34; 11 INF = 10**18 12 dist = [INF] * n 13 dist[src] = 0 14 pq = [(0, src)] # (dist, node) 15 16 while pq: 17 d, u = heapq.heappop(pq) 18 if d != dist[u]: 19 continue # outdated entry 20 for v, w in edges.get(u, []): 21 nd = d + w 22 if nd \u0026lt; dist[v]: 23 dist[v] = nd 24 heapq.heappush(pq, (nd, v)) 25 26 return dist Shortest path: Bellman–Ford# Handles negative weights; detects negative cycles. Time: O(|V||E|) If you can relax on V-th iteration ⇒ negative cycle reachable from source. Shortest path: Floyd–Warshall# All-pairs shortest paths. DP over intermediate nodes. Time: O(|V|^3), Space: O(|V|^2) Also used for transitive closure. Minimum Spanning Tree (MST): Prim# Greedy MST for connected, undirected weighted graph. “Grow” a tree by always adding cheapest outgoing edge. Time: O(E log V) with heap. 1# A Python program for Prims\u0026#39;s MST for 2# adjacency list representation of graph 3# Source GeeksForGeeks 4 5from collections import defaultdict 6import sys 7 8 9class Heap(): 10 def __init__(self): 11 self.array = [] 12 self.size = 0 13 self.pos = [] 14 15 def newMinHeapNode(self, v, dist): 16 minHeapNode = [v, dist] 17 return minHeapNode 18 19 # A utility function to swap two nodes of 20 # min heap. Needed for min heapify 21 def swapMinHeapNode(self, a, b): 22 t = self.array[a] 23 self.array[a] = self.array[b] 24 self.array[b] = t 25 26 # A standard function to heapify at given idx 27 # This function also updates position of nodes 28 # when they are swapped. Position is needed 29 # for decreaseKey() 30 def minHeapify(self, idx): 31 smallest = idx 32 left = 2 * idx + 1 33 right = 2 * idx + 2 34 35 if left \u0026lt; self.size and self.array[left][1] \u0026lt; self.array[smallest][1]: 36 smallest = left 37 38 if right \u0026lt; self.size and self.array[right][1] \u0026lt; self.array[smallest][1]: 39 smallest = right 40 41 # The nodes to be swapped in min heap 42 # if idx is not smallest 43 if smallest != idx: 44 45 # Swap positions 46 self.pos[self.array[smallest][0]] = idx 47 self.pos[self.array[idx][0]] = smallest 48 49 # Swap nodes 50 self.swapMinHeapNode(smallest, idx) 51 52 self.minHeapify(smallest) 53 54 # Standard function to extract minimum node from heap 55 def extractMin(self): 56 57 # Return NULL wif heap is empty 58 if self.isEmpty() == True: 59 return 60 61 # Store the root node 62 root = self.array[0] 63 64 # Replace root node with last node 65 lastNode = self.array[self.size - 1] 66 self.array[0] = lastNode 67 68 # Update position of last node 69 self.pos[lastNode[0]] = 0 70 self.pos[root[0]] = self.size - 1 71 72 # Reduce heap size and heapify root 73 self.size -= 1 74 self.minHeapify(0) 75 76 return root 77 78 def isEmpty(self): 79 return True if self.size == 0 else False 80 81 def decreaseKey(self, v, dist): 82 83 # Get the index of v in heap array 84 85 i = self.pos[v] 86 87 # Get the node and update its dist value 88 self.array[i][1] = dist 89 90 # Travel up while the complete tree is not 91 # hepified. This is a O(Logn) loop 92 while i \u0026gt; 0 and self.array[i][1] \u0026lt; self.array[(i - 1) / 2][1]: 93 94 # Swap this node with its parent 95 self.pos[self.array[i][0]] = (i - 1) / 2 96 self.pos[self.array[(i - 1) / 2][0]] = i 97 self.swapMinHeapNode(i, (i - 1) / 2) 98 99 # move to parent index 100 i = (i - 1) / 2 101 102 # A utility function to check if a given vertex 103 # \u0026#39;v\u0026#39; is in min heap or not 104 def isInMinHeap(self, v): 105 106 if self.pos[v] \u0026lt; self.size: 107 return True 108 return False 109 110 111def printArr(parent, n): 112 for i in range(1, n): 113 print(\u0026#34;% d - % d\u0026#34; % (parent[i], i)) 114 115 116class Graph(): 117 def __init__(self, V): 118 self.V = V 119 self.graph = defaultdict(list) 120 121 # Adds an edge to an undirected graph 122 def addEdge(self, src, dest, weight): 123 124 # Add an edge from src to dest. A new node is 125 # added to the adjacency list of src. The node 126 # is added at the begining. The first element of 127 # the node has the destination and the second 128 # elements has the weight 129 newNode = [dest, weight] 130 self.graph[src].insert(0, newNode) 131 132 # Since graph is undirected, add an edge from 133 # dest to src also 134 newNode = [src, weight] 135 self.graph[dest].insert(0, newNode) 136 137 # The main function that prints the Minimum 138 # Spanning Tree(MST) using the Prim\u0026#39;s Algorithm. 139 # It is a O(ELogV) function 140 def PrimMST(self): 141 # Get the number of vertices in graph 142 V = self.V 143 144 # key values used to pick minimum weight edge in cut 145 key = [] 146 147 # List to store contructed MST 148 parent = [] 149 150 # minHeap represents set E 151 minHeap = Heap() 152 153 # Initialize min heap with all vertices. Key values of all 154 # vertices (except the 0th vertex) is is initially infinite 155 for v in range(V): 156 parent.append(-1) 157 key.append(sys.maxsize) 158 minHeap.array.append(minHeap.newMinHeapNode(v, key[v])) 159 minHeap.pos.append(v) 160 161 # Make key value of 0th vertex as 0 so 162 # that it is extracted first 163 minHeap.pos[0] = 0 164 key[0] = 0 165 minHeap.decreaseKey(0, key[0]) 166 167 # Initially size of min heap is equal to V 168 minHeap.size = V 169 170 # In the following loop, min heap contains all nodes 171 # not yet added in the MST. 172 while minHeap.isEmpty() == False: 173 174 # Extract the vertex with minimum distance value 175 newHeapNode = minHeap.extractMin() 176 u = newHeapNode[0] 177 178 # Traverse through all adjacent vertices of u 179 # (the extracted vertex) and update their 180 # distance values 181 for pCrawl in self.graph[u]: 182 183 v = pCrawl[0] 184 185 # If shortest distance to v is not finalized 186 # yet, and distance to v through u is less than 187 # its previously calculated distance 188 if minHeap.isInMinHeap(v) and pCrawl[1] \u0026lt; key[v]: 189 key[v] = pCrawl[1] 190 parent[v] = u 191 192 # update distance value in min heap also 193 minHeap.decreaseKey(v, key[v]) 194 195 printArr(parent, V) 196 197 198# Driver program to test the above functions 199graph = Graph(9) 200graph.addEdge(0, 1, 4) 201graph.addEdge(0, 7, 8) 202graph.addEdge(1, 2, 8) 203graph.addEdge(1, 7, 11) 204graph.addEdge(2, 3, 7) 205graph.addEdge(2, 8, 2) 206graph.addEdge(2, 5, 4) 207graph.addEdge(3, 4, 9) 208graph.addEdge(3, 5, 14) 209graph.addEdge(4, 5, 10) 210graph.addEdge(5, 6, 2) 211graph.addEdge(6, 7, 1) 212graph.addEdge(6, 8, 6) 213graph.addEdge(7, 8, 7) 214graph.PrimMST() Minimum Spanning Tree (MST): Kruskal# Sort edges by weight; add if it doesn’t form a cycle (DSU/Union-Find). Time: O(E log E) (sorting dominates). 1# Python program for Kruskal\u0026#39;s algorithm to find 2# Minimum Spanning Tree of a given connected, 3# undirected and weighted graph. Source: GeeksForGeeks. 4 5 6#Class to represent a graph 7class Graph: 8 def __init__(self, vertices): 9 self.V = vertices #No. of vertices 10 self.graph = [] 11 12 # function to add an edge to graph 13 def addEdge(self, u, v, w): 14 self.graph.append([u, v, w]) 15 16 # A utility function to find set of an element i 17 # (uses path compression technique) 18 def find(self, parent, i): 19 if parent[i] == i: 20 return i 21 return self.find(parent, parent[i]) 22 23 # A function that does union of two sets of x and y 24 # (uses union by rank) 25 def union(self, parent, rank, x, y): 26 xroot = self.find(parent, x) 27 yroot = self.find(parent, y) 28 29 # Attach smaller rank tree under root of 30 # high rank tree (Union by Rank) 31 if rank[xroot] \u0026lt; rank[yroot]: 32 parent[xroot] = yroot 33 elif rank[xroot] \u0026gt; rank[yroot]: 34 parent[yroot] = xroot 35 36 # If ranks are same, then make one as root 37 # and increment its rank by one 38 else: 39 parent[yroot] = xroot 40 rank[xroot] += 1 41 42 # The main function to construct MST using Kruskal\u0026#39;s 43 # algorithm 44 def KruskalMST(self): 45 46 result = [] #This will store the resultant MST 47 48 i = 0 # An index variable, used for sorted edges 49 e = 0 # An index variable, used for result[] 50 51 # Step 1: Sort all the edges in non-decreasing 52 # order of their 53 # weight. If we are not allowed to change the 54 # given graph, we can create a copy of graph 55 self.graph = sorted(self.graph, key=lambda item: item[2]) 56 57 parent = [] 58 rank = [] 59 60 # Create V subsets with single elements 61 for node in range(self.V): 62 parent.append(node) 63 rank.append(0) 64 65 # Number of edges to be taken is equal to V-1 66 while e \u0026lt; self.V - 1: 67 68 # Step 2: Pick the smallest edge and increment 69 # the index for next iteration 70 u, v, w = self.graph[i] 71 i = i + 1 72 x = self.find(parent, u) 73 y = self.find(parent, v) 74 75 # If including this edge does\u0026#39;t cause cycle, 76 # include it in result and increment the index 77 # of result for next edge 78 if x != y: 79 e = e + 1 80 result.append([u, v, w]) 81 self.union(parent, rank, x, y) 82 # Else discard the edge 83 84 # print the contents of result[] to display the built MST 85 print(\u0026#34;Following are the edges in the constructed MST\u0026#34;) 86 for u, v, weight in result: 87 #print str(u) + \u0026#34; -- \u0026#34; + str(v) + \u0026#34; == \u0026#34; + str(weight) 88 print(\u0026#34;%d -- %d == %d\u0026#34; % (u, v, weight)) 89 90 91# Driver code 92g = Graph(4) 93g.addEdge(0, 1, 10) 94g.addEdge(0, 2, 6) 95g.addEdge(0, 3, 5) 96g.addEdge(1, 3, 15) 97g.addEdge(2, 3, 4) 98 99g.KruskalMST() Greedy Algorithms# Greedy algorithms pick the locally optimal option at each step.\nTypically applicable when:\nOptimal substructure Greedy choice property (local choice can be extended to global optimum) Examples:\ninterval scheduling Huffman coding MST (Prim/Kruskal) Dijkstra (greedy choice on next closest node) Probability: mapping to a larger sample space# Sometimes you’re given probabilities on a coarse sample space and must expand to a finer one.\nKey identity:\nIf coarse events partition space: A1, A2, ... And fine event is B: P(B) = Σ P(B | Ai) P(Ai) (Law of Total Probability) Mapping rule (coarse → refined outcomes):\nFor each coarse outcome Ai, assign probabilities to refined outcomes {rij} such that: P(rij) = P(Ai) * P(rij | Ai) and Σ_j P(rij | Ai) = 1 Common interview pattern:\n“Given P(even)=0.6, P(odd)=0.4, and uniform within parity, compute P(roll=2).” P(2)=P(even)*1/3=0.2 1def refine_distribution(coarse_probs, conditional_refinement): 2 \u0026#34;\u0026#34;\u0026#34; 3 coarse_probs: dict coarse_outcome -\u0026gt; P(coarse) 4 conditional_refinement: dict coarse_outcome -\u0026gt; dict refined_outcome -\u0026gt; P(refined | coarse) 5 6 Returns refined_probs: dict refined_outcome -\u0026gt; P(refined) 7 8 Requires each conditional distribution sums to ~1. 9 \u0026#34;\u0026#34;\u0026#34; 10 refined = {} 11 for coarse, p_coarse in coarse_probs.items(): 12 cond = conditional_refinement[coarse] 13 for r, p_r_given_c in cond.items(): 14 refined[r] = refined.get(r, 0.0) + p_coarse * p_r_given_c 15 return refined Piecewise functions: Tax slabs# Tax slabs are typically progressive:\nIncome is split into brackets, each taxed at its rate. Total tax is sum over brackets. Implementation pattern:\niterate brackets in ascending order, taxable amount in bracket = min(income, upper) - lower (clamped to ≥ 0), add taxable * rate. Pitfalls:\ninclusive/exclusive boundaries, handling “no upper bound” last slab, rounding rules. 1def tax_progressive(income, slabs): 2 \u0026#34;\u0026#34;\u0026#34; 3 slabs: list of (lower_inclusive, upper_exclusive_or_None, rate) 4 Example: 5 slabs = [ 6 (0, 250000, 0.0), 7 (250000, 500000, 0.05), 8 (500000, 1000000, 0.20), 9 (1000000, None, 0.30), 10 ] 11 \u0026#34;\u0026#34;\u0026#34; 12 tax = 0.0 13 for lo, hi, rate in slabs: 14 if income \u0026lt;= lo: 15 break 16 upper = income if hi is None else min(income, hi) 17 taxable = max(0.0, upper - lo) 18 tax += taxable * rate 19 if hi is not None and income \u0026lt; hi: 20 break 21 return tax Streams of Data (online algorithms)# When data arrives continuously and you can’t store everything.\nCommon tasks + standard tools\nRunning mean/variance: Welford’s algorithm (O(1) memory) Top-k / median: top-k: min-heap of size k median: two heaps (max-heap left, min-heap right) Sliding window max/min: monotonic deque Random sampling from unknown-length stream: reservoir sampling Membership (approx): Bloom filter Frequency (approx): Count-Min Sketch / Misra–Gries (heavy hitters) Key concept:\nChoose exact vs approximate depending on memory/latency constraints. 1import random 2 3 4def reservoir_sample(stream, k, rng=random): 5 \u0026#34;\u0026#34;\u0026#34; 6 Sample k items uniformly from a stream of unknown length. 7 Returns a list of size min(k, n). 8 \u0026#34;\u0026#34;\u0026#34; 9 reservoir = [] 10 for i, x in enumerate(stream, start=1): 11 if i \u0026lt;= k: 12 reservoir.append(x) 13 else: 14 j = rng.randint(1, i) 15 if j \u0026lt;= k: 16 reservoir[j - 1] = x 17 return reservoir 1import math 2 3 4class RunningStats: 5 \u0026#34;\u0026#34;\u0026#34;Welford\u0026#39;s algorithm: online mean/variance in O(1) memory.\u0026#34;\u0026#34;\u0026#34; 6 def __init__(self): 7 self.n = 0 8 self.mean = 0.0 9 self.M2 = 0.0 10 11 def add(self, x: float): 12 self.n += 1 13 delta = x - self.mean 14 self.mean += delta / self.n 15 delta2 = x - self.mean 16 self.M2 += delta * delta2 17 18 def variance(self): 19 if self.n \u0026lt; 2: 20 return 0.0 21 return self.M2 / (self.n - 1) # sample variance 22 23 def stddev(self): 24 return math.sqrt(self.variance()) 1from collections import deque 2 3 4def sliding_window_max(nums, k): 5 \u0026#34;\u0026#34;\u0026#34; 6 Monotonic deque: O(n) 7 Returns list of max of each window of size k. 8 \u0026#34;\u0026#34;\u0026#34; 9 dq = deque() # store indices, values decreasing 10 out = [] 11 for i, x in enumerate(nums): 12 while dq and dq[0] \u0026lt;= i - k: 13 dq.popleft() 14 while dq and nums[dq[-1]] \u0026lt;= x: 15 dq.pop() 16 dq.append(i) 17 if i \u0026gt;= k - 1: 18 out.append(nums[dq[0]]) 19 return out 1import heapq 2 3 4class RunningMedian: 5 \u0026#34;\u0026#34;\u0026#34; 6 Two heaps: 7 left: max-heap (store negatives) 8 right: min-heap 9 \u0026#34;\u0026#34;\u0026#34; 10 def __init__(self): 11 self.left = [] 12 self.right = [] 13 14 def add(self, x: float): 15 if not self.left or x \u0026lt;= -self.left[0]: 16 heapq.heappush(self.left, -x) 17 else: 18 heapq.heappush(self.right, x) 19 20 # rebalance 21 if len(self.left) \u0026gt; len(self.right) + 1: 22 heapq.heappush(self.right, -heapq.heappop(self.left)) 23 elif len(self.right) \u0026gt; len(self.left): 24 heapq.heappush(self.left, -heapq.heappop(self.right)) 25 26 def median(self): 27 if not self.left and not self.right: 28 return None 29 if len(self.left) == len(self.right): 30 return (-self.left[0] + self.right[0]) / 2.0 31 return -self.left[0] "},{"id":5,"href":"/tech-interview-prep/algorithms/problems/","title":"Problems","section":"Path: Algorithms","content":"Algorithms: Problems# Approach problems by core Algorithms / techniques (DP/DFS/BFS/etc.).\nBfs (5) Binary Search (4) Dfs (9) Divide and Conquer (2) Dynamic Programming (14) Greedy (1) Bfs Binary tree level order traversalClone graphCourse scheduleNumber of islandsPacific-Atlantic water flowBinary Search Find minimum in rotated sorted arrayKth smallest element in a BSTLongest increasing subsequenceSearch in rotated sorted arrayDfs Binary tree maximum path sumClone graphConstruct binary tree from preorder and inorder traversalCourse scheduleMaximum depth of binary treeNumber of islandsPacific-Atlantic water flowSame treeValidate a binary search treeDivide and Conquer Maximum subarrayMerge k sorted listsDynamic Programming Climbing stairsCoin changeCombination sum IVCounting bitsDecode waysHouse robberHouse robber IIJump gameLongest increasing subsequenceLongest palindromic substringMaximum subarrayPalindromic substringsUnique pathsWord breakGreedy Non overlapping intervals "},{"id":6,"href":"/tech-interview-prep/problems/","title":"All Problems","section":"Tech Interview Prep","content":"All Problems# This is the complete problem bank.\nBelow is the list of all problems in this section.\n"},{"id":7,"href":"/tech-interview-prep/system-design/","title":"System Design","section":"Tech Interview Prep","content":"System Design# For system design preparation, I primarily rely on:\nSystem Design Primer Grokking the System Design Interview This book focuses mostly on DS/Algo + coding interview patterns, and links out for system design.\n"},{"id":8,"href":"/tech-interview-prep/external/","title":"External References","section":"Tech Interview Prep","content":"External References# Educative: Grokking the System Design Interview System Design Primer ProgramCreek: Top algorithms for interviews Kevin Naughton Jr.: Interviews repo Leetcode implementations Big O notation cheat sheet "},{"id":9,"href":"/tech-interview-prep/problems/add-and-search-word/","title":"Add and search word - data structure design","section":"All Problems","content":"Add and search word - data structure design# Levels:\u0026ensp;level-4 Data structures:\u0026ensp;trie Patterns:\u0026ensp;backtracking Practice Link# LeetCode\nDescription# Design a data structure that supports the following two operations:\n1void addWord(word) 2bool search(word) Search(word) can search a literal word or a regular expression string containing only letters a-z or ..\nA .means it can represent any one letter.\nYou may assume that all words are consist of lowercase letters a-z.\nExample# 1addWord(\u0026#34;bad\u0026#34;) 2addWord(\u0026#34;dad\u0026#34;) 3addWord(\u0026#34;mad\u0026#34;) 4search(\u0026#34;pad\u0026#34;) -\u0026gt; false 5search(\u0026#34;bad\u0026#34;) -\u0026gt; true 6search(\u0026#34;.ad\u0026#34;) -\u0026gt; true 7search(\u0026#34;b..\u0026#34;) -\u0026gt; truePython Solution# 1import collections 2 3 4class TrieNode(): 5 def __init__(self): 6 self.children = collections.defaultdict(TrieNode) 7 self.isWord = False 8 9 10class WordDictionary(object): 11 def __init__(self): 12 \u0026#34;\u0026#34;\u0026#34; 13 Initialize your data structure here. 14 \u0026#34;\u0026#34;\u0026#34; 15 self.root = TrieNode() 16 17 def addWord(self, word): 18 \u0026#34;\u0026#34;\u0026#34; 19 Adds a word into the data structure. 20 :type word: str 21 :rtype: None 22 \u0026#34;\u0026#34;\u0026#34; 23 node = self.root 24 for w in word: 25 node = node.children[w] 26 node.isWord = True 27 28 def search(self, word): 29 \u0026#34;\u0026#34;\u0026#34; 30 Returns if the word is in the data structure. A word could contain the dot character \u0026#39;.\u0026#39; to represent any one letter. 31 :type word: str 32 :rtype: bool 33 \u0026#34;\u0026#34;\u0026#34; 34 node = self.root 35 self.res = False 36 self.dfs(node, word) 37 return self.res 38 39 def dfs(self, node, word): 40 if not word: 41 if node.isWord: 42 self.res = True 43 return 44 if word[0] == \u0026#34;.\u0026#34;: 45 for n in node.children.values(): 46 self.dfs(n, word[1:]) 47 else: 48 node = node.children.get(word[0]) 49 if not node: 50 return 51 self.dfs(node, word[1:]) 52 53 54# Your WordDictionary object will be instantiated and called as such: 55# obj = WordDictionary() 56# obj.addWord(word) 57# param_2 = obj.search(word) "},{"id":10,"href":"/tech-interview-prep/problems/alien-dictionary/","title":"Alien dictionary","section":"All Problems","content":"Alien dictionary# Levels:\u0026ensp;level-5 Data structures:\u0026ensp;graph Description# There is a new alien language which uses the latin alphabet. However, the order among letters are unknown to you. You receive a list of words from the dictionary, where words are sorted lexicographically by the rules of this new language. Derive the order of letters in this language. Note:\nYou may assume all letters are in lowercase. If the order is invalid, return an empty string. There may be multiple valid order of letters, return any one of them is fine. Examples# 1Given the following words in dictionary, 2[ 3 \u0026#34;wrt\u0026#34;, 4 \u0026#34;wrf\u0026#34;, 5 \u0026#34;er\u0026#34;, 6 \u0026#34;ett\u0026#34;, 7 \u0026#34;rftt\u0026#34; 8] 9 10The correct order is: \u0026#34;wertf\u0026#34;.1Input: 2[ 3 \u0026#34;z\u0026#34;, 4 \u0026#34;x\u0026#34; 5] 6Output: \u0026#34;zx\u0026#34;Example 3:\n1Input: 2[ 3 \u0026#34;z\u0026#34;, 4 \u0026#34;x\u0026#34;, 5 \u0026#34;z\u0026#34; 6] 7Output: \u0026#34;\u0026#34; 8Explanation: The order is invalid, so return \u0026#34;\u0026#34;.Python Solution# 1from typing import List 2from collections import defaultdict, deque 3 4 5class Solution(object): 6 def alienOrder(self, words: List[str]) -\u0026gt; str: 7 G = self.construct_graph(words) 8 visited = defaultdict(int) # 0 not visited, 1 visiting, 2 visted 9 ret = deque() 10 for u in G.keys(): 11 if visited[u] == 0: 12 if not self.topo_dfs(G, u, visited, ret): 13 return \u0026#34;\u0026#34; 14 15 return \u0026#34;\u0026#34;.join(ret) 16 17 def construct_graph(self, words): 18 G = defaultdict(list) 19 # need to initialize, consider test case [\u0026#34;z\u0026#34;, \u0026#34;z\u0026#34;] 20 for w in words: # error 21 for c in w: 22 G[c] 23 24 for i in range(len(words) - 1): # compare word_i and word_{i+1} 25 for c1, c2 in zip(words[i], words[i + 1]): 26 if c1 != c2: # lexical order 27 G[c1].append(c2) 28 break # need to break for lexical order 29 30 return G 31 32 def topo_dfs(self, G, u, visited, ret): 33 \u0026#34;\u0026#34;\u0026#34; 34 Topological sort 35 G = defaultdict(list) 36 visited = defaultdict(int) # 0 not visited, 1 visiteding, 2 visted 37 pre-condition: u is not visited (0) 38 \u0026#34;\u0026#34;\u0026#34; 39 visited[u] = 1 40 for nbr in G[u]: 41 if visited[nbr] == 1: 42 return False 43 if visited[nbr] == 0: 44 if not self.topo_dfs(G, nbr, visited, ret): 45 return False 46 47 visited[u] = 2 48 ret.appendleft(u) # visit larger first 49 return True 50 51 52if __name__ == \u0026#34;__main__\u0026#34;: 53 lst = [ 54 \u0026#34;ze\u0026#34;, \u0026#34;yf\u0026#34;, \u0026#34;xd\u0026#34;, \u0026#34;wd\u0026#34;, \u0026#34;vd\u0026#34;, \u0026#34;ua\u0026#34;, \u0026#34;tt\u0026#34;, \u0026#34;sz\u0026#34;, \u0026#34;rd\u0026#34;, \u0026#34;qd\u0026#34;, \u0026#34;pz\u0026#34;, \u0026#34;op\u0026#34;, 55 \u0026#34;nw\u0026#34;, \u0026#34;mt\u0026#34;, \u0026#34;ln\u0026#34;, \u0026#34;ko\u0026#34;, \u0026#34;jm\u0026#34;, \u0026#34;il\u0026#34;, \u0026#34;ho\u0026#34;, \u0026#34;gk\u0026#34;, \u0026#34;fa\u0026#34;, \u0026#34;ed\u0026#34;, \u0026#34;dg\u0026#34;, \u0026#34;ct\u0026#34;, 56 \u0026#34;bb\u0026#34;, \u0026#34;ba\u0026#34; 57 ] 58 assert Solution().alienOrder(lst) == \u0026#34;zyxwvutsrqponmlkjihgfedcba\u0026#34; "},{"id":11,"href":"/tech-interview-prep/problems/best-time-to-buy-and-sell-stock/","title":"Best time to buy and sell stock","section":"All Problems","content":"Best time to buy and sell stock# Levels:\u0026ensp;level-1 Data structures:\u0026ensp;array Practice Link# LeetCode\nDescription# Say you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit. Note:\nYou cannot sell a stock before you buy one. Python Solution# 1class Solution(object): 2 def maxProfit(self, prices): 3 \u0026#34;\u0026#34;\u0026#34; 4 :type prices: List[int] 5 :rtype: int 6 \u0026#34;\u0026#34;\u0026#34; 7 l = len(prices) 8 if l \u0026lt; 2: 9 return 0 10 profit = 0 11 cmin = 0 12 i = 1 13 while i \u0026lt; l: 14 if prices[i] \u0026lt; prices[cmin]: 15 cmin = i 16 newp = prices[i] - prices[cmin] 17 if newp \u0026gt; profit: 18 profit = newp 19 # print(i, cmin, profit) 20 i += 1 21 return profit 22 23 24if __name__ == \u0026#34;__main__\u0026#34;: 25 p = [2, 1, 2, 1, 0, 1, 2] 26 #p = [3,3,5,0,0,3,1,4] 27 sol = Solution() 28 r = sol.maxProfit(p) 29 print(r) "},{"id":12,"href":"/tech-interview-prep/problems/bigram-model-next-word-prediction/","title":"Bigram Model - Next Word Prediction","section":"All Problems","content":"Bigram Model - Next Word Prediction# Levels:\u0026ensp;level-4 Data structures:\u0026ensp;hash-table,\u0026ensp;string,\u0026ensp;array Patterns:\u0026ensp;hashing Practice Link# This is a standard “bigram / Markov chain” exercise (not a single canonical LeetCode). Description# Input: a list of sentences, where each sentence is a list of words/tokens. Build a model that counts which words follow a given word (a bigram frequency table). Query: given a word w, predict a next word: Option A (deterministic): return the most frequent next word Option B (probabilistic): sample a next word proportional to its observed frequency If w was never seen (or has no following word), return an empty string. Example# 1Training data: 2[ 3 [\u0026#34;I\u0026#34;, \u0026#34;am\u0026#34;, \u0026#34;sam\u0026#34;], 4 [\u0026#34;sam\u0026#34;, \u0026#34;i\u0026#34;, \u0026#34;am\u0026#34;], 5 [\u0026#34;i\u0026#34;, \u0026#34;like\u0026#34;, \u0026#34;green\u0026#34;, \u0026#34;eggs\u0026#34;, \u0026#34;and\u0026#34;, \u0026#34;ham\u0026#34;] 6] 7 8Possible: 9most_common_next(\u0026#34;i\u0026#34;) -\u0026gt; \u0026#34;am\u0026#34;Python Solution# 1from collections import Counter 2from collections import defaultdict 3import random 4from typing import DefaultDict, Dict, List, Optional 5 6BigramModel = DefaultDict[str, Counter] 7 8def train_bigrams(sentences: List[List[str]]) -\u0026gt; BigramModel: 9 \u0026#34;\u0026#34;\u0026#34; 10 Build next-word counts: 11 model[w][next_w] += 1 12 13 Time: O(total tokens) 14 Space: O(number of observed bigrams) 15 \u0026#34;\u0026#34;\u0026#34; 16 model: BigramModel = defaultdict(Counter) 17 18 for sent in sentences or []: 19 if not sent: 20 continue 21 for i in range(len(sent) - 1): 22 w, nxt = sent[i], sent[i + 1] 23 model[w][nxt] += 1 24 25 return model 26 27def most_common_next(w: str, model: BigramModel) -\u0026gt; str: 28 \u0026#34;\u0026#34;\u0026#34; 29 Return the most frequent next token after w, else \u0026#34;\u0026#34;. 30 \u0026#34;\u0026#34;\u0026#34; 31 if not w or w not in model or not model[w]: 32 return \u0026#34;\u0026#34; 33 # Counter.most_common(1) returns [(word, count)] 34 return model[w].most_common(1)[0][0] 35 36def sample_next(w: str, model: BigramModel, rng: Optional[random.Random] = None) -\u0026gt; str: 37 \u0026#34;\u0026#34;\u0026#34; 38 Sample next token proportional to observed frequencies, else \u0026#34;\u0026#34;. 39 \u0026#34;\u0026#34;\u0026#34; 40 if not w or w not in model or not model[w]: 41 return \u0026#34;\u0026#34; 42 rng = rng or random.Random() 43 44 counter = model[w] 45 total = sum(counter.values()) 46 r = rng.randrange(total) # integer in [0, total-1] 47 48 cum = 0 49 for nxt, c in counter.items(): 50 cum += c 51 if r \u0026lt; cum: 52 return nxt 53 54 return \u0026#34;\u0026#34; # defensive; shouldn\u0026#39;t happen "},{"id":13,"href":"/tech-interview-prep/problems/binary-tree-level-order-traversal/","title":"Binary tree level order traversal","section":"All Problems","content":"Binary tree level order traversal# Levels:\u0026ensp;level-3 Data structures:\u0026ensp;tree Algorithms:\u0026ensp;bfs Practice Link# LeetCode\nDescription# Given a binary tree, return the level order traversal of its nodes\u0026rsquo; values. (ie, from left to right, level by level). Example# 1Given binary tree [3,9,20,null,null,15,7], 2 3 3 4 / \\ 5 9 20 6 / \\ 7 15 7 8 9Output: 10[ 11 [3], 12 [9,20], 13 [15,7] 14]Python Solution# 1class TreeNode(object): 2 def __init__(self, x): 3 self.val = x 4 self.left = None 5 self.right = None 6 7 8class Solution(object): 9 def levelOrder(self, root): 10 \u0026#34;\u0026#34;\u0026#34; 11 :type root: TreeNode 12 :rtype: List[List[int]] 13 \u0026#34;\u0026#34;\u0026#34; 14 if not root: 15 return [] 16 ans, level = [], [root] 17 while level: 18 ans.append([node.val for node in level]) 19 temp = [] 20 for node in level: 21 temp.extend([node.left, node.right]) 22 level = [leaf for leaf in temp if leaf] 23 return ans "},{"id":14,"href":"/tech-interview-prep/problems/binary-tree-maximum-path-sum/","title":"Binary tree maximum path sum","section":"All Problems","content":"Binary tree maximum path sum# Levels:\u0026ensp;level-5 Data structures:\u0026ensp;tree Algorithms:\u0026ensp;dfs Description# Given a non-empty binary tree, find the maximum path sum. For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root. Examples# 1Input: [1,2,3] 2 3 1 4 / \\ 5 2 3 6 7Output: 61Input: [-10,9,20,null,null,15,7] 2 3 -10 4 / \\ 5 9 20 6 / \\ 7 15 7 8 9Output: 42Python Solution# 1class TreeNode(object): 2 def __init__(self, x): 3 self.val = x 4 self.left = None 5 self.right = None 6 7 8class Solution(object): 9 def maxPathSum(self, root): 10 \u0026#34;\u0026#34;\u0026#34; 11 :type root: TreeNode 12 :rtype: int 13 \u0026#34;\u0026#34;\u0026#34; 14 def maxend(node): 15 if not node: 16 return 0 17 left = maxend(node.left) 18 right = maxend(node.right) 19 self.max = max(self.max, left + node.val + right) 20 return max(node.val + max(left, right), 0) 21 22 self.max = None 23 maxend(root) 24 return self.max "},{"id":15,"href":"/tech-interview-prep/problems/climbing-stairs/","title":"Climbing stairs","section":"All Problems","content":"Climbing stairs# Levels:\u0026ensp;level-3 Algorithms:\u0026ensp;dynamic-programming Practice Link# LeetCode\nDescription# You are climbing a stair case. It takes n steps to reach to the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? Note:\nGiven n will be a positive integer. Examples# 1Input: 2 2Output: 2 3Explanation: There are two ways to climb to the top. 41. 1 step + 1 step 52. 2 steps1Input: 3 2Output: 3 3Explanation: There are three ways to climb to the top. 41. 1 step + 1 step + 1 step 52. 1 step + 2 steps 63. 2 steps + 1 stepPython Solution# 1class Solution1(object): 2 def climbStairs(self, n): 3 \u0026#34;\u0026#34;\u0026#34; 4 :type n: int 5 :rtype: int 6 \u0026#34;\u0026#34;\u0026#34; 7 if not n: 8 return 0 9 if n == 1: 10 return 1 11 f = 1 12 s = 2 13 for _ in range(3, n + 1): 14 t = f + s 15 f = s 16 s = t 17 return s 18 19 20class Solution2(object): 21 def climbStairs(self, n): 22 \u0026#34;\u0026#34;\u0026#34; 23 :type n: int 24 :rtype: int 25 \u0026#34;\u0026#34;\u0026#34; 26 if not n: 27 return 0 28 if n == 1: 29 return 1 30 dp = [0 for _ in range(n + 1)] 31 dp[1] = 1 32 dp[2] = 2 33 for i in range(3, n + 1): 34 dp[i] = dp[i - 1] + dp[i - 2] 35 return dp[n] 36 37 38tm = [ 39 (1, 1), 40 (2, 2), 41 (3, 3), 42 (0, 0), 43 (None, 0), 44] 45 46if __name__ == \u0026#34;__main__\u0026#34;: 47 48 sol1 = Solution1() 49 sol2 = Solution2() 50 51 for idx, nin in enumerate(tm): 52 resout = sol1.climbStairs(nin[0]) 53 print(nin, resout, resout == nin[1]) 54 resout = sol2.climbStairs(nin[0]) 55 print(nin, resout, resout == nin[1]) "},{"id":16,"href":"/tech-interview-prep/problems/clone-graph/","title":"Clone graph","section":"All Problems","content":"Clone graph# Levels:\u0026ensp;level-3 Data structures:\u0026ensp;graph Algorithms:\u0026ensp;dfs,\u0026ensp;bfs Description# Given a reference of a node in a connected undirected graph. Return a deep copy (clone) of the graph. Each node in the graph contains a val (int) and a list (List[Node]) of its neighbors. Test case format:\nFor simplicity sake, each node\u0026rsquo;s value is the same as the node\u0026rsquo;s index (1-indexed). For example, the first node with val = 1, the second node with val = 2, and so on. The graph is represented in the test case using an adjacency list. Adjacency list is a collection of unordered lists used to represent a finite graph. Each list describes the set of neighbors of a node in the graph. The given node will always be the first node with val = 1. You must return the copy of the given node as a reference to the cloned graph. Constraints:\n1 \u0026lt;= Node.val \u0026lt;= 100 Node.val is unique for each node. Number of Nodes will not exceed 100. There is no repeated edges and no self-loops in the graph. The Graph is connected and all nodes can be visited starting from the given node. Examples# 1Input: adjList = [[2,4],[1,3],[2,4],[1,3]] 2Output: [[2,4],[1,3],[2,4],[1,3]] 3Explanation: There are 4 nodes in the graph. 41st node (val = 1)\u0026#39;s neighbors are 2nd node (val = 2) and 4th node (val = 4). 52nd node (val = 2)\u0026#39;s neighbors are 1st node (val = 1) and 3rd node (val = 3). 63rd node (val = 3)\u0026#39;s neighbors are 2nd node (val = 2) and 4th node (val = 4). 74th node (val = 4)\u0026#39;s neighbors are 1st node (val = 1) and 3rd node (val = 3).1Input: adjList = [[]] 2Output: [[]] 3Explanation: Note that the input contains one empty list. The graph consists of only one node with val = 1 and it does not have any neighbors.Python Solution# 1class Node: 2 def __init__(self, val=0, neighbors=[]): 3 self.val = val 4 self.neighbors = neighbors 5 6 7class Solution: 8 def cloneGraph(self, node: \u0026#39;Node\u0026#39;) -\u0026gt; \u0026#39;Node\u0026#39;: 9 dic = {} 10 11 def dfs(node): 12 if not node: 13 return 14 else: 15 node_copy = Node(node.val, []) 16 dic[node] = node_copy 17 for nei in node.neighbors: 18 if nei in dic: 19 node_copy.neighbors.append(dic[nei]) 20 else: 21 node_copy.neighbors.append(dfs(nei)) 22 return node_copy 23 24 return dfs(node) "},{"id":17,"href":"/tech-interview-prep/problems/coin-change/","title":"Coin change","section":"All Problems","content":"Coin change# Levels:\u0026ensp;level-3 Algorithms:\u0026ensp;dynamic-programming Practice Link# LeetCode\nDescription# You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1. Note:\nYou may assume that you have an infinite number of each kind of coin. Examples# 1Input: coins = [1, 2, 5], amount = 11 2Output: 3 3Explanation: 11 = 5 + 5 + 11Input: coins = [2], amount = 3 2Output: -1Python Solution# 1class Solution(object): 2 def coinChange(self, coins, amount): 3 \u0026#34;\u0026#34;\u0026#34; 4 :type coins: List[int] 5 :type amount: int 6 :rtype: int 7 \u0026#34;\u0026#34;\u0026#34; 8 # Start with a dp array of size amount + 1. 9 # Use amount + 1 as the \u0026#34;max\u0026#34; value. 10 rs = [amount + 1] * (amount + 1) 11 # No coin needed for amount zero 12 rs[0] = 0 13 # Calculate min counts needed for each target upto amount. 14 for i in range(1, amount + 1): 15 # Check for each available denomination 16 for c in coins: 17 if i \u0026gt;= c: 18 # Coins needed for target amount i is 19 # the min of (current calculated min number of coins) 20 # and (coins needed for i - c target amount + 1) 21 rs[i] = min(rs[i], rs[i - c] + 1) 22 23 if rs[amount] == amount + 1: 24 # return -1 if calculated n coins is the \u0026#34;max\u0026#34; value set initially. 25 return -1 26 return rs[amount] 27 28 29tm = [ 30 ([1, 2, 5], 11, 3), 31 ([2], 3, -1), 32 ([], 11, -1), 33] 34 35if __name__ == \u0026#34;__main__\u0026#34;: 36 37 sol1 = Solution() 38 39 for idx, nin in enumerate(tm): 40 resout = sol1.coinChange(nin[0], nin[1]) 41 print(nin, resout, resout == nin[-1]) "},{"id":18,"href":"/tech-interview-prep/problems/combination-sum-iv/","title":"Combination sum IV","section":"All Problems","content":"Combination sum IV# Levels:\u0026ensp;level-4 Data structures:\u0026ensp;array Algorithms:\u0026ensp;dynamic-programming Practice Link# LeetCode\nDescription# Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target. Example# 1nums = [1, 2, 3] 2target = 4 3 4The possible combination ways are: 5(1, 1, 1, 1) 6(1, 1, 2) 7(1, 2, 1) 8(1, 3) 9(2, 1, 1) 10(2, 2) 11(3, 1) 12 13Note that different sequences are counted as different combinations. 14 15Therefore the output is 7.Follow up# What if negative numbers are allowed in the given array? How does it change the problem? What limitation we need to add to the question to allow negative numbers? Python Solution# 1class Solution(object): 2 def combinationSum4(self, nums, target): 3 nums, combs = sorted(nums), [1] + [0] * (target) 4 for i in range(target + 1): 5 for num in nums: 6 if num \u0026gt; i: break 7 if num == i: combs[i] += 1 8 if num \u0026lt; i: combs[i] += combs[i - num] 9 return combs[target] "},{"id":19,"href":"/tech-interview-prep/problems/construct-binary-tree-from-preorder-and-inorder-traversal/","title":"Construct binary tree from preorder and inorder traversal","section":"All Problems","content":"Construct binary tree from preorder and inorder traversal# Levels:\u0026ensp;level-3 Data structures:\u0026ensp;tree,\u0026ensp;array Algorithms:\u0026ensp;dfs Practice Link# LeetCode\nDescription# Given preorder and inorder traversal of a tree, construct the binary tree. Note:\nYou may assume that duplicates do not exist in the tree.\nExample# 1preorder = [3,9,20,15,7] 2inorder = [9,3,15,20,7] 3 4Return the following binary tree: 5 6 3 7 / \\ 8 9 20 9 / \\ 10 15 7Python Solution# 1class TreeNode(object): 2 def __init__(self, x): 3 self.val = x 4 self.left = None 5 self.right = None 6 7 8class Solution(object): 9 def buildTree(self, preorder, inorder): 10 \u0026#34;\u0026#34;\u0026#34; 11 :type preorder: List[int] 12 :type inorder: List[int] 13 :rtype: TreeNode 14 \u0026#34;\u0026#34;\u0026#34; 15 if inorder: 16 ind = inorder.index(preorder.pop(0)) 17 root = TreeNode(inorder[ind]) 18 root.left = self.buildTree(preorder, inorder[0:ind]) 19 root.right = self.buildTree(preorder, inorder[ind + 1:]) 20 return root "},{"id":20,"href":"/tech-interview-prep/problems/container-with-most-water/","title":"Container with most water","section":"All Problems","content":"Container with most water# Levels:\u0026ensp;level-2 Data structures:\u0026ensp;array Practice Link# LeetCode\nDescription# Given n non-negative integers a1, a2, ..., an, where each represents a point at coordinate (i, ai), n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. Note:\nYou may not slant the container and n is at least 2. Example# 1Input: [1,8,6,2,5,4,8,3,7] 2Output: 49Python Solution# 1class Solution(object): 2 def maxArea(self, height): 3 \u0026#34;\u0026#34;\u0026#34; 4 :type height: List[int] 5 :rtype: int 6 \u0026#34;\u0026#34;\u0026#34; 7 if not height: 8 return -1 9 l = 0 10 h = len(height) - 1 11 if h \u0026lt; 1: 12 return -1 13 maxarea = -1 14 sidel = h 15 while l \u0026lt; h: 16 if height[l] \u0026lt; height[h]: 17 sidew = height[l] 18 l += 1 19 else: 20 sidew = height[h] 21 h -= 1 22 a = sidew * sidel 23 if a \u0026gt; maxarea: 24 maxarea = a 25 sidel -= 1 26 return maxarea 27 28 29in_arrs = [ 30 [1, 8, 6, 2, 5, 4, 8, 3, 7], 31 [1], 32 [], 33 None, 34] 35 36exp_out = [ 37 49, 38 -1, 39 -1, 40 -1, 41] 42 43if __name__ == \u0026#34;__main__\u0026#34;: 44 45 sol = Solution() 46 for idx, nin in enumerate(in_arrs): 47 resout = sol.maxArea(nin) 48 print(nin, resout, exp_out[idx], resout == exp_out[idx]) "},{"id":21,"href":"/tech-interview-prep/problems/contains-duplicate/","title":"Contains duplicate","section":"All Problems","content":"Contains duplicate# Levels:\u0026ensp;level-0 Data structures:\u0026ensp;array,\u0026ensp;hash-table Practice Link# LeetCode\nDescription# Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct. Example# 1Input: [1,2,3,1] 2Output: truePython Solution# 1class Solution(object): 2 def containsDuplicate(self, nums): 3 \u0026#34;\u0026#34;\u0026#34; 4 :type nums: List[int] 5 :rtype: bool 6 \u0026#34;\u0026#34;\u0026#34; 7 h = {} 8 for n in nums: 9 if n in h: 10 return True 11 h[n] = True 12 return False 13 14 15class Solution2(object): 16 def containsDuplicate(self, nums): 17 \u0026#34;\u0026#34;\u0026#34; 18 :type nums: List[int] 19 :rtype: bool 20 \u0026#34;\u0026#34;\u0026#34; 21 return True if len(set(nums)) \u0026lt; len(nums) else False 22 23 24in_arrs = [ 25 [2, 1, 2, 1, 0, 1, 2], 26 [3, 3, 5, 0, 0, 3, 1, 4], 27 [3, 5, 0, 1, 4], 28 [1, 2, 3, 1], 29 [1, 2, 3, 4], 30 [1, 1, 1, 3, 3, 4, 3, 2, 4, 2], 31] 32if __name__ == \u0026#34;__main__\u0026#34;: 33 34 sol = Solution2() 35 for nin in in_arrs: 36 r = sol.containsDuplicate(nin) 37 print(r) "},{"id":22,"href":"/tech-interview-prep/problems/count-distinct-subsequences/","title":"Count Distinct Subsequences","section":"All Problems","content":"Count Distinct Subsequences# Levels:\u0026ensp;level-5 Data structures:\u0026ensp;string,\u0026ensp;array Patterns:\u0026ensp;dynamic-programming Practice# LeetCode\nDescription# Given two strings s and t, return the number of distinct subsequences of s that equal t. A subsequence is formed by deleting zero or more characters from s without changing the order of the remaining characters. Return the count (an integer). Examples# 1getcount(\u0026#34;abab\u0026#34;, \u0026#34;ab\u0026#34;) -\u0026gt; 3 2Explanation: choose indices (0,1), (0,3), (2,3)1getcount(\u0026#34;abb\u0026#34;, \u0026#34;ab\u0026#34;) -\u0026gt; 21getcount(\u0026#34;abcd\u0026#34;, \u0026#34;\u0026#34;) -\u0026gt; 1Python Solution# 1def count_distinct_subsequences(s: str, t: str) -\u0026gt; int: 2 \u0026#34;\u0026#34;\u0026#34; 3 Count the number of distinct subsequences of s that equal t. 4 5 DP (1D optimization): 6 dp[j] = number of ways to match t[:j] using processed prefix of s 7 dp[0] = 1 (empty t matches in exactly 1 way) 8 9 For each char in s: 10 update dp backwards so we don\u0026#39;t reuse the same s-char multiple times. 11 12 Time: O(len(s) * len(t)) 13 Space: O(len(t)) 14 \u0026#34;\u0026#34;\u0026#34; 15 n, m = len(s), len(t) 16 if m == 0: 17 return 1 18 if n == 0: 19 return 0 20 21 dp = [0] * (m + 1) 22 dp[0] = 1 23 24 for ch in s: 25 for j in range(m - 1, -1, -1): 26 if ch == t[j]: 27 dp[j + 1] += dp[j] 28 29 return dp[m] "},{"id":23,"href":"/tech-interview-prep/problems/counting-bits/","title":"Counting bits","section":"All Problems","content":"Counting bits# Levels:\u0026ensp;level-4 Data structures:\u0026ensp;bits,\u0026ensp;array Algorithms:\u0026ensp;dynamic-programming Practice Link# LeetCode\nDescription# Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1\u0026rsquo;s in their binary representation and return them as an array. Examples# 1Input: 2 2Output: [0,1,1]1Input: 5 2Output: [0,1,1,2,1,2]Follow up# It is very easy to come up with a solution with run time O(n*sizeof(integer)). But can you do it in linear time O(n) /possibly in a single pass? Space complexity should be O(n). Thinking# We do not need check the input parameter, because the question has already mentioned that the number is non negative.\nHow we do this? The first idea come up with is find the pattern or rules for the result. Therefore, we can get following pattern\n1Index : 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 2num : 0 1 1 2 1 2 2 3 1 2 2 3 2 3 3 4 Do you find the pattern?\nObviously, this is overlap sub problem, and we can come up the DP solution. For now, we need find the function to implement DP.\n1dp[0] = 0; 2dp[1] = dp[0] + 1; 3dp[2] = dp[0] + 1; 4dp[3] = dp[1] +1; 5dp[4] = dp[0] + 1; 6dp[5] = dp[1] + 1; 7dp[6] = dp[2] + 1; 8dp[7] = dp[3] + 1; 9dp[8] = dp[0] + 1; This is the function we get, now we need find the other pattern for the function to get the general function.\nAfter we analyze the above function, we can get\n1dp[0] = 0; 2dp[1] = dp[1-1] + 1; 3dp[2] = dp[2-2] + 1; 4dp[3] = dp[3-2] +1; 5dp[4] = dp[4-4] + 1; 6dp[5] = dp[5-4] + 1; 7dp[6] = dp[6-4] + 1; 8dp[7] = dp[7-4] + 1; 9dp[8] = dp[8-8] + 1; Obviously, we can find the pattern for above example, so now we get the general function dp[index] = dp[index - offset] + 1;\nPython Solution# 1class Solution(object): 2 def countBits(self, num): 3 \u0026#34;\u0026#34;\u0026#34; 4 :type num: int 5 :rtype: List[int] 6 \u0026#34;\u0026#34;\u0026#34; 7 result = [0] * (num + 1) 8 offset = 1 9 for index in range(1, num + 1): 10 if (offset * 2 == index): 11 offset *= 2 12 result[index] = result[index - offset] + 1 13 return result "},{"id":24,"href":"/tech-interview-prep/problems/course-schedule/","title":"Course schedule","section":"All Problems","content":"Course schedule# Levels:\u0026ensp;level-4 Data structures:\u0026ensp;graph Algorithms:\u0026ensp;dfs,\u0026ensp;bfs Description# There are a total of numCourses courses you have to take, labeled from 0 to numCourses-1. Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1] Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses? Constraints:\nThe input prerequisites is a graph represented by a list of edges, not adjacency matrices. You may assume that there are no duplicate edges in the input prerequisites. 1 \u0026lt;= numCourses \u0026lt;= 10^5 Examples# 1Input: numCourses = 2, prerequisites = [[1,0]] 2Output: true 3Explanation: There are a total of 2 courses to take. 4 To take course 1 you should have finished course 0. So it is possible.1Input: numCourses = 2, prerequisites = [[1,0],[0,1]] 2Output: false 3Explanation: There are a total of 2 courses to take. 4 To take course 1 you should have finished course 0, and to take course 0 you should 5 also have finished course 1. So it is impossible.Python Solution# 1class Solution(object): 2 def canFinish(self, numCourses, prerequisites): 3 \u0026#34;\u0026#34;\u0026#34; 4 :type numCourses: int 5 :type prerequisites: List[List[int]] 6 :rtype: bool 7 \u0026#34;\u0026#34;\u0026#34; 8 graph = [[] for _ in range(numCourses)] 9 visited = [0 for _ in range(numCourses)] 10 # create graph 11 for pair in prerequisites: 12 x, y = pair 13 graph[x].append(y) 14 # visit each node 15 for i in range(numCourses): 16 if not self.dfs(graph, visited, i): 17 return False 18 return True 19 20 def dfs(self, graph, visited, i): 21 # if ith node is marked as being visited, then a cycle is found 22 if visited[i] == -1: 23 return False 24 # if it is done visted, then do not visit again 25 if visited[i] == 1: 26 return True 27 # mark as being visited 28 visited[i] = -1 29 # visit all the neighbours 30 for j in graph[i]: 31 if not self.dfs(graph, visited, j): 32 return False 33 # after visit all the neighbours, mark it as done visited 34 visited[i] = 1 35 return True "},{"id":25,"href":"/tech-interview-prep/problems/decode-ways/","title":"Decode ways","section":"All Problems","content":"Decode ways# Levels:\u0026ensp;level-4 Data structures:\u0026ensp;string Algorithms:\u0026ensp;dynamic-programming Practice Link# LeetCode\nDescription# A message containing letters from A-Z is being encoded to numbers using the following mapping:\n1\u0026#39;A\u0026#39; -\u0026gt; 1 2\u0026#39;B\u0026#39; -\u0026gt; 2 3... 4\u0026#39;Z\u0026#39; -\u0026gt; 26 Given a non-empty string containing only digits, determine the total number of ways to decode it.\nExamples# 1Input: \u0026#34;12\u0026#34; 2Output: 2 3Explanation: It could be decoded as \u0026#34;AB\u0026#34; (1 2) or \u0026#34;L\u0026#34; (12).1Input: \u0026#34;226\u0026#34; 2Output: 3 3Explanation: It could be decoded as \u0026#34;BZ\u0026#34; (2 26), \u0026#34;VF\u0026#34; (22 6), or \u0026#34;BBF\u0026#34; (2 2 6).Python Solution# 1class Solution: 2 def numDecodings(self, s): 3 if not s or s[0] == \u0026#39;0\u0026#39;: 4 return 0 5 6 dp = [0 for x in range(len(s) + 1)] 7 8 # base case initialization 9 dp[0:2] = [1, 1] 10 11 for i in range(2, len(s) + 1): 12 # One step jump 13 if 0 \u0026lt; int(s[i - 1:i]): #(2) 14 dp[i] = dp[i - 1] 15 # Two step jump 16 if 10 \u0026lt;= int(s[i - 2:i]) \u0026lt;= 26: #(3) 17 dp[i] += dp[i - 2] 18 19 return dp[-1] "},{"id":26,"href":"/tech-interview-prep/problems/encode-and-decode-strings/","title":"Encode and decode strings","section":"All Problems","content":"Encode and decode strings# Levels:\u0026ensp;level-4 Data structures:\u0026ensp;string Description# Design an algorithm to encode a list of strings to a string. The encoded string is then sent over the network and is decoded back to the original list of strings. Note:\nThe string may contain any possible characters out of 256 valid ascii characters. Your algorithm should be generalized enough to work on any possible characters. Do not use class member/global/static variables to store states. Your encode and decode algorithms should be stateless. Do not rely on any library method such as eval or serialize methods. You should implement your own encode/decode algorithm. Python Solution# 1from functools import reduce 2 3 4class Codec(object): 5 def encode(self, strs): 6 \u0026#34;\u0026#34;\u0026#34; 7 Encodes a list of strings to a single string. 8 9 Algorithm: Length info 10 11 :type strs: List[str] 12 :rtype: str 13 \u0026#34;\u0026#34;\u0026#34; 14 strs = list(map(lambda x: str(len(x)) + \u0026#34;/\u0026#34; + x, strs)) 15 return reduce(lambda x, y: x + y, strs, \u0026#34;\u0026#34;) # i.e. \u0026#34;\u0026#34;.join(strs) 16 17 def decode(self, s): 18 \u0026#34;\u0026#34;\u0026#34; 19 Decodes a single string to a list of strings. 20 21 :type s: str 22 :rtype: List[str] 23 \u0026#34;\u0026#34;\u0026#34; 24 strs = [] 25 i = 0 26 while i \u0026lt; len(s): 27 j = s.index(\u0026#34;/\u0026#34;, i) 28 l = int(s[i:j]) 29 strs.append(s[j + 1:j + 1 + l]) 30 i = j + 1 + l 31 32 return strs 33 34 35class CodecMethod2(object): 36 def encode(self, strs): 37 \u0026#34;\u0026#34;\u0026#34; 38 Encodes a list of strings to a single string. 39 40 Algorithm: Escape 41 42 :type strs: List[str] 43 :rtype: str 44 \u0026#34;\u0026#34;\u0026#34; 45 strs = list(map(lambda x: x.replace(\u0026#34;\\n\u0026#34;, \u0026#34;\\n\\n\u0026#34;) + \u0026#34;_\\n_\u0026#34;, strs)) 46 return reduce(lambda x, y: x + y, strs, \u0026#34;\u0026#34;) 47 48 def decode(self, s): 49 \u0026#34;\u0026#34;\u0026#34; 50 Decodes a single string to a list of strings. 51 52 :type s: str 53 :rtype: List[str] 54 \u0026#34;\u0026#34;\u0026#34; 55 strs = s.split(\u0026#34;_\\n_\u0026#34;) 56 strs = strs[:-1] # clear the trailing delimiter 57 return list(map(lambda x: x.replace(\u0026#34;\\n\\n\u0026#34;, \u0026#34;\\n\u0026#34;), strs)) "},{"id":27,"href":"/tech-interview-prep/problems/eval-precedence-expression/","title":"Evaluate Precedence Expression With + And *","section":"All Problems","content":"Evaluate Precedence Expression With + And *# Levels:\u0026ensp;level-4 Data structures:\u0026ensp;string,\u0026ensp;stack Patterns:\u0026ensp;mark-and-sweep Practice Link# LeetCode (nearby) This problem is a simpler subset: only + and *. Description# Given a string expression containing: non-negative integers (possibly multi-digit) operators + and * no parentheses optional whitespace Evaluate the expression and return the integer result. Operator precedence: * is evaluated before +. Examples# 1\u0026#34;2*3+4\u0026#34; -\u0026gt; 10 2\u0026#34;2*3+4*3\u0026#34; -\u0026gt; 18 3\u0026#34;12 + 3*4 + 5\u0026#34; -\u0026gt; 29Python Solution# 1def eval_plus_mul(expr: str) -\u0026gt; int: 2 \u0026#34;\u0026#34;\u0026#34; 3 Evaluate expression with non-negative integers and operators \u0026#39;+\u0026#39; and \u0026#39;*\u0026#39;, 4 respecting precedence of \u0026#39;*\u0026#39; over \u0026#39;+\u0026#39;. 5 6 Idea: 7 - Keep a running `term` (the current multiplication chain). 8 - When we hit \u0026#39;+\u0026#39;, we add the finished `term` into `total` and start a new term. 9 - When we hit \u0026#39;*\u0026#39;, we keep multiplying into the same term. 10 11 Time: O(n) 12 Space: O(1) 13 \u0026#34;\u0026#34;\u0026#34; 14 if expr is None: 15 return 0 16 17 s = expr.replace(\u0026#34; \u0026#34;, \u0026#34;\u0026#34;) 18 if not s: 19 return 0 20 21 total = 0 22 term = 0 # current multiplication term 23 num = 0 24 op = \u0026#39;+\u0026#39; # previous operator applied to `num` into `term` 25 26 for i, ch in enumerate(s): 27 if ch.isdigit(): 28 num = num * 10 + (ord(ch) - ord(\u0026#39;0\u0026#39;)) 29 30 # If operator or end: apply previous op 31 if (not ch.isdigit()) or i == len(s) - 1: 32 if op == \u0026#39;+\u0026#39;: 33 # term is complete; push it to total, start new term with num 34 total += term 35 term = num 36 elif op == \u0026#39;*\u0026#39;: 37 term *= num 38 else: 39 raise ValueError(f\u0026#34;Unexpected operator: {op}\u0026#34;) 40 41 op = ch 42 num = 0 43 44 return total + term "},{"id":28,"href":"/tech-interview-prep/problems/find-median-from-data-stream/","title":"Find median from data stream","section":"All Problems","content":"Find median from data stream# Levels:\u0026ensp;level-5 Data structures:\u0026ensp;heap Practice Link# LeetCode\nDescription# Median is the middle value in an ordered integer list.\nIf the size of the list is even, there is no middle value.\nSo the median is the mean of the two middle value.\n1For example, 2[2,3,4], the median is 3 3 4[2,3], the median is (2 + 3) / 2 = 2.5 Design a data structure that supports the following two operations:\nvoid addNum(int num): Add a integer number from the data stream to the data structure. double findMedian(): Return the median of all elements so far. Example# 1addNum(1) 2addNum(2) 3findMedian() -\u0026gt; 1.5 4addNum(3) 5findMedian() -\u0026gt; 2Follow up# If all integer numbers from the stream are between 0 and 100, how would you optimize it? If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it? Python Solution# 1from heapq import heappush, heappushpop, heappop 2 3 4class MedianFinder: 5 def __init__(self): 6 self.heaps = [], [] 7 8 def addNum(self, num): 9 small, large = self.heaps 10 heappush(small, -heappushpop(large, num)) 11 if len(large) \u0026lt; len(small): 12 heappush(large, -heappop(small)) 13 14 def findMedian(self): 15 small, large = self.heaps 16 if len(large) \u0026gt; len(small): 17 return float(large[0]) 18 return (large[0] - small[0]) / 2.0 "},{"id":29,"href":"/tech-interview-prep/problems/find-minimum-in-rotated-sorted-array/","title":"Find minimum in rotated sorted array","section":"All Problems","content":"Find minimum in rotated sorted array# Levels:\u0026ensp;level-2 Data structures:\u0026ensp;array Algorithms:\u0026ensp;binary-search Practice Link# LeetCode\nDescription# Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). Find the minimum element. You may assume no duplicate exists in the array. Python Solution# 1class Solution(object): 2 def findMin(self, nums): 3 \u0026#34;\u0026#34;\u0026#34; 4 :type nums: List[int] 5 :rtype: int 6 \u0026#34;\u0026#34;\u0026#34; 7 if not nums: 8 return None 9 return self.__fmin(nums, 0, len(nums) - 1) 10 11 def __fmin(self, nums, i, j): 12 if i == j: 13 return nums[i] 14 if i + 1 == j: 15 return min(nums[i], nums[j]) 16 if nums[i] \u0026lt; nums[j]: 17 return nums[i] 18 mid = int((i + j) / 2) 19 if nums[i] \u0026lt; nums[mid]: 20 return self.__fmin(nums, mid, j) 21 return self.__fmin(nums, i, mid) 22 23 24class Solution2(object): 25 def findMin(self, nums): 26 \u0026#34;\u0026#34;\u0026#34; 27 :type nums: List[int] 28 :rtype: int 29 \u0026#34;\u0026#34;\u0026#34; 30 if not nums: 31 return None 32 lo = 0 33 hi = len(nums) - 1 34 while lo \u0026lt; hi: 35 mid = (lo + hi) / 2 36 if (nums[mid] \u0026gt; nums[hi]): 37 lo = mid + 1 38 else: 39 hi = mid 40 return nums[lo] 41 42 43in_arrs = [ 44 [3, 4, 5, 1, 2], 45 [4, 5, 6, 7, 0, 1, 2], 46 [8, 1, 2, 3], 47 [1, 2, 3, 4], 48 [1], 49 [], 50 None, 51] 52 53exp_out = [ 54 1, 55 0, 56 1, 57 1, 58 1, 59 None, 60 None, 61] 62 63if __name__ == \u0026#34;__main__\u0026#34;: 64 65 sol = Solution() 66 sol2 = Solution() 67 for idx, nin in enumerate(in_arrs): 68 r = sol.findMin(nin) 69 print(exp_out[idx] == r, r) 70 r = sol2.findMin(nin) 71 print(exp_out[idx] == r, r) "},{"id":30,"href":"/tech-interview-prep/problems/graph-valid-tree/","title":"Graph valid tree","section":"All Problems","content":"Graph valid tree# Levels:\u0026ensp;level-5 Data structures:\u0026ensp;graph Description# Given n nodes labeled from 0 to n - 1 and a list of undirected edges (each edge is a pair of nodes), write a function to check whether these edges make up a valid tree. Example# 1Given n = 5 and edges = [[0, 1], [0, 2], [0, 3], [1, 4]], return true. 2 3Given n = 5 and edges = [[0, 1], [1, 2], [2, 3], [1, 3], [1, 4]], return false.Hint# Given n = 5 and edges = [[0, 1], [1, 2], [3, 4]], what should your return? Is this case a valid tree? According to the definition of tree on Wikipedia: “a tree is an undirected graph in which any two vertices are connected by exactly one path. In other words, any connected graph without simple cycles is a tree.” Note: you can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0, 1] is the same as [1, 0] and thus will not appear together inedges. Treating input as graph, making sure no cycles and one connected component. Check for cycle and connectness in Graph can be done by DFS, BFS and Union-find Python Solution# 1from collections import defaultdict 2 3 4class Solution(object): 5 def validTree(self, n, edges): 6 \u0026#34;\u0026#34;\u0026#34; 7 A graph is a tree: 8 1. no cycle 9 2. all connected 10 :type n: int 11 :type edges: List[List[int] 12 :rtype: bool 13 \u0026#34;\u0026#34;\u0026#34; 14 if not edges: 15 return n in (0, 1) 16 17 V = defaultdict(list) 18 for e in edges: 19 V[e[0]].append(e[1]) 20 V[e[1]].append(e[0]) 21 22 visited = set() 23 pathset = set() 24 if not self.dfs(V, edges[0][0], None, pathset, visited): 25 return False 26 27 return len(visited) == n 28 29 def dfs(self, V, v, pi, pathset, visited): 30 if v in pathset: 31 return False 32 33 pathset.add(v) 34 for nbr in V[v]: 35 if nbr != pi: # since undirected graph 36 if not self.dfs(V, nbr, v, pathset, visited): 37 return False 38 39 pathset.remove(v) 40 visited.add(v) 41 return True "},{"id":31,"href":"/tech-interview-prep/problems/group-anagrams/","title":"Group anagrams","section":"All Problems","content":"Group anagrams# Levels:\u0026ensp;level-3 Data structures:\u0026ensp;string,\u0026ensp;hash-table Practice Link# LeetCode\nDescription# Given an array of strings, group anagrams together. Note:\nAll inputs will be in lowercase. The order of your output does not matter. Example# 1Input: [\u0026#34;eat\u0026#34;, \u0026#34;tea\u0026#34;, \u0026#34;tan\u0026#34;, \u0026#34;ate\u0026#34;, \u0026#34;nat\u0026#34;, \u0026#34;bat\u0026#34;], 2Output: 3[ 4 [\u0026#34;ate\u0026#34;,\u0026#34;eat\u0026#34;,\u0026#34;tea\u0026#34;], 5 [\u0026#34;nat\u0026#34;,\u0026#34;tan\u0026#34;], 6 [\u0026#34;bat\u0026#34;] 7]Python Solution# 1import collections 2 3 4class Solution(object): 5 def groupAnagrams(self, strs): 6 ans = collections.defaultdict(list) 7 for s in strs: 8 ans[tuple(sorted(s))].append(s) 9 return ans.values() "},{"id":32,"href":"/tech-interview-prep/problems/house-robber/","title":"House robber","section":"All Problems","content":"House robber# Levels:\u0026ensp;level-3 Data structures:\u0026ensp;array Algorithms:\u0026ensp;dynamic-programming Practice Link# LeetCode\nDescription# You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. Examples# 1Input: [1,2,3,1] 2Output: 4 3Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3). 4 Total amount you can rob = 1 + 3 = 4.1Input: [2,7,9,3,1] 2Output: 12 3Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1). 4 Total amount you can rob = 2 + 9 + 1 = 12.Python Solution# 1class Solution: 2 def rob(self, nums): 3 rob, not_rob = 0, 0 4 for num in nums: 5 rob, not_rob = not_rob + num, max(rob, not_rob) 6 return max(rob, not_rob) "},{"id":33,"href":"/tech-interview-prep/problems/house-robber-ii/","title":"House robber II","section":"All Problems","content":"House robber II# Levels:\u0026ensp;level-4 Data structures:\u0026ensp;array Algorithms:\u0026ensp;dynamic-programming Practice Link# LeetCode\nDescription# You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. Examples# 1Input: [2,3,2] 2Output: 3 3Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), 4 because they are adjacent houses.1Input: [1,2,3,1] 2Output: 4 3Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3). 4 Total amount you can rob = 1 + 3 = 4.Python Solution# 1class Solution(object): 2 def rob(self, nums): 3 \u0026#34;\u0026#34;\u0026#34; 4 :type nums: List[int] 5 :rtype: int 6 \u0026#34;\u0026#34;\u0026#34; 7 def simple_rob(nums): 8 rob, not_rob = 0, 0 9 for num in nums: 10 rob, not_rob = not_rob + num, max(rob, not_rob) 11 return max(rob, not_rob) 12 13 if not nums: 14 return 0 15 elif len(nums) == 1: 16 return nums[0] 17 else: 18 return max(simple_rob(nums[1:]), simple_rob(nums[:-1])) "},{"id":34,"href":"/tech-interview-prep/problems/implement-trie-prefix-tree/","title":"Implement trie (prefix tree)","section":"All Problems","content":"Implement trie (prefix tree)# Levels:\u0026ensp;level-4 Data structures:\u0026ensp;trie Practice Link# LeetCode\nDescription# Implement a trie with insert, search, and startsWith methods. You may assume that all inputs are consist of lowercase letters a-z. All inputs are guaranteed to be non-empty strings. Example# 1Trie trie = new Trie(); 2 3trie.insert(\u0026#34;apple\u0026#34;); 4trie.search(\u0026#34;apple\u0026#34;); // returns true 5trie.search(\u0026#34;app\u0026#34;); // returns false 6trie.startsWith(\u0026#34;app\u0026#34;); // returns true 7trie.insert(\u0026#34;app\u0026#34;); 8trie.search(\u0026#34;app\u0026#34;); // returns truePython Solution# 1import collections 2 3 4class TrieNode: 5 # Initialize your data structure here. 6 def __init__(self): 7 self.children = collections.defaultdict(TrieNode) 8 self.is_word = False 9 10 11class Trie(object): 12 def __init__(self): 13 self.root = TrieNode() 14 15 def insert(self, word): 16 current = self.root 17 for letter in word: 18 current = current.children[letter] 19 current.is_word = True 20 21 def search(self, word): 22 current = self.root 23 for letter in word: 24 current = current.children.get(letter) 25 if current is None: 26 return False 27 return current.is_word 28 29 def startsWith(self, prefix): 30 current = self.root 31 for letter in prefix: 32 current = current.children.get(letter) 33 if current is None: 34 return False 35 return True 36 37 38# Your Trie object will be instantiated and called as such: 39# obj = Trie() 40# obj.insert(word) 41# param_2 = obj.search(word) 42# param_3 = obj.startsWith(prefix) "},{"id":35,"href":"/tech-interview-prep/problems/insert-interval/","title":"Insert interval","section":"All Problems","content":"Insert interval# Levels:\u0026ensp;level-5 Data structures:\u0026ensp;array Patterns:\u0026ensp;intervals Practice Link# LeetCode\nDescription# Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary). You may assume that the intervals were initially sorted according to their start times. Examples# 1Input: intervals = [[1,3],[6,9]], newInterval = [2,5] 2Output: [[1,5],[6,9]]1Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8] 2Output: [[1,2],[3,10],[12,16]] 3Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].Python Solution# 1class Solution(object): 2 def insert(self, intervals, newInterval): 3 \u0026#34;\u0026#34;\u0026#34; 4 :type intervals: List[List[int]] 5 :type newInterval: List[int] 6 :rtype: List[List[int]] 7 \u0026#34;\u0026#34;\u0026#34; 8 s, e = newInterval[0], newInterval[-1] 9 left, right = [], [] 10 for i in intervals: 11 if i[-1] \u0026lt; s: 12 left += i, 13 elif i[0] \u0026gt; e: 14 right += i, 15 else: 16 s = min(s, i[0]) 17 e = max(e, i[-1]) 18 return left + [[s, e]] + right "},{"id":36,"href":"/tech-interview-prep/problems/level-order-binary-tree-insert/","title":"Insert Into Complete Binary Tree (Level-Order)","section":"All Problems","content":"Insert Into Complete Binary Tree (Level-Order)# Levels:\u0026ensp;level-4 Data structures:\u0026ensp;tree Patterns:\u0026ensp;bfs Practice Link# LeetCode (nearby/exact concept) Description# Inferred from your notes: “insert/attach child”, BFS levels, left-to-right. Given the root of a binary tree and a value val, insert a new node such that the tree remains a complete binary tree: fill levels top-to-bottom and within a level, fill left-to-right Concretely: perform level-order traversal and insert at the first node missing a left child, else the first node missing a right child. Return the root. Examples# 1Input: root = [1,2,3,4,5,6], val = 7 2Output: [1,2,3,4,5,6,7]1Input: root = [1,2,3,4,5,6], val = 8 2Output: [1,2,3,4,5,6,7,8]Python Solution# 1from collections import deque 2from typing import Optional 3 4 5class TreeNode: 6 def __init__(self, val: int = 0, 7 left: Optional[\u0026#34;TreeNode\u0026#34;] = None, 8 right: Optional[\u0026#34;TreeNode\u0026#34;] = None): 9 self.val = val 10 self.left = left 11 self.right = right 12 13def insert_complete(root: Optional[TreeNode], val: int) -\u0026gt; TreeNode: 14 \u0026#34;\u0026#34;\u0026#34; 15 Insert `val` into the first available spot to maintain completeness. 16 17 Time: O(n) worst-case per insertion 18 Space: O(width of tree) due to queue 19 \u0026#34;\u0026#34;\u0026#34; 20 new_node = TreeNode(val) 21 if root is None: 22 return new_node 23 24 q = deque([root]) 25 while q: 26 node = q.popleft() 27 28 if node.left is None: 29 node.left = new_node 30 return root 31 else: 32 q.append(node.left) 33 34 if node.right is None: 35 node.right = new_node 36 return root 37 else: 38 q.append(node.right) 39 40 return root # logically unreachable "},{"id":37,"href":"/tech-interview-prep/problems/invert-binary-tree/","title":"Invert a binary tree","section":"All Problems","content":"Invert a binary tree# Levels:\u0026ensp;level-0 Data structures:\u0026ensp;tree Practice Link# LeetCode\nDescription# Invert a binary tree Example# 1Input: 2 4 3 / \\ 4 2 7 5 / \\ / \\ 61 3 6 9 7 8Output: 9 4 10 / \\ 11 7 2 12 / \\ / \\ 139 6 3 1Python Solution# 1# Definition for a binary tree node. 2class TreeNode(object): 3 def __init__(self, x): 4 self.val = x 5 self.left = None 6 self.right = None 7 8 9class Solution(object): 10 def invertTree(self, root): 11 \u0026#34;\u0026#34;\u0026#34; 12 :type root: TreeNode 13 :rtype: TreeNode 14 \u0026#34;\u0026#34;\u0026#34; 15 if root is None: 16 return None 17 root.left, root.right = self.invertTree(root.right), self.invertTree( 18 root.left) 19 return root "},{"id":38,"href":"/tech-interview-prep/problems/string-is-subsequence/","title":"Is Subsequence","section":"All Problems","content":"Is Subsequence# Levels:\u0026ensp;level-2 Data structures:\u0026ensp;string Patterns:\u0026ensp;two-pointers Practice Link# LeetCode Description# Given two strings s (source) and t (target), return True if t is a subsequence of s, else False. Order must be preserved. Edge cases: (\u0026quot;\u0026quot;, \u0026quot;\u0026quot;) -\u0026gt; True (\u0026quot;abcd\u0026quot;, \u0026quot;\u0026quot;) -\u0026gt; True (\u0026quot;\u0026quot;, \u0026quot;a\u0026quot;) -\u0026gt; False Examples# 1(\u0026#34;abcd\u0026#34;, \u0026#34;bd\u0026#34;) -\u0026gt; True 2(\u0026#34;abcd\u0026#34;, \u0026#34;be\u0026#34;) -\u0026gt; FalsePython Solution# 1def is_subsequence(s: str, t: str) -\u0026gt; bool: 2 \u0026#34;\u0026#34;\u0026#34; 3 Returns True if t is a subsequence of s. 4 5 Time: O(len(s)) 6 Space: O(1) 7 \u0026#34;\u0026#34;\u0026#34; 8 i = 0 # pointer in t 9 for ch in s: 10 if i \u0026lt; len(t) and ch == t[i]: 11 i += 1 12 if i == len(t): 13 return True 14 return i == len(t) "},{"id":39,"href":"/tech-interview-prep/problems/jump-game/","title":"Jump game","section":"All Problems","content":"Jump game# Levels:\u0026ensp;level-4 Data structures:\u0026ensp;array Algorithms:\u0026ensp;dynamic-programming Practice Link# LeetCode\nDescription# Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index. Examples# 1Input: [2,3,1,1,4] 2Output: true 3Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.1Input: [3,2,1,0,4] 2Output: false 3Explanation: You will always arrive at index 3 no matter what. Its maximum 4 jump length is 0, which makes it impossible to reach the last index.Python Solution# 1class Solution: 2 def canJump(self, nums): 3 \u0026#34;\u0026#34;\u0026#34; 4 :type nums: List[int] 5 :rtype: bool 6 \u0026#34;\u0026#34;\u0026#34; 7 if len(nums) \u0026lt;= 1: 8 return True 9 jumps = 1 10 n = len(nums) - 2 11 for i in range(n, -1, -1): 12 if nums[i] \u0026gt;= jumps: 13 jumps = 1 14 else: 15 jumps += 1 16 return nums[0] \u0026gt;= jumps "},{"id":40,"href":"/tech-interview-prep/problems/kth-smallest-element-in-a-bst/","title":"Kth smallest element in a BST","section":"All Problems","content":"Kth smallest element in a BST# Levels:\u0026ensp;level-3 Data structures:\u0026ensp;tree Algorithms:\u0026ensp;binary-search Practice Link# LeetCode\nDescription# Given a binary search tree, write a function kthSmallest to find the kth smallest element in it. Note:\nYou may assume k is always valid, 1 ≤ k ≤ BST\u0026rsquo;s total elements. Examples# 1Input: root = [3,1,4,null,2], k = 1 2 3 3 / \\ 4 1 4 5 \\ 6 2 7Output: 11Input: root = [5,3,6,2,4,null,null,1], k = 3 2 5 3 / \\ 4 3 6 5 / \\ 6 2 4 7 / 8 1 9Output: 3Follow up# What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine? Python Solution# 1class TreeNode(object): 2 def __init__(self, x): 3 self.val = x 4 self.left = None 5 self.right = None 6 7 8class Solution(object): 9 def kthSmallestRecursive(self, root, k): 10 \u0026#34;\u0026#34;\u0026#34; 11 :type root: TreeNode 12 :type k: int 13 :rtype: int 14 \u0026#34;\u0026#34;\u0026#34; 15 def inorder(r): 16 return inorder(r.left) + [r.val] + inorder(r.right) if r else [] 17 18 return inorder(root)[k - 1] 19 20 def kthSmallestIterative(self, root, k): 21 \u0026#34;\u0026#34;\u0026#34; 22 :type root: TreeNode 23 :type k: int 24 :rtype: int 25 \u0026#34;\u0026#34;\u0026#34; 26 stack = [] 27 28 while True: 29 while root: 30 stack.append(root) 31 root = root.left 32 root = stack.pop() 33 k -= 1 34 if not k: 35 return root.val 36 root = root.right "},{"id":41,"href":"/tech-interview-prep/problems/linked-list-cycle/","title":"Linked list cycle","section":"All Problems","content":"Linked list cycle# Levels:\u0026ensp;level-1 Data structures:\u0026ensp;linkedlist Practice Link# LeetCode\nDescription# Given a linked list, determine if it has a cycle in it. To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list. Examples# 1Input: head = [3,2,0,-4], pos = 1 2Output: true 3Explanation: There is a cycle in the linked list, where tail connects to the second node.1Input: head = [1,2], pos = 0 2Output: true 3Explanation: There is a cycle in the linked list, where tail connects to the first node.Thinking# This can be solved using tortoise and hare approach or using hashtable. Python Solution# 1class Solution(object): 2 # Tortise and hare approach 3 def hasCycle(self, head): 4 try: 5 slow = head 6 fast = head.next 7 while slow is not fast: 8 slow = slow.next 9 fast = fast.next.next 10 return True 11 except: 12 return False "},{"id":42,"href":"/tech-interview-prep/problems/longest-consecutive-sequence/","title":"Longest consecutive sequence","section":"All Problems","content":"Longest consecutive sequence# Levels:\u0026ensp;level-5 Data structures:\u0026ensp;array Patterns:\u0026ensp;union-find Practice Link# LeetCode\nDescription# Given an unsorted array of integers, find the length of the longest consecutive elements sequence. Your algorithm should run in O(n) complexity. Example# 1Input: [100, 4, 200, 1, 3, 2] 2Output: 4 3Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.Python Solution# 1class Solution: 2 def longestConsecutive(self, nums): 3 longest_streak = 0 4 num_set = set(nums) 5 6 for num in num_set: 7 if num - 1 not in num_set: 8 current_num = num 9 current_streak = 1 10 11 while current_num + 1 in num_set: 12 current_num += 1 13 current_streak += 1 14 15 longest_streak = max(longest_streak, current_streak) 16 17 return longest_streak "},{"id":43,"href":"/tech-interview-prep/problems/longest-increasing-subsequence/","title":"Longest increasing subsequence","section":"All Problems","content":"Longest increasing subsequence# Levels:\u0026ensp;level-4 Data structures:\u0026ensp;array Algorithms:\u0026ensp;dynamic-programming,\u0026ensp;binary-search Practice Link# LeetCode\nDescription# Given an unsorted array of integers, find the length of longest increasing subsequence. Note:\nThere may be more than one LIS combination, it is only necessary for you to return the length. Your algorithm should run in O(n2) complexity. Example# 1Input: [10,9,2,5,3,7,101,18] 2Output: 4 3Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.Follow up# Could you improve it to O(n log n) time complexity? Python Solution# 1class Solution(object): 2 def lengthOfLIS(self, nums): 3 tails = [0] * len(nums) 4 size = 0 5 for x in nums: 6 i, j = 0, size 7 while i != j: 8 m = (i + j) / 2 9 if tails[m] \u0026lt; x: 10 i = m + 1 11 else: 12 j = m 13 tails[i] = x 14 size = max(i + 1, size) 15 return size "},{"id":44,"href":"/tech-interview-prep/problems/longest-palindromic-substring/","title":"Longest palindromic substring","section":"All Problems","content":"Longest palindromic substring# Levels:\u0026ensp;level-4 Data structures:\u0026ensp;string Algorithms:\u0026ensp;dynamic-programming Practice Link# LeetCode\nDescription# Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. Example# 1Input: \u0026#34;babad\u0026#34; 2Output: \u0026#34;bab\u0026#34; 3Note: \u0026#34;aba\u0026#34; is also a valid answer.1Input: \u0026#34;cbbd\u0026#34; 2Output: \u0026#34;bb\u0026#34;Python Solution# 1class Solution(object): 2 def longestPalindrome(self, s): 3 \u0026#34;\u0026#34;\u0026#34; 4 :type s: str 5 :rtype: str 6 \u0026#34;\u0026#34;\u0026#34; 7 8 res = \u0026#34;\u0026#34; 9 for i in range(len(s)): 10 # odd case, like \u0026#34;aba\u0026#34; 11 tmp = self.helper(s, i, i) 12 if len(tmp) \u0026gt; len(res): 13 res = tmp 14 # even case, like \u0026#34;abba\u0026#34; 15 tmp = self.helper(s, i, i + 1) 16 if len(tmp) \u0026gt; len(res): 17 res = tmp 18 return res 19 20 # get the longest palindrome, l, r are the middle indexes 21 # from inner to outer 22 def helper(self, s, l, r): 23 while l \u0026gt;= 0 and r \u0026lt; len(s) and s[l] == s[r]: 24 l -= 1 25 r += 1 26 return s[l + 1:r] "},{"id":45,"href":"/tech-interview-prep/problems/longest-repeating-character-replacement/","title":"Longest repeating character replacement","section":"All Problems","content":"Longest repeating character replacement# Levels:\u0026ensp;level-4 Data structures:\u0026ensp;string Patterns:\u0026ensp;sliding-window Practice Link# LeetCode\nDescription# Given a string s that consists of only uppercase english letters, you can perform at most k operations on that string. In one operation, you can choose any character of the string and change it to any other uppercase English character. Find the length of the longest sub-string containing all repeating letters you can get after performing the above operations. Note:\nBoth the string\u0026rsquo;s length and k will not exceed 10^4. Examples# 1Input: s = \u0026#34;ABAB\u0026#34;, k = 2 2 3Output: 4 4 5Explanation: 6Replace the two \u0026#39;A\u0026#39;s with two \u0026#39;B\u0026#39;s or vice versa.1Input: s = \u0026#34;AABABBA\u0026#34;, k = 1 2 3Output: 4 4 5Explanation: 6Replace the one \u0026#39;A\u0026#39; in the middle with \u0026#39;B\u0026#39; and form \u0026#34;AABBBBA\u0026#34;. 7The substring \u0026#34;BBBB\u0026#34; has the longest repeating letters, which is 4.Thinking# Can this have a sliding window based implementation? Python Solution# 1import collections 2 3 4class Solution: 5 def characterReplacement(self, s, k): 6 counts = collections.Counter() 7 start = res = 0 8 9 # We use a window ranging from index start to end 10 # We only look in characters inside this window and keep track of their counts 11 # We can allow up to K chars that are not the most frequent char in our window 12 13 for end in range(len(s)): 14 # at each loop, end is shifted to the right 15 counts[s[end]] += 1 # we\u0026#39;ve seen character \u0026#39;s[end]\u0026#39; one more time in the this new window 16 17 # we shift start to the right only if we ran out of replacements 18 # we ran out of replacements if (CHARS that are not the most frequent in current window) \u0026gt; k 19 # (end - start + 1) is length of our window, because our window range is INCLUSIVE of both ends 20 if end - start + 1 - counts.most_common(1)[0][1] \u0026gt; k: 21 # since our window will be shifted, we subtract the character that we are shifting away from by 1 22 # because it will no longer be in the new window 23 counts[s[start]] -= 1 24 start += 1 # now shift our window 25 26 # at each window, simply update res if our current window is larger 27 res = max(res, end - start + 1) 28 29 return res "},{"id":46,"href":"/tech-interview-prep/problems/longest-substring-without-repeating-characters/","title":"Longest substring without repeating characters","section":"All Problems","content":"Longest substring without repeating characters# Levels:\u0026ensp;level-4 Data structures:\u0026ensp;string,\u0026ensp;hash-table Patterns:\u0026ensp;sliding-window Practice Link# LeetCode\nDescription# Given a string, find the length of the longest substring without repeating characters. Examples# 1Input: \u0026#34;abcabcbb\u0026#34; 2Output: 3 3Explanation: The answer is \u0026#34;abc\u0026#34;, with the length of 3.1Input: \u0026#34;pwwkew\u0026#34; 2Output: 3 3Explanation: The answer is \u0026#34;wke\u0026#34;, with the length of 3. 4Note that the answer must be a substring, \u0026#34;pwke\u0026#34; is a subsequence and not a substring.Python Solution# 1class Solution: 2 # @return an integer 3 def lengthOfLongestSubstring(self, s): 4 used = {} 5 max_length = start = 0 6 for i, c in enumerate(s): 7 if c in used and start \u0026lt;= used[c]: 8 start = used[c] + 1 9 else: 10 max_length = max(max_length, i - start + 1) 11 12 used[c] = i 13 return max_length "},{"id":47,"href":"/tech-interview-prep/problems/lowest-common-ancestor-of-a-bst/","title":"Lowest common ancestor of a binary search tree","section":"All Problems","content":"Lowest common ancestor of a binary search tree# Levels:\u0026ensp;level-2 Data structures:\u0026ensp;tree Practice Link# LeetCode\nDescription# Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST. According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).” Note:\nAll of the nodes\u0026rsquo; values will be unique. p and q are different and both values will exist in the BST. Examples# 1Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8 2Output: 6 3Explanation: The LCA of nodes 2 and 8 is 6.1Output: 2 2Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.Python Solution# 1class TreeNode(object): 2 def __init__(self, x): 3 self.val = x 4 self.left = None 5 self.right = None 6 7 8class Solution: 9 # Recursive solution is O(N) in time and O(N) in space 10 def lowestCommonAncestorRecursive(self, root, p, q): 11 \u0026#34;\u0026#34;\u0026#34; 12 :type root: TreeNode 13 :type p: TreeNode 14 :type q: TreeNode 15 :rtype: TreeNode 16 \u0026#34;\u0026#34;\u0026#34; 17 # Value of current node or parent node. 18 parent_val = root.val 19 20 # Value of p 21 p_val = p.val 22 23 # Value of q 24 q_val = q.val 25 26 # If both p and q are greater than parent 27 if p_val \u0026gt; parent_val and q_val \u0026gt; parent_val: 28 return self.lowestCommonAncestorRecursive(root.right, p, q) 29 # If both p and q are lesser than parent 30 elif p_val \u0026lt; parent_val and q_val \u0026lt; parent_val: 31 return self.lowestCommonAncestorRecursive(root.left, p, q) 32 # We have found the split point, i.e. the LCA node. 33 else: 34 return root 35 36 # Iterative solution is O(N) in time and O(1) in space 37 def lowestCommonAncestorIterative(self, root, p, q): 38 \u0026#34;\u0026#34;\u0026#34; 39 :type root: TreeNode 40 :type p: TreeNode 41 :type q: TreeNode 42 :rtype: TreeNode 43 \u0026#34;\u0026#34;\u0026#34; 44 45 # Value of p 46 p_val = p.val 47 48 # Value of q 49 q_val = q.val 50 51 # Start from the root node of the tree 52 node = root 53 54 # Traverse the tree 55 while node: 56 57 # Value of current node or parent node. 58 parent_val = node.val 59 60 if p_val \u0026gt; parent_val and q_val \u0026gt; parent_val: 61 # If both p and q are greater than parent 62 node = node.right 63 elif p_val \u0026lt; parent_val and q_val \u0026lt; parent_val: 64 # If both p and q are lesser than parent 65 node = node.left 66 else: 67 # We have found the split point, i.e. the LCA node. 68 return node "},{"id":48,"href":"/tech-interview-prep/problems/maximum-depth-of-binary-tree/","title":"Maximum depth of binary tree","section":"All Problems","content":"Maximum depth of binary tree# Levels:\u0026ensp;level-0 Data structures:\u0026ensp;tree Algorithms:\u0026ensp;dfs Practice Link# LeetCode\nDescription# Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Note:\nA leaf is a node with no children. Example# 1Given binary tree [3,9,20,null,null,15,7], 2 3 3 4 / \\ 5 9 20 6 / \\ 7 15 7 8 9return its depth = 3.Python Solution# 1class TreeNode(object): 2 def __init__(self, x): 3 self.val = x 4 self.left = None 5 self.right = None 6 7 8class Solution(object): 9 def maxDepth(self, root): 10 \u0026#34;\u0026#34;\u0026#34; 11 :type root: TreeNode 12 :rtype: int 13 \u0026#34;\u0026#34;\u0026#34; 14 return 1 + max(self.maxDepth(root.left), self.maxDepth( 15 root.right)) if root else 0 "},{"id":49,"href":"/tech-interview-prep/problems/maximum-product-subarray/","title":"Maximum product subarray","section":"All Problems","content":"Maximum product subarray# Levels:\u0026ensp;level-3 Data structures:\u0026ensp;array Practice Link# LeetCode\nDescription# Given an integer array nums, find the contiguous subarray within an array (containing at least one number) which has the largest product. Examples# 1Input: [2,3,-2,4] 2Output: 6 3Explanation: [2,3] has the largest product 6.1Input: [-2,0,-1] 2Output: 0 3Explanation: The result cannot be 2, because [-2,-1] is not a subarray.Python Solution# 1class Solution(object): 2 def maxProduct(self, nums): 3 \u0026#34;\u0026#34;\u0026#34; 4 :type nums: List[int] 5 :rtype: int 6 \u0026#34;\u0026#34;\u0026#34; 7 if not nums: 8 return 0 9 best = nums[0] 10 current_max = nums[0] 11 current_min = nums[0] 12 for x in range(1, len(nums)): 13 n = (nums[x], nums[x] * current_max, nums[x] * current_min) 14 current_max = max(n) 15 current_min = min(n) 16 best = max(current_max, best) 17 print(nums[x], current_max, current_min, best) 18 return best 19 20 21in_arrs = [ 22 # [2, 1, 2, 1, 0, 1, 2], 23 # [3, 3, 5, 0, 0, 3, 1, 4], 24 # [3, 5, 0, 1, 4], 25 # [1, 2, -1, 1], 26 # [1, 2, 3, 4], 27 # [1, 1, 1, 3, 3, 4, 3, 2, 4, 2], 28 # [-2, 1, -3, 4, -1, 2, 1, -5, 4], 29 [2, 3, -2, 4], 30 [-2, 0, -1], 31 [-2], 32 [-4, -3], 33 [-2, 3, -4], 34 [2, -3, 4], 35 [0, -2, -3], 36 [0, -2], 37 [2, -3, 4, 0], 38 [2, -5, -2, -4, 3], 39] 40 41if __name__ == \u0026#34;__main__\u0026#34;: 42 43 sol = Solution() 44 for nin in in_arrs: 45 print(nin) 46 r = sol.maxProduct(nin) 47 print(r) "},{"id":50,"href":"/tech-interview-prep/problems/maximum-subarray/","title":"Maximum subarray","section":"All Problems","content":"Maximum subarray# Levels:\u0026ensp;level-2 Data structures:\u0026ensp;array Algorithms:\u0026ensp;divide-and-conquer,\u0026ensp;dynamic-programming Practice Link# LeetCode\nDescription# Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. Example# 1Input: [-2,1,-3,4,-1,2,1,-5,4], 2Output: 6 3Explanation: [4,-1,2,1] has the largest sum = 6.Follow up# If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle. Python Solution# 1class Solution(object): 2 def maxSubArray(self, nums): 3 if not nums: 4 return 0 5 best_sum = nums[0] 6 current_sum = 0 7 for x in nums: 8 current_sum = max(x, current_sum + x) 9 best_sum = max(best_sum, current_sum) 10 return best_sum 11 12 13in_arrs = [ 14 [2, 1, 2, 1, 0, 1, 2], 15 [3, 3, 5, 0, 0, 3, 1, 4], 16 [3, 5, 0, 1, 4], 17 [1, 2, -1, 1], 18 [1, 2, 3, 4], 19 [1, 1, 1, 3, 3, 4, 3, 2, 4, 2], 20 [-2, 1, -3, 4, -1, 2, 1, -5, 4], 21] 22if __name__ == \u0026#34;__main__\u0026#34;: 23 24 sol = Solution() 25 for nin in in_arrs: 26 r = sol.maxSubArray(nin) 27 print(r) "},{"id":51,"href":"/tech-interview-prep/problems/meeting-rooms/","title":"Meeting rooms","section":"All Problems","content":"Meeting rooms# Levels:\u0026ensp;level-4 Data structures:\u0026ensp;array Patterns:\u0026ensp;intervals Description# Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],...] (si \u0026lt; ei), determine if a person could attend all meetings. Example# 1Input: [[0, 30],[5, 10],[15, 20]], 2Output: false.Python Solution# 1import operator 2 3 4class Interval: 5 def __init__(self, s=0, e=0): 6 self.start = s 7 self.end = e 8 9 10class Solution: 11 def canAttendMeetings(self, intervals): 12 \u0026#34;\u0026#34;\u0026#34; 13 :type intervals: list[Interval] 14 :rtype: bool 15 \u0026#34;\u0026#34;\u0026#34; 16 intervals.sort(key=operator.attrgetter(\u0026#34;start\u0026#34;)) 17 for i in range(len(intervals) - 1): 18 if intervals[i].end \u0026gt; intervals[i + 1].start: 19 return False 20 21 return True "},{"id":52,"href":"/tech-interview-prep/problems/meeting-rooms-ii/","title":"Meeting rooms II","section":"All Problems","content":"Meeting rooms II# Levels:\u0026ensp;level-4 Data structures:\u0026ensp;array Patterns:\u0026ensp;intervals Description# Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],...] (si \u0026lt; ei), find the minimum number of conference rooms required. i.e Find the maximum number of overlapped intervals Example# 1Input: [[0, 30],[5, 10],[15, 20]], 2Output: 2Python Solution# 1import heapq 2import operator 3 4 5class Interval: 6 def __init__(self, s=0, e=0): 7 self.start = s 8 self.end = e 9 10 11class Solution(object): 12 def minMeetingRooms(self, intervals): 13 \u0026#34;\u0026#34;\u0026#34; 14 :type intervals: list[Interval] 15 :rtype: int 16 \u0026#34;\u0026#34;\u0026#34; 17 maxa = 0 18 19 intervals.sort(key=operator.attrgetter(\u0026#34;start\u0026#34;)) 20 h_end = [] 21 for itvl in intervals: 22 heapq.heappush(h_end, itvl.end) 23 while h_end and h_end[0] \u0026lt;= itvl.start: 24 heapq.heappop(h_end) 25 26 maxa = max(maxa, len(h_end)) 27 28 return maxa "},{"id":53,"href":"/tech-interview-prep/problems/merge-intervals/","title":"Merge intervals","section":"All Problems","content":"Merge intervals# Levels:\u0026ensp;level-3 Data structures:\u0026ensp;array Patterns:\u0026ensp;intervals Practice Link# LeetCode\nDescription# Given a collection of intervals, merge all overlapping intervals. Examples# 1Input: [[1,3],[2,6],[8,10],[15,18]] 2Output: [[1,6],[8,10],[15,18]] 3Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].1Input: [[1,4],[4,5]] 2Output: [[1,5]] 3Explanation: Intervals [1,4] and [4,5] are considered overlapping.Python Solution# 1from typing import List 2 3 4class Solution: 5 def merge(self, intervals: List[List[int]]) -\u0026gt; List[List[int]]: 6 7 intervals.sort(key=lambda x: x[0]) 8 9 merged = [] 10 for interval in intervals: 11 # if the list of merged intervals is empty or if the current 12 # interval does not overlap with the previous, simply append it. 13 if not merged or merged[-1][1] \u0026lt; interval[0]: 14 merged.append(interval) 15 else: 16 # otherwise, there is overlap, so we merge the current and previous 17 # intervals. 18 merged[-1][1] = max(merged[-1][1], interval[1]) 19 20 return merged "},{"id":54,"href":"/tech-interview-prep/problems/merge-k-sorted-lists/","title":"Merge k sorted lists","section":"All Problems","content":"Merge k sorted lists# Levels:\u0026ensp;level-5 Data structures:\u0026ensp;linkedlist,\u0026ensp;heap Algorithms:\u0026ensp;divide-and-conquer Practice Link# LeetCode\nDescription# Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity. Example# 1Input: 2[ 3 1-\u0026gt;4-\u0026gt;5, 4 1-\u0026gt;3-\u0026gt;4, 5 2-\u0026gt;6 6] 7Output: 1-\u0026gt;1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;4-\u0026gt;5-\u0026gt;6Python Solution# 1class ListNode(object): 2 def __init__(self, x): 3 self.val = x 4 self.next = None 5 6 7class Solution(object): 8 # This O(N*log k). Divide and conquer 9 def mergeKLists(self, lists): 10 \u0026#34;\u0026#34;\u0026#34; 11 :type lists: List[ListNode] 12 :rtype: ListNode 13 \u0026#34;\u0026#34;\u0026#34; 14 amount = len(lists) 15 interval = 1 16 while interval \u0026lt; amount: 17 for i in range(0, amount - interval, interval * 2): 18 lists[i] = self.merge2Lists(lists[i], lists[i + interval]) 19 interval *= 2 20 return lists[0] if amount \u0026gt; 0 else lists 21 22 def merge2Lists(self, l1, l2): 23 head = point = ListNode(0) 24 while l1 and l2: 25 if l1.val \u0026lt;= l2.val: 26 point.next = l1 27 l1 = l1.next 28 else: 29 point.next = l2 30 l2 = l1 31 l1 = point.next.next 32 point = point.next 33 if not l1: 34 point.next = l2 35 else: 36 point.next = l1 37 return head.next "},{"id":55,"href":"/tech-interview-prep/problems/make-parentheses-valid/","title":"Minimum Remove To Make Parentheses Valid","section":"All Problems","content":"Minimum Remove To Make Parentheses Valid# Levels:\u0026ensp;level-3 Data structures:\u0026ensp;string,\u0026ensp;stack Patterns:\u0026ensp;mark-and-sweep Practice Link# LeetCode\nDescription# Given a string s containing letters and parentheses '(' and ')', remove the minimum number of parentheses so that the resulting string is valid. Non-parenthesis characters must remain in their original order. Return the resulting valid string. Examples# 1balance(\u0026#34;()\u0026#34;) -\u0026gt; \u0026#34;()\u0026#34; 2balance(\u0026#34;a(b)c)\u0026#34;) -\u0026gt; \u0026#34;a(b)c\u0026#34; 3balance(\u0026#34;)(\u0026#34;) -\u0026gt; \u0026#34;\u0026#34; 4balance(\u0026#34;(((((\u0026#34;) -\u0026gt; \u0026#34;\u0026#34; 5balance(\u0026#34;(()()(\u0026#34;) -\u0026gt; \u0026#34;()()\u0026#34; 6balance(\u0026#34;)(())(\u0026#34;) -\u0026gt; \u0026#34;(())\u0026#34; 7balance(\u0026#34;)())(()()(\u0026#34;) -\u0026gt; \u0026#34;()()()\u0026#34; 8 9balance(\u0026#34;)a(\u0026#34;) -\u0026gt; \u0026#34;a\u0026#34; 10balance(\u0026#34;)a()\u0026#34;) -\u0026gt; \u0026#34;a()\u0026#34; 11balance(\u0026#34;()a(\u0026#34;) -\u0026gt; \u0026#34;()a\u0026#34;Python Solution# 1from typing import List 2 3 4def balance_parentheses(s: str) -\u0026gt; str: 5 \u0026#34;\u0026#34;\u0026#34; 6 Remove the minimum number of parentheses to make the string valid. 7 8 Approach: 9 - Scan once: 10 - push indices of \u0026#39;(\u0026#39; onto stack 11 - when seeing \u0026#39;)\u0026#39;, pop if possible; otherwise mark this \u0026#39;)\u0026#39; as invalid 12 - Any remaining \u0026#39;(\u0026#39; in stack are invalid too 13 - Build result skipping all invalid indices 14 15 Time: O(n) 16 Space: O(n) 17 \u0026#34;\u0026#34;\u0026#34; 18 if not s: 19 return \u0026#34;\u0026#34; 20 21 stack: List[int] = [] 22 invalid = set() 23 24 for i, ch in enumerate(s): 25 if ch == \u0026#39;(\u0026#39;: 26 stack.append(i) 27 elif ch == \u0026#39;)\u0026#39;: 28 if stack: 29 stack.pop() 30 else: 31 invalid.add(i) 32 33 # Unmatched \u0026#39;(\u0026#39; are invalid 34 invalid.update(stack) 35 36 # Rebuild string 37 out = [] 38 for i, ch in enumerate(s): 39 if i not in invalid: 40 out.append(ch) 41 return \u0026#34;\u0026#34;.join(out) "},{"id":56,"href":"/tech-interview-prep/problems/minimum-window-substring/","title":"Minimum window substring","section":"All Problems","content":"Minimum window substring# Levels:\u0026ensp;level-5 Data structures:\u0026ensp;string,\u0026ensp;hash-table Patterns:\u0026ensp;sliding-window Practice Link# LeetCode\nDescription# Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n). Note:\nIf there is no such window in S that covers all characters in T, return the empty string \u0026ldquo;\u0026rdquo;. If there is such window, you are guaranteed that there will always be only one unique minimum window in S. Example# 1Input: S = \u0026#34;ADOBECODEBANC\u0026#34;, T = \u0026#34;ABC\u0026#34; 2Output: \u0026#34;BANC\u0026#34;Thinking# Can this have a sliding window based approach? Python Solution# 1from collections import Counter 2 3 4class Solution(object): 5 def minWindow(self, s, t): 6 \u0026#34;\u0026#34;\u0026#34; 7 :type s: str 8 :type t: str 9 :rtype: str 10 \u0026#34;\u0026#34;\u0026#34; 11 12 if not t or not s: 13 return \u0026#34;\u0026#34; 14 15 # Dictionary which keeps a count of all the unique characters in t. 16 dict_t = Counter(t) 17 18 # Number of unique characters in t, which need to be present in the desired window. 19 required = len(dict_t) 20 21 # left and right pointer 22 l, r = 0, 0 23 24 # formed is used to keep track of how many unique characters in t are present in the current window in its desired frequency. 25 # e.g. if t is \u0026#34;AABC\u0026#34; then the window must have two A\u0026#39;s, one B and one C. Thus formed would be = 3 when all these conditions are met. 26 formed = 0 27 28 # Dictionary which keeps a count of all the unique characters in the current window. 29 window_counts = {} 30 31 # ans tuple of the form (window length, left, right) 32 ans = float(\u0026#34;inf\u0026#34;), None, None 33 34 while r \u0026lt; len(s): 35 36 # Add one character from the right to the window 37 character = s[r] 38 window_counts[character] = window_counts.get(character, 0) + 1 39 40 # If the frequency of the current character added equals to the desired count in t then increment the formed count by 1. 41 if character in dict_t and window_counts[character] == dict_t[ 42 character]: 43 formed += 1 44 45 # Try and contract the window till the point where it ceases to be \u0026#39;desirable\u0026#39;. 46 while l \u0026lt;= r and formed == required: 47 character = s[l] 48 49 # Save the smallest window until now. 50 if r - l + 1 \u0026lt; ans[0]: 51 ans = (r - l + 1, l, r) 52 53 # The character at the position pointed by the `left` pointer is no longer a part of the window. 54 window_counts[character] -= 1 55 if character in dict_t and window_counts[character] \u0026lt; dict_t[ 56 character]: 57 formed -= 1 58 59 # Move the left pointer ahead, this would help to look for a new window. 60 l += 1 61 62 # Keep expanding the window once we are done contracting. 63 r += 1 64 return \u0026#34;\u0026#34; if ans[0] == float(\u0026#34;inf\u0026#34;) else s[ans[1]:ans[2] + 1] "},{"id":57,"href":"/tech-interview-prep/problems/missing-number/","title":"Missing number","section":"All Problems","content":"Missing number# Levels:\u0026ensp;level-2 Data structures:\u0026ensp;bits,\u0026ensp;array Practice Link# LeetCode\nDescription# Given an array containing n distinct numbers taken from 0, 1, 2, \u0026hellip;, n, find the one that is missing from the array. Note:\nYour algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity? Examples# 1Input: [3,0,1] 2Output: 21Input: [9,6,4,2,3,5,7,0,1] 2Output: 8Thinking# We can harness the fact that XOR is its own inverse to find the missing element in linear time. Because we know that nums contains n numbers and that it is missing exactly one number on the range [0..n-1][0..n−1], we know that nn definitely replaces the missing number in nums. Therefore, if we initialize an integer to nn and XOR it with every index and value, we will be left with the missing number. Python Solution# 1class Solution: 2 def missingNumber(self, nums): 3 missing = len(nums) 4 for i, num in enumerate(nums): 5 missing ^= i ^ num 6 return missing "},{"id":58,"href":"/tech-interview-prep/problems/non-overlapping-intervals/","title":"Non overlapping intervals","section":"All Problems","content":"Non overlapping intervals# Levels:\u0026ensp;level-4 Data structures:\u0026ensp;array Algorithms:\u0026ensp;greedy Patterns:\u0026ensp;intervals Practice Link# LeetCode\nDescription# Given a collection of intervals, find the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping. Note:\nYou may assume the interval\u0026rsquo;s end point is always bigger than its start point. Intervals like [1,2] and [2,3] have borders \u0026ldquo;touching\u0026rdquo; but they don\u0026rsquo;t overlap each other. Examples# 1Input: [[1,2],[2,3],[3,4],[1,3]] 2Output: 1 3Explanation: [1,3] can be removed and the rest of intervals are non-overlapping.1Input: [[1,2],[1,2],[1,2]] 2Output: 2 3Explanation: You need to remove two [1,2] to make the rest of intervals non-overlapping.1Input: [[1,2],[2,3]] 2Output: 0 3Explanation: You don\u0026#39;t need to remove any of the intervals since they\u0026#39;re already non-overlapping.Python Solution# 1class Solution(object): 2 def eraseOverlapIntervals(self, intervals): 3 \u0026#34;\u0026#34;\u0026#34; 4 :type intervals: List[List[int]] 5 :rtype: int 6 \u0026#34;\u0026#34;\u0026#34; 7 end = float(\u0026#39;-inf\u0026#39;) 8 erased = 0 9 for i in sorted(intervals, key=lambda i: i.end): 10 if i.start \u0026gt;= end: 11 end = i.end 12 else: 13 erased += 1 14 return erased "},{"id":59,"href":"/tech-interview-prep/problems/number-of-1-bits/","title":"Number of 1 bits","section":"All Problems","content":"Number of 1 bits# Levels:\u0026ensp;level-1 Data structures:\u0026ensp;bits Practice Link# LeetCode\nDescription# Write a function that takes an unsigned integer and return the number of \u0026lsquo;1\u0026rsquo; bits it has (also known as the Hamming weight). Example# 1Input: 00000000000000000000000000001011 2Output: 3 3Explanation: The input binary string 00000000000000000000000000001011 has a total of three \u0026#39;1\u0026#39; bits.Python Solution# 1class Solution(object): 2 # Use inbuilt functions 3 def hammingWeightBuiltin(self, n): 4 \u0026#34;\u0026#34;\u0026#34; 5 :type n: int 6 :rtype: int 7 \u0026#34;\u0026#34;\u0026#34; 8 return bin(n).count(\u0026#39;1\u0026#39;) 9 10 # Using bit operation to cancel a 1 in each round 11 # Think of a number in binary `n = XXXXXX1000, n - 1 is XXXXXX0111`. 12 # `n \u0026amp; (n - 1)` will be `XXXXXX0000` which just canceled the last `1` 13 def hammingWeightBitwise(self, n): 14 \u0026#34;\u0026#34;\u0026#34; 15 :type n: int 16 :rtype: int 17 \u0026#34;\u0026#34;\u0026#34; 18 c = 0 19 while n: 20 n \u0026amp;= n - 1 21 c += 1 22 return c "},{"id":60,"href":"/tech-interview-prep/problems/number-of-connected-components-in-an-undirected-graph/","title":"Number of connected components in an undirected graph","section":"All Problems","content":"Number of connected components in an undirected graph# Levels:\u0026ensp;level-5 Data structures:\u0026ensp;graph Description# Given n nodes labeled from 0 to n - 1 and a list of undirected edges (each edge is a pair of nodes), write a function to find the number of connected components in an undirected graph. Note:\nYou can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0, 1] is the same as [1, 0] and thus will not appear together in edges. Examples# 1 2 0 3 3 | | 4 1 --- 2 4 5 6Given n = 5 and edges = [[0, 1], [1, 2], [3, 4]], return 2.1 0 4 2 | | 3 1 --- 2 --- 3 4 5Given n = 5 and edges = [[0, 1], [1, 2], [2, 3], [3, 4]], return 1.Python Solution# 1class Solution(object): 2 def countComponents(self, n, edges): 3 \u0026#34;\u0026#34;\u0026#34; 4 :type n: int 5 :type edges: List[List[int]] 6 :rtype: int 7 \u0026#34;\u0026#34;\u0026#34; 8 V = [[] for _ in range(n)] 9 for e in edges: 10 V[e[0]].append(e[1]) 11 V[e[1]].append(e[0]) 12 13 visited = [False for _ in range(n)] 14 cnt = 0 15 for v in range(n): 16 if not visited[v]: 17 cnt += 1 18 self.dfs(V, v, visited) 19 20 return cnt 21 22 def dfs(self, V, v, visited): 23 visited[v] = True 24 for nbr in V[v]: 25 if not visited[nbr]: 26 self.dfs(V, nbr, visited) "},{"id":61,"href":"/tech-interview-prep/problems/number-of-islands/","title":"Number of islands","section":"All Problems","content":"Number of islands# Levels:\u0026ensp;level-4 Data structures:\u0026ensp;graph Algorithms:\u0026ensp;dfs,\u0026ensp;bfs Patterns:\u0026ensp;union-find Practice Link# LeetCode\nDescription# Given a 2d grid map of \u0026lsquo;1\u0026rsquo;s (land) and \u0026lsquo;0\u0026rsquo;s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. Examples# 1Input: 211110 311010 411000 500000 6Output: 11Input: 211000 311000 400100 500011 6Output: 3Python Solution# 1class Solution(object): 2 # Iterate through each of the cell and if it is an island, 3 # do dfs to mark all adjacent islands, 4 # then increase the counter by 1. 5 def numIslands(self, grid): 6 if not grid: 7 return 0 8 9 count = 0 10 for i in range(len(grid)): 11 for j in range(len(grid[0])): 12 if grid[i][j] == \u0026#39;1\u0026#39;: 13 self.dfs(grid, i, j) 14 count += 1 15 return count 16 17 def dfs(self, grid, i, j): 18 if i \u0026lt; 0 or j \u0026lt; 0 or i \u0026gt;= len(grid) or j \u0026gt;= len( 19 grid[0]) or grid[i][j] != \u0026#39;1\u0026#39;: 20 return 21 grid[i][j] = \u0026#39;#\u0026#39; 22 self.dfs(grid, i + 1, j) 23 self.dfs(grid, i - 1, j) 24 self.dfs(grid, i, j + 1) 25 self.dfs(grid, i, j - 1) "},{"id":62,"href":"/tech-interview-prep/problems/pacific-atlantic-water-flow/","title":"Pacific-Atlantic water flow","section":"All Problems","content":"Pacific-Atlantic water flow# Levels:\u0026ensp;level-4 Data structures:\u0026ensp;graph Algorithms:\u0026ensp;dfs,\u0026ensp;bfs Practice Link# LeetCode\nDescription# Given an m x n matrix of non-negative integers representing the height of each unit cell in a continent, the \u0026ldquo;Pacific ocean\u0026rdquo; touches the left and top edges of the matrix and the \u0026ldquo;Atlantic ocean\u0026rdquo; touches the right and bottom edges. Water can only flow in four directions (up, down, left, or right) from a cell to another one with height equal or lower. Find the list of grid coordinates where water can flow to both the Pacific and Atlantic ocean. Note:\nThe order of returned grid coordinates does not matter. Both m and n are less than 150. Example# 1Input: 2 Pacific ~ ~ ~ ~ ~ 3 ~ 1 2 2 3 (5) * 4 ~ 3 2 3 (4) (4) * 5 ~ 2 4 (5) 3 1 * 6 ~ (6) (7) 1 4 5 * 7 ~ (5) 1 1 2 4 * 8 * * * * * Atlantic 9Output: 10[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] 11(positions with parentheses in above matrix).Python Solution# 1class Solution(object): 2 def pacificAtlantic(self, matrix): 3 \u0026#34;\u0026#34;\u0026#34; 4 :type matrix: List[List[int]] 5 :rtype: List[List[int]] 6 \u0026#34;\u0026#34;\u0026#34; 7 if not matrix: return [] 8 self.directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] 9 m = len(matrix) 10 n = len(matrix[0]) 11 p_visited = [[False for _ in range(n)] for _ in range(m)] 12 13 a_visited = [[False for _ in range(n)] for _ in range(m)] 14 result = [] 15 16 for i in range(m): 17 # p_visited[i][0] = True 18 # a_visited[i][n-1] = True 19 self.dfs(matrix, i, 0, p_visited, m, n) 20 self.dfs(matrix, i, n - 1, a_visited, m, n) 21 for j in range(n): 22 # p_visited[0][j] = True 23 # a_visited[m-1][j] = True 24 self.dfs(matrix, 0, j, p_visited, m, n) 25 self.dfs(matrix, m - 1, j, a_visited, m, n) 26 27 for i in range(m): 28 for j in range(n): 29 if p_visited[i][j] and a_visited[i][j]: 30 result.append([i, j]) 31 return result 32 33 def dfs(self, matrix, i, j, visited, m, n): 34 # when dfs called, meaning its caller already verified this point 35 visited[i][j] = True 36 for dir in self.directions: 37 x, y = i + dir[0], j + dir[1] 38 if x \u0026lt; 0 or x \u0026gt;= m or y \u0026lt; 0 or y \u0026gt;= n or visited[x][ 39 y] or matrix[x][y] \u0026lt; matrix[i][j]: 40 continue 41 self.dfs(matrix, x, y, visited, m, n) "},{"id":63,"href":"/tech-interview-prep/problems/palindromic-substrings/","title":"Palindromic substrings","section":"All Problems","content":"Palindromic substrings# Levels:\u0026ensp;level-4 Data structures:\u0026ensp;string Algorithms:\u0026ensp;dynamic-programming Practice Link# LeetCode\nDescription# Given a string, your task is to count how many palindromic substrings in this string. The substrings with different start indexes or end indexes are counted as different substrings even they consist of same characters. Note:\nThe input string length won\u0026rsquo;t exceed 1000. Examples# 1Input: \u0026#34;abc\u0026#34; 2Output: 3 3Explanation: Three palindromic strings: \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;.1Input: \u0026#34;aaa\u0026#34; 2Output: 6 3Explanation: Six palindromic strings: \u0026#34;a\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;aa\u0026#34;, \u0026#34;aa\u0026#34;, \u0026#34;aaa\u0026#34;.Python Solution# 1class Solution(object): 2 # Let N be the length of the string. The middle of the palindrome could be in one of 2N - 1 positions: either at letter or between two letters. 3 # For each center, let\u0026#39;s count all the palindromes that have this center. Notice that if [a, b] is a palindromic interval (meaning S[a], S[a+1], ..., S[b] is a palindrome), then [a+1, b-1] is one too. 4 # Algorithm 5 # For each possible palindrome center, 6 # let\u0026#39;s expand our candidate palindrome on the interval [left, right] as long as we can. 7 # The condition for expanding is left \u0026gt;= 0 and right \u0026lt; N and S[left] == S[right]. 8 # That means we want to count a new palindrome S[left], S[left+1], ..., S[right]. 9 def countSubstrings(self, S): 10 N = len(S) 11 ans = 0 12 for center in range(2 * N - 1): 13 left = center / 2 14 right = left + center % 2 15 while left \u0026gt;= 0 and right \u0026lt; N and S[left] == S[right]: 16 ans += 1 17 left -= 1 18 right += 1 19 return ans "},{"id":64,"href":"/tech-interview-prep/problems/product-of-array-except-self/","title":"Product of array except self","section":"All Problems","content":"Product of array except self# Levels:\u0026ensp;level-3 Data structures:\u0026ensp;array Practice Link# LeetCode\nDescription# Given an array nums of n integers where n \u0026gt; 1, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i]. Note:\nPlease solve it without division and in O(n). Python Solution# 1class Solution(object): 2 def productExceptSelf(self, nums): 3 \u0026#34;\u0026#34;\u0026#34; 4 :type nums: List[int] 5 :rtype: List[int] 6 \u0026#34;\u0026#34;\u0026#34; 7 out = [1 for idx in range(len(nums))] 8 for idx, _ in enumerate(nums): 9 outp = 1 10 for jdx, n in enumerate(nums): 11 if idx != jdx: 12 outp *= n 13 out[idx] = outp 14 return out 15 16 17class Solution2(object): 18 def productExceptSelf(self, nums): 19 20 # The length of the input array 21 length = len(nums) 22 23 # The left and right arrays as described in the algorithm 24 L, R, answer = [0] * length, [0] * length, [0] * length 25 26 # L[i] contains the product of all the elements to the left 27 # Note: for the element at index \u0026#39;0\u0026#39;, there are no elements to the left, 28 # so the L[0] would be 1 29 L[0] = 1 30 for i in range(1, length): 31 32 # L[i - 1] already contains the product of elements to the left of \u0026#39;i - 1\u0026#39; 33 # Simply multiplying it with nums[i - 1] would give the product of all 34 # elements to the left of index \u0026#39;i\u0026#39; 35 L[i] = nums[i - 1] * L[i - 1] 36 37 # R[i] contains the product of all the elements to the right 38 # Note: for the element at index \u0026#39;length - 1\u0026#39;, there are no elements to the right, 39 # so the R[length - 1] would be 1 40 R[length - 1] = 1 41 for i in reversed(range(length - 1)): 42 43 # R[i + 1] already contains the product of elements to the right of \u0026#39;i + 1\u0026#39; 44 # Simply multiplying it with nums[i + 1] would give the product of all 45 # elements to the right of index \u0026#39;i\u0026#39; 46 R[i] = nums[i + 1] * R[i + 1] 47 48 # Constructing the answer array 49 for i in range(length): 50 # For the first element, R[i] would be product except self 51 # For the last element of the array, product except self would be L[i] 52 # Else, multiple product of all elements to the left and to the right 53 answer[i] = L[i] * R[i] 54 55 return answer 56 57 58in_arrs = [ 59 [2, 1, 2, 1, 0, 1, 2], 60 [3, 3, 5, 0, 0, 3, 1, 4], 61 [3, 5, 0, 1, 4], 62 [1, 2, 3, 1], 63 [1, 2, 3, 4], 64 [1, 1, 1, 3, 3, 4, 3, 2, 4, 2], 65] 66if __name__ == \u0026#34;__main__\u0026#34;: 67 68 sol = Solution2() 69 for nin in in_arrs: 70 r = sol.productExceptSelf(nin) 71 print(r) "},{"id":65,"href":"/tech-interview-prep/problems/remove-nth-node-from-end-of-list/","title":"Remove n'th node from end of list","section":"All Problems","content":"Remove n\u0026rsquo;th node from end of list# Levels:\u0026ensp;level-3 Data structures:\u0026ensp;linkedlist Practice Link# LeetCode\nDescription# Given a linked list, remove the n-th node from the end of list and return its head. Note:\nGiven n will always be valid. Example# 1Given linked list: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5, and n = 2. 2After removing the second node from the end, the linked list becomes 1-\u0026gt;2-\u0026gt;3-\u0026gt;5.Follow up:\nCould you do this in one pass? Python Solution# 1class ListNode(object): 2 def __init__(self, x): 3 self.val = x 4 self.next = None 5 6 7class Solution: 8 def removeNthFromEnd(self, head, n): 9 if not head: 10 return 11 fast = slow = head 12 for _ in range(n): 13 if not fast.next: 14 raise Exception(\u0026#34;less than n nodes found\u0026#34;) 15 fast = fast.next 16 if not fast: 17 return head.next 18 while fast.next: 19 fast = fast.next 20 slow = slow.next 21 slow.next = slow.next.next 22 return head "},{"id":66,"href":"/tech-interview-prep/problems/reorder-list/","title":"Reorder list","section":"All Problems","content":"Reorder list# Levels:\u0026ensp;level-3 Data structures:\u0026ensp;linkedlist Practice Link# LeetCode\nDescription# Given a singly linked list L: L0→L1→…→Ln-1→Ln, reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→… You may not modify the values in the list\u0026rsquo;s nodes, only nodes itself may be changed. Examples# 1Given 1-\u0026gt;2-\u0026gt;3-\u0026gt;4, reorder it to 1-\u0026gt;4-\u0026gt;2-\u0026gt;3.1Given 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5, reorder it to 1-\u0026gt;5-\u0026gt;2-\u0026gt;4-\u0026gt;3.Python Solution# 1class ListNode(object): 2 def __init__(self, x): 3 self.val = x 4 self.next = None 5 6 7class Solution(object): 8 def reorderList(self, head): 9 \u0026#34;\u0026#34;\u0026#34; 10 :type head: ListNode 11 :rtype: None Do not return anything, modify head in-place instead. 12 \u0026#34;\u0026#34;\u0026#34; 13 if not head: 14 return 15 16 # find the mid point 17 slow = fast = head 18 while fast and fast.next: 19 slow = slow.next 20 fast = fast.next.next 21 22 # reverse the second half in-place 23 pre, node = None, slow 24 while node: 25 pre, node.next, node = node, pre, node.next 26 27 # Merge in-place; Note : the last node of \u0026#34;first\u0026#34; and \u0026#34;second\u0026#34; are the same 28 first, second = head, pre 29 while second.next: 30 first.next, first = second, first.next 31 second.next, second = first, second.next 32 return "},{"id":67,"href":"/tech-interview-prep/problems/reverse-bits/","title":"Reverse bits","section":"All Problems","content":"Reverse bits# Levels:\u0026ensp;level-2 Data structures:\u0026ensp;bits Practice Link# LeetCode\nDescription# Reverse bits of a given 32 bits unsigned integer. Example# 1Input: 00000010100101000001111010011100 2Output: 00111001011110000010100101000000 3Explanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000.Follow up# If this function is called many times, how would you optimize it? Thinking# We first intitialize result to 0. We then iterate from 0 to 31 (an integer has 32 bits). In each iteration: We first shift result to the left by 1 bit. Then, if the last digit of input n is 1, we add 1 to result. To find the last digit of n, we just do: (n \u0026amp; 1) Example, if n=5 (101), n\u0026amp;1 = 101 \u0026amp; 001 = 001 = 1; however, if n = 2 (10), n\u0026amp;1 = 10 \u0026amp; 01 = 00 = 0). Finally, we update n by shifting it to the right by 1 (n \u0026raquo;= 1). This is because the last digit is already taken care of, so we need to drop it by shifting n to the right by 1. At the end of the iteration, we return result. Python Solution# 1class Solution: 2 # @param n, an integer 3 # @return an integer 4 def reverseBits(self, n): 5 res = 0 6 for _ in range(32): 7 res = (res \u0026lt;\u0026lt; 1) + (n \u0026amp; 1) 8 n \u0026gt;\u0026gt;= 1 9 return res 10 11 # Use bit hacks to directly do in O(1) 12 # for 8 bit binary number abcdefgh, the process is as follow: 13 # abcdefgh -\u0026gt; efghabcd -\u0026gt; ghefcdab -\u0026gt; hgfedcba 14 def reverseBitsHack(self, n): 15 n = (n \u0026gt;\u0026gt; 16) | (n \u0026lt;\u0026lt; 16) 16 n = ((n \u0026amp; 0xff00ff00) \u0026gt;\u0026gt; 8) | ((n \u0026amp; 0x00ff00ff) \u0026lt;\u0026lt; 8) 17 n = ((n \u0026amp; 0xf0f0f0f0) \u0026gt;\u0026gt; 4) | ((n \u0026amp; 0x0f0f0f0f) \u0026lt;\u0026lt; 4) 18 n = ((n \u0026amp; 0xcccccccc) \u0026gt;\u0026gt; 2) | ((n \u0026amp; 0x33333333) \u0026lt;\u0026lt; 2) 19 n = ((n \u0026amp; 0xaaaaaaaa) \u0026gt;\u0026gt; 1) | ((n \u0026amp; 0x55555555) \u0026lt;\u0026lt; 1) 20 return n "},{"id":68,"href":"/tech-interview-prep/problems/reverse-linked-list/","title":"Reverse linked list","section":"All Problems","content":"Reverse linked list# Levels:\u0026ensp;level-1 Data structures:\u0026ensp;linkedlist Practice Link# LeetCode\nDescription# Reverse a singly linked list. Example# 1Input: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5-\u0026gt;NULL 2Output: 5-\u0026gt;4-\u0026gt;3-\u0026gt;2-\u0026gt;1-\u0026gt;NULLFollow up# A linked list can be reversed either iteratively or recursively. Could you implement both? Python Solution# 1class ListNode(object): 2 def __init__(self, x): 3 self.val = x 4 self.next = None 5 6 7class Solution(object): 8 def reverseList(self, head): # Iterative 9 prev, curr = None, head 10 while curr: 11 curr.next, prev, curr = prev, curr, curr.next 12 return prev 13 14 def reverseList_v1(self, head): # Recursive 15 \u0026#34;\u0026#34;\u0026#34; 16 :type head: ListNode 17 :rtype: ListNode 18 \u0026#34;\u0026#34;\u0026#34; 19 if not head or not head.next: 20 return head 21 p = self.reverseList_v1(head.next) 22 head.next.next = head 23 head.next = None 24 return p "},{"id":69,"href":"/tech-interview-prep/problems/rotate-image/","title":"Rotate image","section":"All Problems","content":"Rotate image# Levels:\u0026ensp;level-3 Data structures:\u0026ensp;array Practice Link# LeetCode\nDescription# You are given an n x n 2D matrix representing an image. Rotate the image by 90 degrees (clockwise). Note:\nYou have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation. Examples# 1Given input matrix = 2[ 3 [1,2,3], 4 [4,5,6], 5 [7,8,9] 6], 7 8rotate the input matrix in-place such that it becomes: 9[ 10 [7,4,1], 11 [8,5,2], 12 [9,6,3] 13] 1Given input matrix = 2[ 3 [ 5, 1, 9,11], 4 [ 2, 4, 8,10], 5 [13, 3, 6, 7], 6 [15,14,12,16] 7], 8 9rotate the input matrix in-place such that it becomes: 10[ 11 [15,13, 2, 5], 12 [14, 3, 4, 1], 13 [12, 6, 8, 9], 14 [16, 7,10,11] 15]Python Solution# 1class Solution(object): 2 # Pythonic with extended slices and zip syntax 3 def rotate(self, A): 4 \u0026#34;\u0026#34;\u0026#34; 5 :type matrix: List[List[int]] 6 :rtype: None Do not return anything, modify matrix in-place instead. 7 \u0026#34;\u0026#34;\u0026#34; 8 A[:] = list(zip(*A[::-1])) 9 10 # first transpose and then flip left-right 11 def rotateManual(self, A): 12 n = len(A) 13 for i in range(n): 14 for j in range(i): 15 A[i][j], A[j][i] = A[j][i], A[i][j] 16 for row in A: 17 for j in range(n / 2): 18 row[j], row[~j] = row[~j], row[j] "},{"id":70,"href":"/tech-interview-prep/problems/same-tree/","title":"Same tree","section":"All Problems","content":"Same tree# Levels:\u0026ensp;level-2 Data structures:\u0026ensp;tree Algorithms:\u0026ensp;dfs Practice Link# LeetCode\nDescription# Given two binary trees, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical and the nodes have the same value. Examples# 1Input: 1 1 2 / \\ / \\ 3 2 3 2 3 4 5 [1,2,3], [1,2,3] 6 7Output: true1Input: 1 1 2 / \\ 3 2 2 4 5 [1,2], [1,null,2] 6 7Output: falsePython Solution# 1from collections import deque 2 3 4class TreeNode(object): 5 def __init__(self, x): 6 self.val = x 7 self.left = None 8 self.right = None 9 10 11class Solution: 12 # Recursive solution 13 def isSameTree(self, p, q): 14 \u0026#34;\u0026#34;\u0026#34; 15 :type p: TreeNode 16 :type q: TreeNode 17 :rtype: bool 18 \u0026#34;\u0026#34;\u0026#34; 19 # p and q are both None 20 if not p and not q: 21 return True 22 # one of p and q is None 23 if not q or not p: 24 return False 25 if p.val != q.val: 26 return False 27 return self.isSameTree(p.right, q.right) and \\ 28 self.isSameTree(p.left, q.left) 29 30 # Iterative solution 31 def isSameTreeIterative(self, p, q): 32 \u0026#34;\u0026#34;\u0026#34; 33 :type p: TreeNode 34 :type q: TreeNode 35 :rtype: bool 36 \u0026#34;\u0026#34;\u0026#34; 37 def check(p, q): 38 # if both are None 39 if not p and not q: 40 return True 41 # one of p and q is None 42 if not q or not p: 43 return False 44 if p.val != q.val: 45 return False 46 return True 47 48 deq = deque([ 49 (p, q), 50 ]) 51 while deq: 52 p, q = deq.popleft() 53 if not check(p, q): 54 return False 55 56 if p: 57 deq.append((p.left, q.left)) 58 deq.append((p.right, q.right)) 59 60 return True "},{"id":71,"href":"/tech-interview-prep/problems/search-in-rotated-sorted-array/","title":"Search in rotated sorted array","section":"All Problems","content":"Search in rotated sorted array# Levels:\u0026ensp;level-3 Data structures:\u0026ensp;array Algorithms:\u0026ensp;binary-search Practice Link# LeetCode\nDescription# Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). You are given a target value to search. If found in the array return its index, otherwise return -1. You may assume no duplicate exists in the array. Your algorithm\u0026rsquo;s runtime complexity must be in the order of O(log n). Python Solution# 1class Solution(object): 2 def search(self, nums, target): 3 \u0026#34;\u0026#34;\u0026#34; 4 :type nums: List[int] 5 :type target: int 6 :rtype: int 7 \u0026#34;\u0026#34;\u0026#34; 8 if not nums: 9 return -1 10 return self.__search(nums, 0, len(nums) - 1, target) 11 12 def __binsearch(self, nums, i, j, target): 13 if i == j: 14 if nums[i] == target: 15 return i 16 return -1 17 18 if i + 1 == j: 19 if nums[i] == target: 20 return i 21 if nums[j] == target: 22 return j 23 return -1 24 25 mid = int((i + j) / 2) 26 if nums[mid] \u0026lt; target: 27 return self.__binsearch(nums, mid, j, target) 28 return self.__binsearch(nums, i, mid, target) 29 30 def __search(self, nums, i, j, target): 31 if i == j: 32 if nums[i] == target: 33 return i 34 return -1 35 36 if i + 1 == j: 37 if nums[i] == target: 38 return i 39 if nums[j] == target: 40 return j 41 return -1 42 43 if nums[i] \u0026lt; nums[j]: 44 return self.__binsearch(nums, i, j, target) 45 46 mid = int((i + j) / 2) 47 if nums[i] \u0026lt; nums[mid]: 48 if (target \u0026lt;= nums[mid]) and (target \u0026gt;= nums[i]): 49 return self.__binsearch(nums, i, mid, target) 50 return self.__search(nums, mid, j, target) 51 if (target \u0026gt;= nums[mid]) and (target \u0026lt;= nums[j]): 52 return self.__binsearch(nums, mid, j, target) 53 return self.__search(nums, i, mid, target) 54 55 56class Solution2(object): 57 def find_min_index(self, nums): 58 \u0026#34;\u0026#34;\u0026#34; 59 :type nums: List[int] 60 :rtype: int 61 \u0026#34;\u0026#34;\u0026#34; 62 if not nums: 63 return None 64 lo = 0 65 hi = len(nums) - 1 66 while lo \u0026lt; hi: 67 mid = (lo + hi) / 2 68 if (nums[mid] \u0026gt; nums[hi]): 69 lo = mid + 1 70 else: 71 hi = mid 72 return lo 73 74 def search(self, nums, target): 75 \u0026#34;\u0026#34;\u0026#34; 76 :type nums: List[int] 77 :type target: int 78 :rtype: int 79 \u0026#34;\u0026#34;\u0026#34; 80 if not nums: 81 return -1 82 rot_index = self.find_min_index(nums) 83 hi = len(nums) - 1 84 if rot_index == 0: 85 return self.__binsearch(nums, rot_index, hi, target) 86 if target \u0026gt;= nums[rot_index] and target \u0026lt;= nums[hi]: 87 return self.__binsearch(nums, rot_index, hi, target) 88 return self.__binsearch(nums, 0, rot_index - 1, target) 89 90 def __binsearch(self, nums, i, j, target): 91 if i \u0026gt; j: 92 return -1 93 if i == j: 94 if nums[i] == target: 95 return i 96 return -1 97 98 if i + 1 == j: 99 if nums[i] == target: 100 return i 101 if nums[j] == target: 102 return j 103 return -1 104 105 mid = int((i + j) / 2) 106 if nums[mid] \u0026lt; target: 107 return self.__binsearch(nums, mid, j, target) 108 return self.__binsearch(nums, i, mid, target) 109 110 111in_arrs = [ 112 ([3, 4, 5, 1, 2], 4), 113 ([4, 5, 6, 7, 0, 1, 2], 1), 114 ([8, 1, 2, 3], 3), 115 ([1, 2, 3, 4], 5), 116 ([1], 1), 117 ([], 1), 118 (None, 1), 119 ([5, 1, 3, 4], 5), 120 ([8, 1, 2, 3], 1), 121 ([1, 2, 3, 4], 4), 122 ([1, 2, 3, 4], 1), 123 ([1], 0), 124] 125 126exp_out = [ 127 1, 128 5, 129 3, 130 -1, 131 0, 132 -1, 133 -1, 134 0, 135 1, 136 3, 137 0, 138 -1, 139] 140 141if __name__ == \u0026#34;__main__\u0026#34;: 142 143 sol = Solution() 144 sol2 = Solution() 145 for idx, nin in enumerate(in_arrs): 146 r = sol.search(nin[0], nin[1]) 147 print(exp_out[idx] == r, r) 148 r = sol2.search(nin[0], nin[1]) 149 print(exp_out[idx] == r, r) "},{"id":72,"href":"/tech-interview-prep/problems/serialize-and-deserialize-binary-tree/","title":"Serialize and deserialize a binary tree","section":"All Problems","content":"Serialize and deserialize a binary tree# Levels:\u0026ensp;level-5 Data structures:\u0026ensp;tree Practice Link# LeetCode\nDescription# Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure. Note:\nDo not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless. Clarification:\nThe below format is the same as how LeetCode serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself. Example# 1You may serialize the following tree: 2 1 3 / \\ 4 2 3 5 / \\ 6 4 5 7 8as \u0026#34;[1,2,3,null,null,4,5]\u0026#34;Python Solution# 1# Definition for a binary tree node. 2class TreeNode(object): 3 def __init__(self, x): 4 self.val = x 5 self.left = None 6 self.right = None 7 8 9class Codec: 10 def serialize(self, root): 11 \u0026#34;\u0026#34;\u0026#34;Encodes a tree to a single string. 12 13 :type root: TreeNode 14 :rtype: str 15 \u0026#34;\u0026#34;\u0026#34; 16 def doit(node): 17 if node: 18 vals.append(str(node.val)) 19 doit(node.left) 20 doit(node.right) 21 else: 22 vals.append(\u0026#39;#\u0026#39;) 23 24 vals = [] 25 doit(root) 26 return \u0026#39; \u0026#39;.join(vals) 27 28 def deserialize(self, data): 29 \u0026#34;\u0026#34;\u0026#34;Decodes your encoded data to tree. 30 31 :type data: str 32 :rtype: TreeNode 33 \u0026#34;\u0026#34;\u0026#34; 34 def doit(): 35 val = next(vals) 36 if val == \u0026#39;#\u0026#39;: 37 return None 38 node = TreeNode(int(val)) 39 node.left = doit() 40 node.right = doit() 41 return node 42 43 vals = iter(data.split()) 44 return doit() 45 46 47# codec = Codec() 48# codec.deserialize(codec.serialize(root)) "},{"id":73,"href":"/tech-interview-prep/problems/set-card-game-validate-find/","title":"SET Card Game - Validate Set And Find Set","section":"All Problems","content":"SET Card Game - Validate Set And Find Set# Levels:\u0026ensp;level-4 Data structures:\u0026ensp;array,\u0026ensp;hash-table Patterns:\u0026ensp;hashing Practice Link# No single canonical LeetCode problem; this is a common interview / game-math problem. Description# Each card has k attributes (in the classic game, k = 4), each taking one of 3 values, typically encoded as 0/1/2. Three cards form a valid set if for every attribute: the values are all the same, OR the values are all different Tasks: is_set(cards3) -\u0026gt; bool: given exactly 3 cards, return whether they form a set find_set(cards) -\u0026gt; list[card]: given a list of cards, return any one set (3 cards), else [] Examples# 1(1,0,1,2) 2(1,2,0,2) 3(1,1,2,1) 4-\u0026gt; True1(1,0,1,2) 2(1,0,1,2) 3(1,0,1,2) 4-\u0026gt; True (all attributes all same)Python Solution# 1from collections import Counter 2from typing import List, Sequence, Tuple 3 4Card = Tuple[int, ...] # e.g. (1,0,1,2) 5 6def is_set(cards: Sequence[Card]) -\u0026gt; bool: 7 \u0026#34;\u0026#34;\u0026#34; 8 Check whether exactly 3 cards form a valid Set. 9 10 Condition per attribute i: 11 len({c1[i], c2[i], c3[i]}) in {1, 3} 12 13 Time: O(k) 14 Space: O(1) 15 \u0026#34;\u0026#34;\u0026#34; 16 if len(cards) != 3: 17 return False 18 a, b, c = cards 19 if len(a) != len(b) or len(b) != len(c): 20 return False 21 22 k = len(a) 23 for i in range(k): 24 vals = {a[i], b[i], c[i]} 25 if len(vals) not in (1, 3): 26 return False 27 return True 28 29def _third_value_mod3(x: int, y: int) -\u0026gt; int: 30 \u0026#34;\u0026#34;\u0026#34; 31 Values are in {0,1,2}. 32 If x==y then third must be same. 33 Else third is the remaining value: 0+1+2 - x - y 34 \u0026#34;\u0026#34;\u0026#34; 35 return x if x == y else (3 - x - y) 36 37def find_any_set(cards: List[Card]) -\u0026gt; List[Card]: 38 \u0026#34;\u0026#34;\u0026#34; 39 Find any set among the given cards (returns the 3 cards), else []. 40 41 Efficient approach (classic SET trick): 42 For any two cards A and B, the required third card C is uniquely determined 43 attribute-wise (in mod 3 encoding). 44 45 Handles duplicates by using counts. 46 47 Time: O(n^2 * k) 48 Space: O(n) 49 \u0026#34;\u0026#34;\u0026#34; 50 n = len(cards) 51 if n \u0026lt; 3: 52 return [] 53 54 counts = Counter(cards) 55 unique = list(counts.keys()) 56 k = len(unique[0]) if unique else 0 57 unique_set = set(unique) 58 59 # Iterate over pairs of unique cards (still fine; counts handle duplicates) 60 for i in range(len(unique)): 61 for j in range(i, len(unique)): 62 a = unique[i] 63 b = unique[j] 64 65 need = tuple(_third_value_mod3(a[d], b[d]) for d in range(k)) 66 if need not in unique_set: 67 continue 68 69 # Verify availability of 3 cards considering duplicates 70 # Build multiset requirement 71 req = Counter([a, b, need]) 72 ok = True 73 for card, r in req.items(): 74 if counts[card] \u0026lt; r: 75 ok = False 76 break 77 if ok and is_set([a, b, need]): 78 return [a, b, need] 79 80 return [] "},{"id":74,"href":"/tech-interview-prep/problems/set-matrix-zeroes/","title":"Set matrix zeroes","section":"All Problems","content":"Set matrix zeroes# Levels:\u0026ensp;level-3 Data structures:\u0026ensp;array Practice Link# LeetCode\nDescription# Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in-place. Examples# 1Input: 2[ 3 [1,1,1], 4 [1,0,1], 5 [1,1,1] 6] 7Output: 8[ 9 [1,0,1], 10 [0,0,0], 11 [1,0,1] 12] 1Input: 2[ 3 [0,1,2,0], 4 [3,4,5,2], 5 [1,3,1,5] 6] 7Output: 8[ 9 [0,0,0,0], 10 [0,4,5,0], 11 [0,3,1,0] 12]Follow up# A straight forward solution using O(mn) space is probably a bad idea. A simple improvement uses O(m + n) space, but still not the best solution. Could you devise a constant space solution? Python Solution# 1class Solution: 2 # @param {integer[][]} matrix 3 # @return {void} Do not return anything, modify matrix in-place instead. 4 def setZeroes(self, matrix): 5 m = len(matrix) 6 if m == 0: 7 return 8 n = len(matrix[0]) 9 10 row_zero = False 11 for i in range(m): 12 if matrix[i][0] == 0: 13 row_zero = True 14 col_zero = False 15 for j in range(n): 16 if matrix[0][j] == 0: 17 col_zero = True 18 19 for i in range(1, m): 20 for j in range(1, n): 21 if matrix[i][j] == 0: 22 matrix[i][0] = 0 23 matrix[0][j] = 0 24 25 for i in range(1, m): 26 if matrix[i][0] == 0: 27 for j in range(1, n): 28 matrix[i][j] = 0 29 30 for j in range(1, n): 31 if matrix[0][j] == 0: 32 for i in range(1, m): 33 matrix[i][j] = 0 34 35 if col_zero: 36 for j in range(n): 37 matrix[0][j] = 0 38 if row_zero: 39 for i in range(m): 40 matrix[i][0] = 0 "},{"id":75,"href":"/tech-interview-prep/problems/spiral-matrix/","title":"Spiral matrix","section":"All Problems","content":"Spiral matrix# Levels:\u0026ensp;level-2 Data structures:\u0026ensp;array Practice Link# LeetCode\nDescription# Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order. Examples# 1Input: 2[ 3 [ 1, 2, 3 ], 4 [ 4, 5, 6 ], 5 [ 7, 8, 9 ] 6] 7Output: [1,2,3,6,9,8,7,4,5]1Input: 2[ 3 [1, 2, 3, 4], 4 [5, 6, 7, 8], 5 [9,10,11,12] 6] 7Output: [1,2,3,4,8,12,11,10,9,5,6,7]Python Solution# 1def spiralOrder(self, matrix): 2 res = [] 3 while matrix: 4 res.extend(matrix.pop(0)) # left to right 5 if matrix and matrix[0]: # top to dwon 6 for row in matrix: 7 res.append(row.pop()) 8 if matrix: # right to left 9 res.extend(matrix.pop()[::-1]) 10 if matrix and matrix[0]: # bottom to up 11 for row in matrix[::-1]: 12 res.append(row.pop(0)) 13 return res "},{"id":76,"href":"/tech-interview-prep/problems/subtree-of-another-tree/","title":"Subtree of another tree","section":"All Problems","content":"Subtree of another tree# Levels:\u0026ensp;level-3 Data structures:\u0026ensp;tree Practice Link# LeetCode\nDescription# Given two non-empty binary trees s and t, check whether tree t has exactly the same structure and node values with a subtree of s. A subtree of s is a tree consists of a node in s and all of this node\u0026rsquo;s descendants. The tree s could also be considered as a subtree of itself. Examples# 1 2Given tree s: 3 4 3 5 / \\ 6 4 5 7 / \\ 8 1 2 9 10Given tree t: 11 4 12 / \\ 13 1 2 14 15 Output: true 1Given tree s: 2 3 3 4 / \\ 5 4 5 6 / \\ 7 1 2 8 / 9 0 10 11Given tree t: 12 4 13 / \\ 14 1 2 15 16Output: falsePython Solution# 1class TreeNode(object): 2 def __init__(self, x): 3 self.val = x 4 self.left = None 5 self.right = None 6 7 8class Solution(object): 9 def isSubtree(self, s, t): 10 \u0026#34;\u0026#34;\u0026#34; 11 :type s: TreeNode 12 :type t: TreeNode 13 :rtype: bool 14 \u0026#34;\u0026#34;\u0026#34; 15 def convert(p): 16 return \u0026#34;^\u0026#34; + str(p.val) + \u0026#34;#\u0026#34; + convert(p.left) + convert( 17 p.right) if p else \u0026#34;$\u0026#34; 18 19 return convert(t) in convert(s) "},{"id":77,"href":"/tech-interview-prep/problems/sum-of-two-integers/","title":"Sum of two integers","section":"All Problems","content":"Sum of two integers# Levels:\u0026ensp;level-1 Data structures:\u0026ensp;bits Practice Link# LeetCode\nDescription# Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -. Example# 1Input: a = 1, b = 2 2Output: 3Python Solution# 1# Add without using arithmetic operator 2def Add(x, y): 3 4 # Iterate till there is no carry 5 while (y != 0): 6 7 # carry now contains common 8 # set bits of x and y 9 carry = x \u0026amp; y 10 11 # Sum of bits of x and y where at 12 # least one of the bits is not set 13 x = x ^ y 14 15 # Carry is shifted by one so that 16 # adding it to x gives the required sum 17 y = carry \u0026lt;\u0026lt; 1 18 19 return x 20 21 22print(Add(15, 32)) "},{"id":78,"href":"/tech-interview-prep/problems/three-sum/","title":"Three sum","section":"All Problems","content":"Three sum# Levels:\u0026ensp;level-2 Data structures:\u0026ensp;array,\u0026ensp;hash-table Practice Link# LeetCode\nDescription# Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Note:\nThe solution set must not contain duplicate triplets. Python Solution# 1class Solution(object): 2 def threeSum(self, nums): 3 \u0026#34;\u0026#34;\u0026#34; 4 :type nums: List[int] 5 :rtype: List[List[int]] 6 \u0026#34;\u0026#34;\u0026#34; 7 if not nums: 8 return [] 9 res = [] 10 nums.sort() 11 for i in range(len(nums) - 2): 12 # adjacent duplicate elements would cause duplicate triplets 13 if i \u0026gt; 0 and nums[i] == nums[i - 1]: 14 continue 15 l, r = i + 1, len(nums) - 1 16 while l \u0026lt; r: 17 s = nums[i] + nums[l] + nums[r] 18 if s \u0026lt; 0: 19 l += 1 20 elif s \u0026gt; 0: 21 r -= 1 22 else: 23 res.append((nums[i], nums[l], nums[r])) 24 # adjacent duplicate elements would cause duplicate triplets 25 # Increment left and right until duplicates are eliminated 26 while l \u0026lt; r and nums[l] == nums[l + 1]: 27 l += 1 28 while l \u0026lt; r and nums[r] == nums[r - 1]: 29 r -= 1 30 l += 1 31 r -= 1 32 return res 33 34 35in_arrs = [ 36 [-1, 0, 1, 2, -1, -4], 37 [1], 38 [], 39 None, 40] 41 42exp_out = [ 43 set([ 44 (-1, 0, 1), 45 (-1, -1, 2), 46 ]), 47 set([]), 48 set([]), 49 set([]), 50] 51 52if __name__ == \u0026#34;__main__\u0026#34;: 53 54 sol = Solution() 55 for idx, nin in enumerate(in_arrs): 56 resout = sol.threeSum(nin) 57 resout = set(map(tuple, resout)) 58 di = resout.symmetric_difference(exp_out[idx]) 59 print(resout, di, False if di else True) "},{"id":79,"href":"/tech-interview-prep/problems/top-k-frequent-elements/","title":"Top k frequent elements","section":"All Problems","content":"Top k frequent elements# Levels:\u0026ensp;level-3 Data structures:\u0026ensp;heap,\u0026ensp;hash-table Description# Given a non-empty array of integers, return the k most frequent elements. Note:\nYou may assume k is always valid, 1 ≤ k ≤ number of unique elements. Your algorithm\u0026rsquo;s time complexity must be better than O(n log n), where n is the array\u0026rsquo;s size. Examples# 1Input: nums = [1,1,1,2,2,3], k = 2 2Output: [1,2]1Input: nums = [1], k = 1 2Output: [1]Python Solution# 1import collections 2import heapq 3 4 5class Solution(object): 6 def topKFrequent(self, nums, k): 7 \u0026#34;\u0026#34;\u0026#34; 8 :type nums: List[int] 9 :type k: int 10 :rtype: List[int] 11 \u0026#34;\u0026#34;\u0026#34; 12 count = collections.Counter(nums) 13 return heapq.nlargest(k, list(count.keys()), key=count.get) "},{"id":80,"href":"/tech-interview-prep/problems/two-sum/","title":"Two sum","section":"All Problems","content":"Two sum# Levels:\u0026ensp;level-0 Data structures:\u0026ensp;array,\u0026ensp;hash-table Practice Link# LeetCode\nDescription# Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Python Solution# 1class Solution1(object): 2 def twoSum(self, nums, target): 3 \u0026#34;\u0026#34;\u0026#34; 4 :type nums: List[int] 5 :type target: int 6 :rtype: List[int] 7 nlog(n) complexity using sorting. 8 \u0026#34;\u0026#34;\u0026#34; 9 nums.sort() 10 l = len(nums) 11 start = 0 12 end = l - 1 13 while start \u0026lt; end: 14 s = nums[start] + nums[end] 15 if s == target: 16 return [start, end] 17 if s \u0026gt; target: 18 end -= 1 19 continue 20 start += 1 21 return [] 22 23 24class Solution2(object): 25 def twoSum(self, nums, target): 26 \u0026#34;\u0026#34;\u0026#34; 27 :type nums: List[int] 28 :type target: int 29 :rtype: List[int] 30 O(n) complexity using hashmap. 31 \u0026#34;\u0026#34;\u0026#34; 32 m = {} 33 for idx, num in enumerate(nums): 34 complement = target - num 35 if complement in m: 36 return [idx, m[complement]] 37 m[num] = idx 38 return [] 39 40 41if __name__ == \u0026#34;__main__\u0026#34;: 42 nin = [2, 1, 2, 1, 0, 1, 2] 43 tin = 3 44 #p = [3,3,5,0,0,3,1,4] 45 sol = Solution2() 46 r = sol.twoSum(nin, tin) 47 print(r) "},{"id":81,"href":"/tech-interview-prep/problems/unique-paths/","title":"Unique paths","section":"All Problems","content":"Unique paths# Levels:\u0026ensp;level-4 Data structures:\u0026ensp;array Algorithms:\u0026ensp;dynamic-programming Practice Link# LeetCode\nDescription# A robot is located at the top-left corner of a m x n grid (marked \u0026lsquo;Start\u0026rsquo; in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked \u0026lsquo;Finish\u0026rsquo; in the diagram below). How many possible unique paths are there? Examples# 1Input: m = 3, n = 2 2Output: 3 3Explanation: 4From the top-left corner, there are a total of 3 ways to reach the bottom-right corner: 51. Right -\u0026gt; Right -\u0026gt; Down 62. Right -\u0026gt; Down -\u0026gt; Right 73. Down -\u0026gt; Right -\u0026gt; Right1Input: m = 7, n = 3 2Output: 28Constraints:\n1 \u0026lt;= m, n \u0026lt;= 100 It\u0026rsquo;s guaranteed that the answer will be less than or equal to 2 * 10 ^ 9. Python Solution# 1class Solution: 2 # @return an integer 3 def uniquePaths(self, m, n): 4 aux = [[1 for x in range(n)] for x in range(m)] 5 for i in range(1, m): 6 for j in range(1, n): 7 aux[i][j] = aux[i][j - 1] + aux[i - 1][j] 8 return aux[-1][-1] "},{"id":82,"href":"/tech-interview-prep/problems/valid-anagram/","title":"Valid anagram","section":"All Problems","content":"Valid anagram# Levels:\u0026ensp;level-1 Data structures:\u0026ensp;string,\u0026ensp;hash-table Practice Link# LeetCode\nDescription# Given two strings s and t, write a function to determine if t is an anagram of s. Note:\nYou may assume the string contains only lowercase alphabets. Examples# 1Input: s = \u0026#34;anagram\u0026#34;, t = \u0026#34;nagaram\u0026#34; 2Output: true1Input: s = \u0026#34;rat\u0026#34;, t = \u0026#34;car\u0026#34; 2Output: falseFollow up# What if the inputs contain unicode characters? How would you adapt your solution to such case? Thinking# This can be solved either by Sorting or hashing. Python Solution# 1import collections 2 3 4# Sorting solution 5def isAnagram(self, s, t): 6 if len(s) != len(t): 7 return False 8 return sorted(s) == sorted(t) 9 10 11# One liner with using counter 12def isAnagramCounter(self, s, t): 13 return collections.Counter(s) == collections.Counter(t) 14 15 16# using dicts 17def isAnagramDict(self, s, t): 18 dic1, dic2 = [0] * 26, [0] * 26 19 for item in s: 20 dic1[ord(item) - ord(\u0026#39;a\u0026#39;)] += 1 21 for item in t: 22 dic2[ord(item) - ord(\u0026#39;a\u0026#39;)] += 1 23 return dic1 == dic2 "},{"id":83,"href":"/tech-interview-prep/problems/valid-palindrome/","title":"Valid palindrome","section":"All Problems","content":"Valid palindrome# Levels:\u0026ensp;level-2 Data structures:\u0026ensp;string Practice Link# LeetCode\nDescription# Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases. Note:\nFor the purpose of this problem, we define empty string as valid palindrome. Examples# 1Input: \u0026#34;A man, a plan, a canal: Panama\u0026#34; 2Output: true1Input: \u0026#34;race a car\u0026#34; 2Output: falsePython Solution# 1class Solution(object): 2 def isPalindrome(self, s): 3 \u0026#34;\u0026#34;\u0026#34; 4 :type s: str 5 :rtype: bool 6 \u0026#34;\u0026#34;\u0026#34; 7 8 l, r = 0, len(s) - 1 9 while l \u0026lt; r: 10 while l \u0026lt; r and not s[l].isalnum(): 11 l += 1 12 while l \u0026lt; r and not s[r].isalnum(): 13 r -= 1 14 if s[l].lower() != s[r].lower(): 15 return False 16 l += 1 17 r -= 1 18 return True 19 20 # Use pythonic inbuilt functions 21 def isPalindromeInbuilt(self, s): 22 s = \u0026#39;\u0026#39;.join(e for e in s if e.isalnum()).lower() 23 return s == s[::-1] "},{"id":84,"href":"/tech-interview-prep/problems/valid-parentheses/","title":"Valid parentheses","section":"All Problems","content":"Valid parentheses# Levels:\u0026ensp;level-1 Data structures:\u0026ensp;string,\u0026ensp;stack Practice Link# LeetCode\nDescription# Given a string containing just the characters \u0026lsquo;(\u0026rsquo;, \u0026lsquo;)\u0026rsquo;, \u0026lsquo;{\u0026rsquo;, \u0026lsquo;}\u0026rsquo;, \u0026lsquo;[\u0026rsquo; and \u0026lsquo;]\u0026rsquo;, determine if the input string is valid. An input string is valid if: Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Note:\nAn empty string is also considered valid. Examples# 1Input: \u0026#34;()[]{}\u0026#34; 2Output: true1# Input: \u0026#34;([)]\u0026#34; 2# Output: falsePython Solution# 1class Solution(object): 2 def isValid(self, s): 3 \u0026#34;\u0026#34;\u0026#34; 4 :type s: str 5 :rtype: bool 6 \u0026#34;\u0026#34;\u0026#34; 7 8 # The stack to keep track of opening brackets. 9 stack = [] 10 11 # Hash map for keeping track of mappings. This keeps the code very clean. 12 # Also makes adding more types of parenthesis easier 13 mapping = {\u0026#34;)\u0026#34;: \u0026#34;(\u0026#34;, \u0026#34;}\u0026#34;: \u0026#34;{\u0026#34;, \u0026#34;]\u0026#34;: \u0026#34;[\u0026#34;} 14 15 # For every bracket in the expression. 16 for char in s: 17 18 # If the character is an closing bracket 19 if char in mapping: 20 21 # Pop the topmost element from the stack, if it is non empty 22 # Otherwise assign a dummy value of \u0026#39;#\u0026#39; to the top_element variable 23 top_element = stack.pop() if stack else \u0026#39;#\u0026#39; 24 25 # The mapping for the opening bracket in our hash and the top 26 # element of the stack don\u0026#39;t match, return False 27 if mapping[char] != top_element: 28 return False 29 else: 30 # We have an opening bracket, simply push it onto the stack. 31 stack.append(char) 32 33 # In the end, if the stack is empty, then we have a valid expression. 34 # The stack won\u0026#39;t be empty for cases like ((() 35 return not stack "},{"id":85,"href":"/tech-interview-prep/problems/validate-binary-search-tree/","title":"Validate a binary search tree","section":"All Problems","content":"Validate a binary search tree# Levels:\u0026ensp;level-2 Data structures:\u0026ensp;tree Algorithms:\u0026ensp;dfs Practice Link# LeetCode\nDescription# Given a binary tree, determine if it is a valid binary search tree (BST). Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than the node\u0026rsquo;s key. The right subtree of a node contains only nodes with keys greater than the node\u0026rsquo;s key. Both the left and right subtrees must also be binary search trees. Examples# 1 2 2 / \\ 3 1 3 4 5Input: [2,1,3] 6Output: true1 5 2 / \\ 3 1 4 4 / \\ 5 3 6 6 7Input: [5,1,4,null,null,3,6] 8Output: false 9Explanation: The root node\u0026#39;s value is 5 but its right child\u0026#39;s value is 4.Python Solution# 1# Definition for a binary tree node. 2class TreeNode(object): 3 def __init__(self, x): 4 self.val = x 5 self.left = None 6 self.right = None 7 8 9class Solution: 10 # Recursive solution 11 def isValidBST(self, root): 12 \u0026#34;\u0026#34;\u0026#34; 13 :type root: TreeNode 14 :rtype: bool 15 \u0026#34;\u0026#34;\u0026#34; 16 def helper(node, lower=float(\u0026#39;-inf\u0026#39;), upper=float(\u0026#39;inf\u0026#39;)): 17 if not node: 18 return True 19 20 val = node.val 21 if val \u0026lt;= lower or val \u0026gt;= upper: 22 return False 23 24 if not helper(node.right, val, upper): 25 return False 26 if not helper(node.left, lower, val): 27 return False 28 return True 29 30 return helper(root) 31 32 # Use inorder traversal 33 def isValidBSTInorder(self, root): 34 \u0026#34;\u0026#34;\u0026#34; 35 :type root: TreeNode 36 :rtype: bool 37 \u0026#34;\u0026#34;\u0026#34; 38 stack, inorder = [], float(\u0026#39;-inf\u0026#39;) 39 40 while stack or root: 41 while root: 42 stack.append(root) 43 root = root.left 44 root = stack.pop() 45 # If next element in inorder traversal 46 # is smaller than the previous one 47 # that\u0026#39;s not BST. 48 if root.val \u0026lt;= inorder: 49 return False 50 inorder = root.val 51 root = root.right 52 53 return True "},{"id":86,"href":"/tech-interview-prep/problems/verify-lexicographic-sort-custom/","title":"Verify Lexicographic Sort With Custom Alphabet","section":"All Problems","content":"Verify Lexicographic Sort With Custom Alphabet# Levels:\u0026ensp;level-3 Data structures:\u0026ensp;string,\u0026ensp;hash-table Patterns:\u0026ensp;hashing Practice Link# LeetCode\nDescription# You are given: words: a list of lowercase words. order: a custom ordering of characters (e.g., ['c','b','a','t', ...]). Return True if words is sorted lexicographically according to order, else return False. Lexicographic rules: Compare characters left-to-right using the custom order. If all characters match up to the shorter length, the shorter word must come first. Examples# 1Input: 2words = [\u0026#34;cat\u0026#34;, \u0026#34;bat\u0026#34;, \u0026#34;tab\u0026#34;] 3order = [\u0026#39;c\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;t\u0026#39;] 4Output: True1Input: 2words = [\u0026#34;cat\u0026#34;, \u0026#34;tab\u0026#34;, \u0026#34;car\u0026#34;] 3order = [\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;,...,\u0026#39;z\u0026#39;] (normal alphabet) 4Output: FalsePython Solution# 1from typing import Dict, List 2 3 4def is_sorted_alien(words: List[str], order: List[str]) -\u0026gt; bool: 5 \u0026#34;\u0026#34;\u0026#34; 6 Returns True if `words` is sorted under the custom alphabet `order`. 7 8 Time: O(total characters across comparisons) ~= O(sum(len(words[i]))) 9 Space: O(|alphabet|) 10 \u0026#34;\u0026#34;\u0026#34; 11 if not words: 12 return True 13 14 rank: Dict[str, int] = {ch: i for i, ch in enumerate(order)} 15 16 def in_correct_order(a: str, b: str) -\u0026gt; bool: 17 # Compare a vs b according to rank 18 i = 0 19 n, m = len(a), len(b) 20 while i \u0026lt; n and i \u0026lt; m: 21 ca, cb = a[i], b[i] 22 if ca != cb: 23 return rank[ca] \u0026lt; rank[cb] 24 i += 1 25 # All matched up to min length: shorter must come first 26 return n \u0026lt;= m 27 28 for i in range(len(words) - 1): 29 if not in_correct_order(words[i], words[i + 1]): 30 return False 31 return True "},{"id":87,"href":"/tech-interview-prep/problems/word-break/","title":"Word break","section":"All Problems","content":"Word break# Levels:\u0026ensp;level-4 Data structures:\u0026ensp;string Algorithms:\u0026ensp;dynamic-programming Practice Link# LeetCode\nDescription# Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words. Note:\nThe same word in the dictionary may be reused multiple times in the segmentation. You may assume the dictionary does not contain duplicate words. Examples# 1Input: s = \u0026#34;leetcode\u0026#34;, wordDict = [\u0026#34;leet\u0026#34;, \u0026#34;code\u0026#34;] 2Output: true 3Explanation: Return true because \u0026#34;leetcode\u0026#34; can be segmented as \u0026#34;leet code\u0026#34;.1Input: s = \u0026#34;applepenapple\u0026#34;, wordDict = [\u0026#34;apple\u0026#34;, \u0026#34;pen\u0026#34;] 2Output: true 3Explanation: Return true because \u0026#34;applepenapple\u0026#34; can be segmented as \u0026#34;apple pen apple\u0026#34;. 4 Note that you are allowed to reuse a dictionary word.1Input: s = \u0026#34;catsandog\u0026#34;, wordDict = [\u0026#34;cats\u0026#34;, \u0026#34;dog\u0026#34;, \u0026#34;sand\u0026#34;, \u0026#34;and\u0026#34;, \u0026#34;cat\u0026#34;] 2Output: falsePython Solution# 1class Solution(object): 2 def wordBreak(self, s, wordDict): 3 \u0026#34;\u0026#34;\u0026#34; 4 :type s: str 5 :type wordDict: Set[str] 6 :rtype: bool 7 \u0026#34;\u0026#34;\u0026#34; 8 # dp[i] means s[:i+1] can be segmented into words in the wordDicts 9 dp = [False] * (len(s) + 1) 10 dp[0] = True 11 for i in range(len(s)): 12 if dp[i]: 13 for j in range(i, len(s)): 14 if s[i:j + 1] in wordDict: 15 dp[j + 1] = True 16 17 return dp[-1] "},{"id":88,"href":"/tech-interview-prep/problems/word-search/","title":"Word search","section":"All Problems","content":"Word search# Levels:\u0026ensp;level-4 Data structures:\u0026ensp;array Patterns:\u0026ensp;backtracking Practice Link# LeetCode\nDescription# Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where \u0026ldquo;adjacent\u0026rdquo; cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. Example# 1board = 2[ 3 [\u0026#39;A\u0026#39;,\u0026#39;B\u0026#39;,\u0026#39;C\u0026#39;,\u0026#39;E\u0026#39;], 4 [\u0026#39;S\u0026#39;,\u0026#39;F\u0026#39;,\u0026#39;C\u0026#39;,\u0026#39;S\u0026#39;], 5 [\u0026#39;A\u0026#39;,\u0026#39;D\u0026#39;,\u0026#39;E\u0026#39;,\u0026#39;E\u0026#39;] 6] 7 8Given word = \u0026#34;ABCCED\u0026#34;, return true. 9Given word = \u0026#34;SEE\u0026#34;, return true. 10Given word = \u0026#34;ABCB\u0026#34;, return false.Constraints:\nBoard and word consists only of lowercase and uppercase English letters. 1 \u0026lt;= board.length \u0026lt;= 200 1 \u0026lt;= board[i].length \u0026lt;= 200 1 \u0026lt;= word.length \u0026lt;= 10^3 Python Solution# 1class Solution(object): 2 def exist(self, board, word): 3 \u0026#34;\u0026#34;\u0026#34; 4 :type board: List[List[str]] 5 :type word: str 6 :rtype: bool 7 \u0026#34;\u0026#34;\u0026#34; 8 if not board: 9 return False 10 for i in range(len(board)): 11 for j in range(len(board[0])): 12 if self.dfs(board, i, j, word): 13 return True 14 return False 15 16 # check whether can find word, start at (i,j) position 17 def dfs(self, board, i, j, word): 18 if len(word) == 0: # all the characters are checked 19 return True 20 if i \u0026lt; 0 or i \u0026gt;= len(board) or j \u0026lt; 0 or j \u0026gt;= len( 21 board[0]) or word[0] != board[i][j]: 22 return False 23 tmp = board[i][j] # first character is found, check the remaining part 24 board[i][j] = \u0026#34;#\u0026#34; # avoid visit agian 25 # check whether can find \u0026#34;word\u0026#34; along one direction 26 res = self.dfs(board, i+1, j, word[1:]) or self.dfs(board, i-1, j, word[1:]) \\ 27 or self.dfs(board, i, j+1, word[1:]) or self.dfs(board, i, j-1, word[1:]) 28 board[i][j] = tmp 29 return res "},{"id":89,"href":"/tech-interview-prep/problems/word-search-ii/","title":"Word search II","section":"All Problems","content":"Word search II# Levels:\u0026ensp;level-5 Data structures:\u0026ensp;trie Patterns:\u0026ensp;backtracking Practice Link# LeetCode\nDescription# Given a 2D board and a list of words from the dictionary, find all words in the board. Each word must be constructed from letters of sequentially adjacent cell, where \u0026ldquo;adjacent\u0026rdquo; cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word. Note:\nAll inputs are consist of lowercase letters a-z. The values of words are distinct. Example# 1Input: 2board = [ 3 [\u0026#39;o\u0026#39;,\u0026#39;a\u0026#39;,\u0026#39;a\u0026#39;,\u0026#39;n\u0026#39;], 4 [\u0026#39;e\u0026#39;,\u0026#39;t\u0026#39;,\u0026#39;a\u0026#39;,\u0026#39;e\u0026#39;], 5 [\u0026#39;i\u0026#39;,\u0026#39;h\u0026#39;,\u0026#39;k\u0026#39;,\u0026#39;r\u0026#39;], 6 [\u0026#39;i\u0026#39;,\u0026#39;f\u0026#39;,\u0026#39;l\u0026#39;,\u0026#39;v\u0026#39;] 7] 8words = [\u0026#34;oath\u0026#34;,\u0026#34;pea\u0026#34;,\u0026#34;eat\u0026#34;,\u0026#34;rain\u0026#34;] 9 10Output: [\u0026#34;eat\u0026#34;,\u0026#34;oath\u0026#34;]Python Solution# 1import collections 2 3 4class TrieNode(): 5 def __init__(self): 6 self.children = collections.defaultdict(TrieNode) 7 self.isWord = False 8 9 10class Trie(): 11 def __init__(self): 12 self.root = TrieNode() 13 14 def insert(self, word): 15 node = self.root 16 for w in word: 17 node = node.children[w] 18 node.isWord = True 19 20 def search(self, word): 21 node = self.root 22 for w in word: 23 node = node.children.get(w) 24 if not node: 25 return False 26 return node.isWord 27 28 29class Solution(object): 30 def findWords(self, board, words): 31 res = [] 32 trie = Trie() 33 node = trie.root 34 for w in words: 35 trie.insert(w) 36 for i in range(len(board)): 37 for j in range(len(board[0])): 38 self.dfs(board, node, i, j, \u0026#34;\u0026#34;, res) 39 return res 40 41 def dfs(self, board, node, i, j, path, res): 42 if node.isWord: 43 res.append(path) 44 node.isWord = False 45 if i \u0026lt; 0 or i \u0026gt;= len(board) or j \u0026lt; 0 or j \u0026gt;= len(board[0]): 46 return 47 tmp = board[i][j] 48 node = node.children.get(tmp) 49 if not node: 50 return 51 board[i][j] = \u0026#34;#\u0026#34; 52 self.dfs(board, node, i + 1, j, path + tmp, res) 53 self.dfs(board, node, i - 1, j, path + tmp, res) 54 self.dfs(board, node, i, j - 1, path + tmp, res) 55 self.dfs(board, node, i, j + 1, path + tmp, res) 56 board[i][j] = tmp "}]